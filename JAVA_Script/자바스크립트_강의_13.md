# 클로저의 활용

(메모장 보기)(이거 메모장 맨 마지막 빨간색 함수식->).... 안사라집니다. 가비지 컬렉션의 대상이 안됩니다.



클로저를 어떤 상황에서 써야 하는지 모르겟다. 언제써야 할지 모르겟다.<- 이건 당연한거다.

전역변수 썼더니 상태를 유지할수는 있으나 안전할수 없다. 

그래서 지역변수 썼더니 안전하게 보관할수는 있었지만 변경할수 없었다.

그러면 이때 클로저를 떠올리면 된다. 

![image-20200515134621560](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515134621560.png) 

![image-20200515134632836](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515134632836.png) 

위 코드가 함수형으로 만든거다.



## 자주 발생하는 실수

![image-20200515135413110](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515135413110.png) 

포문의 i가 전역이기 때문에. 포문안에 펑션(){} 에 클로저를 써야 한다.

자유변수: 클로저가 바로보고 있는 외부함수의.... ~다.

즉시실행함수는 인수를 전달할수 있으므로, ... 즉시 실행함수 내부에 있는... 똑같이 한다.

따라서 아래 코드처럼 코딩한다(옛날방식)

![image-20200515135838039](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515135838039.png) 

---

---

---

# 클래스

객체 만드는 방법: 클래스

객체 만드는 방법 클래스 말고 뭐 있지? 객체 리터럴, .....

자스는 객체지향언어냐? 객체 지향언어다. 근데 프로토타입 기반 언어다. 상속... 이란 개념을 구현했다.

근데 왜 자스에서 클래스가 필요하나? 왜 클래스를 도입하냐? 자스는 클래스가 필요없는건데 왜 클래스를 도입하냐 하면서 말이 많았는데, 답변은 없다.



클래스는, 자스가 천시받는 언어였어. 

태어난 이유는....

 

클래스로 우리가 객체를 만들어볼텐데, 우리에게 익숙한 person 객체를 만들어보자

객체를 만드는 애라서 파스칼케이스로 생성사 함수를 만들자

```js
class Person {
    
}
```

클래스 몸체에는 뭐만 올수 있냐면 메소드들만 올수 있다.

그 메소드에 올수 잇는건 3개인데 생성자라고도 불리우는 컨스트럭터랑 프로토타입 메소드, 정적 메소드 이렇게 3개 올수 잇다.  



컨스트럭터라는걸 만들어보자

```js
class Person {
 constructor() {
     // 생성자 함수 내부에서 하던일. 디스에다가 프로퍼티를 바인딩 하던 행위를 여기서 하는거다.
     this.naeme // 생성자 함수가 생성할 인스턴스였으면 얘는 클래스가 생성할 인스턴스를 가리킨다. //
         = 'Lee'; // 함수니까 세미콜론으로 끝낸다.
     this.age = 20;
 }   
}
console.log(typeof Person); // function
```

```js
class Person {
 constructor() {
     this.naeme = 'Lee'; 
     this.age = 20;
 }   
}
Person(); // Error
```

```js
class Person {
 constructor() {
     // 빈객체 만들어서 디스바인딩
     this.naeme = 'Lee'; 
     this.age = 20;
     // 여기서 암묵적으로 리턴을 반환한다.
 }   
}
const me = new Person(); 
-------------------------
    생성자 함수와 비슷하다.
    얘도 인스턴스 생성과정이 있겠지?  
```

```js
class Person {
 constructor(name, age) {
     this.naeme = name; 
     this.age = age;
 }   
}
const me = new Person('Lee', 20);
console.log(me); // Person {name: 'Lee', ageL 20}
```

새로운 객체 생성 매커니즘이 아니라 프로토타입이다. 

그러면 바로 위코드의 펄슨 객체의 상위는 누구일까요? 오브젝트.겟프로토타입오브(미) 하면 누가 나올까요?  펄슨.프로토타입이죠. 

생성자함수가 태어날때 프로토타입이랑 항상 쌍으로 태어난다. 

클래스는 생성자 함수의 문법적 설탕인가?  알고보면 문법적 설탕이냐 아니냐. 아니다. 차이점이 있다. 클래스가 더 엄격하다. 똑같이 동작 안한다. 그래서 문법적 설탕이라기 보다 새로운 객체 생성 방식으로 생각해야 한다. 



그럼 메소드를 구현해볼까요?

```js
function Person(name, age) {
     this.naeme = name; 
     this.age = age;
     this.sayHi = function (){
         console.log('Hi! My name is ' + this.name);
     };
 }   
 
var me = new Person('Lee', 20);  // 여기서 me는 인스턴스에 있다.왜지? 맨 위의 this가 인스턴스니까. 
me.sayHi(); // Hi! my name is Lee
------------------------------------
객체 만들때마다.....
```

```js
function Person(name, age) {
     this.naeme = name; 
     this.age = age;
    
    Person.prototype.sayHi = function () {
        console.log('Hi! My name is ' + this.name);
    }
         
     };
 }   
 
var me = new Person('Lee', 20);  // 여기서 me는 인스턴스에 있다.왜지? 맨 위의 this가 인스턴스니까. 
me.sayHi(); // Hi! my name is Lee
```

```js
function Person(name, age) {
     this.naeme = name; 
     this.age = age;
     }
    Person.prototype.sayHi = function () {
        console.log('Hi! My name is ' + this.name);
 }   
 
var me = new Person('Lee', 20);  
me.sayHi(); // Hi! my name is Lee
```

바로 위 코드는 프로토타입 메소드다

```js
class Person {
 constructor(name, age) {
     this.naeme = name; 
     this.age = age;
     this.sayHi = function () {
         console.log(`Hi! mu name is ${this.name}`);
     };// 인스턴스 메소드다.
 }   
}
const me = new Person('Lee', 20);
console.log(me); // Person {name: 'Lee', ageL 20}
```

```js
class Person {
 constructor(name, age) {
     this.naeme = name; 
     this.age = age;
 }
     sayHi = function () { // 여기서 sayHi 는 클래스....다.
         console.log(`Hi! mu name is ${this.name}`);
     };
 }   
}
const me = new Person('Lee', 20);
console.log(me); // Person {name: 'Lee', ageL 20}
```

```js
class Person {
 constructor(name, age) {
     this.naeme = name; 
     this.age = age;
 }
     // sayHi () { 
         console.log(`Hi! mu name is ${this.name}`);
     }; // 야가 프로토타입 메소드다
 }   
}
const me = new Person('Lee', 20);
console.log(me); // Person {name: 'Lee', ageL 20}
```

다시 es5 로 돌아와서

정적메소드란 무엇입니까? 하면, 인스턴스 메소드와 정적 메소드의 차이는?

어떻게 만드는거냐면

```js
class Person {
 constructor(name, age) {
     this.naeme = name; 
     this.age = age;
 }
     Person.prototype.sayHi = function () { 
         console.log('Hi! mu name is '+this.name);
     };
Person.sayHi = function (){
    console.log(`Hi!`);
};

var me = new Person('Lee', 20);
me.sayHi(); 
Person.sayHi(); // Hi! my name is Person <- 이렇게 나오는 이유는.... 우리가 의도한대로 안나오고 있다. undefined 가 나올줄 알았는데...
```

```js
class Person {
 constructor(name, age) {
     this.naeme = name; 
     this.age = age;
 }
   
sayHi(){
    console.log(`Hi! my name is ${this.name}`);
};
    
    static sayHi(){
        console.log() {
            console.log(`Hello!`);
        }
    }

```

![image-20200515151235932](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515151235932.png) 



왼쪽의 두번째는...

왼쪽의 세번째가 인스트럭터다.

오른쪽의 두번째를 호출하려면 인스턴스로 호출해야 한다.

오른쪽의 세번빼는 넌컨스트럭터다.

오른쪽은 일반함수로 호출할수 없다. 그래서 오른쪽이 더 엄격하다.



## 클래스 호이스팅

클래스도 호이스팅을 한다는 개념에서~ 

호이스팅하면 반드시 나오는건 모든 선언문은 전부 호이스팅을 한다. 

클래스도 선언문이다. 이 클래스 정의가 언제 평가되어질까? 선언문이 평가될때. 즉, 런타임이전이다.

클래스도 호이스팅 대상인데, 호이스팅 안되는것처럼 보인다. 얘도 일시적 사각지대에 빠진다.

그러면 또 다른 선언문중에, 이런게 잇다. (메모장 보기)

![image-20200515151626066](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515151626066.png) 

위 코드러럼 하지 마세요



## 메소드

클래스 몸체에는 0개 이상의 메소드만을 선언할수 있다. 

```js
class Person {
#name = '' // 이렇게 하면 프라이빗 된다.

constructor (name, age) {
this.#name = name;
this.age - age;
}
sayHi (){
console.log(`Hi! my name is ${this.name}`);
}
}
```

.... 모두 퍼블릭하다. ... 변경할수 있다. 

그러면 무슨 문제점이 생기지? 

### consturctot

생성자라고 한다.

생략할수 있다.  아무때나 생략가능한게 아니라 얘 문에 아무것도 없을때 생략가능하다.

예를 들어서

```js
class Foo() 
------------- 
    이거 된다.이렇게 하면 
    class Foo(
    constructor() // 암묵적으로 얘가 여기에 생기는거다.
    )
```

![image-20200515152920301](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515152920301.png) 

![image-20200515153047153](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515153047153.png) 

정적메소드는 어케 호출해야 할까?

.... 할수는 있지만 이상한거다. 

프로토타입 메소드는 왜 항상 .... 할까?

객체는 프로퍼티가 있다. 인스턴스 프로퍼티. 위코드에서 me를 보면 인스턴스 프로퍼티잖아. 

왜 굳이 저 위치에 놨을까? 인스턴스마다 name 값이 다르기때문이다. 만약에 같다면? 저기말고 위로 올라가야 한다. 근데 이름이 다 똑같을수 있나? 고유의 값을 가지는 것들은 다 저 위치에 있어야 한다.

그럼 왜 디스를 쓸까? 인스턴스의 프로퍼티를 볼려고 하는것이다.

그래서 정적 메소드와 프로토타입의 차이는 지금까지 말한거 잘 기억하고 있어야 한다.



예를 들어서 

```js
Math // 컨스트럭터가 아니다.
Math.하면 뒤에 나오는것들은 정적 메소드다. 
----------------------------------------
Math.max(1, 2, 3);   // 3
```

![image-20200515154253790](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515154253790.png) 

사각형이란 객체를 만들건데....

![image-20200515154743896](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515154743896.png) 

생성자 함수랑 똑같죠?

맨 처음에 인스턴스 만들고 두번째로 뭘 할까? 근데 클래스는 메소드도 잇어야 해서 메소드도 위치에 따라서 ... 갖다놔준다. 클래스는 이거까지 해준다.

## 클래스 확장

클래스를 확장하는거다.

확장하는데, 프로토타입 체인이랑 헷갈리면 안된다

```js
class Aimal{
constructor(name, weight, age){
    this.name = name;
    this.weight = weight;
    this.age = age;
}
    move(){
        console.log(`${this.name},Move!`);
    }
}

class Bird extends Animal{
//constructor(name, weight, age){
    this.name = name;
    this.weight = weight;
    this.age = age;
} // 얘넨 지운다. 

constructor(...args){
    super(... arfs);
} //암묵적으로 얘네가 생긴다. 여기서 수퍼는 무슨 의미냐면, ... 이런식으로 부른다. 이 수퍼는 얘의 컨스트럭터를 호출한다는 말이다.
//
    move(){
        console.log(`${this.name},Move!`);
    }
// 얘네도 지운다. 
    fly(){
        console.log(`${this.name},Fly!`);
    }
}
const bird = new Bird('치킨', 0.5, 1);
console.log(bird); // Bird  {name: '치킨', weight: 0.5, age: 1}
```

위 코드를 보면 객체지향의 기본이다. 

우리가 구현페이지 전에 들어가기전에 설계를 가진다. 

![image-20200515161644253](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515161644253.png) 

위 코드를 다중상속이라 한다. 위 코드가 클래스 기반이다.



![image-20200515161908268](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515161908268.png) 

수퍼는 키워드인데, 문법적으로는 키워드인데 아주 특수한 키워드다. 호출할수도 있고 참조할수도 있다.

호출하면 무슨 일이 일어나지? 수퍼 클래스의 생성자 함수를 호출한다. 참조하면 수퍼 클래스의 프로토토타입 체인 안에 있는 메소드를 .... 

![image-20200515162420644](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515162420644.png)  

수퍼 랑 디스 사이에.. 리턴 에이비씨 프로퍼티가 디스에 달려있는 상황이잖아요.





# es6 함수의 추가 기능

여기서 핵심음 화살표함수다. 

정말 중요하다.

코딩할때 5분에 한번씩 사용한다. 그만큼 사용빈도가 높다.

메소드의 구분은 무슨 얘기냐면 es5의 함수와 es6 의 함수는 차이가 있다.

es5 시절의 함수는 일반, 메소드, 생성자 함수로도 호출되는데 

es6에 새롭게 나온게 ... 축약표현이랑 화살표 함수다. 얘넨 생성자 함수로 호출못한다.

얘네는 프로토타입이 없다. 함수 객체는 모든 함수 객체는 ... 프로퍼티가 존재한다고 햇던거는 이제 뻥이다. 왜없다? 프로토타입이 있을 필요가 없다. 

따라서 화살표함수는 표현이 일반함수보다 간략하다. 근데 표현만 간략한게 아니라 내부 동작까지 간략하다. 그래서 굉장히 경량이다.

![image-20200515163407699](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515163407699.png) 

## 매개변수 선언

![image-20200515163753209](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515163753209.png) 

위의 화살표는 어떻게 받아들이면 되냐면, 기본에 변수를 선언할때 ... 괄호를 열고 닫고 매개변수를 하고 중괄효 열고 함수 몸체 만들었다면 화살표함수는 저렇게 해서 매개변수를 함수 몸체 안으로 전달한다는 표현이다. 

두줄로 만들때는 중괄호를 생략할수 없다. 리턴문이 두번째 줄에 잇으면 리턴줄은 생략할수 없다.

![image-20200515164242213](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515164242213.png) 

소괄호로 닫아줘야한다. 주의해줘야 한다. 



## 화살표 함수와 일반 함수의 차이

화살표 함수는 넌 컨스트럭터다.

화살표 함수에는 디스가 없다. 일반 함수가 호출되면 함수 평가에 들어간다. 그러면 함수 실행 컨텍스트를 만들고 함수 렉시컬 환경이 만들어지고 함수 환경 레코드가 만들어졌을때 디스가 결정되잖아. 디스가 결정된다는 말은 함수 환경 레코드에 디스 벨류라는 값이 디스값이 박히는 거다.

함수가 만들어질때 디스 값이 결정되어져서 디스를 갖고있는것이다.

es5 시절에는 모든... 다 디스를 볼수 있었다. 따라서 es5 시절에는 디스를 상위 스코프에서 디스를 본다는 개념이 없다. 왤까? 상위 스코프의 식별자를 본다는 의미는 자신의 스코프에 식별자가 없다는 얘기잖아.

근데 화살표함수는 디스바인딩이 없기 때문에 상위 스코프의 디스를 본다.

화살표 함수가 다른 화살표 함수에 중첩함수일수 있잖아. 상위 스코프에도 디스 없고 그 위도 없고 그 위도 없고 그래서 전역까지 올라가는 경우가 있다. 

왜 이렇게 설계가 되엇을까? 예전에 디스를 배울때 메소드가 있었어. 메소드 안에 콜백이 있었어. 콜백은 일반함수를 호출했어. ... 불일치 하는 문제가 발생했어. 

일반함수를 호출할때... 

이제부터는 콜백을 쓸때 다 화살표함수를 쓰자. 

![image-20200515164916495](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515164916495.png) 

위 코드의 콜백 함수의 상위스코프는 어디일까? 

![image-20200515165121236](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515165121236.png) 

함수의 상위 스코프는 전역이다. 윈도우다. 왜냐면 상위 스코프의 .. 가 윈도우니까. 

![image-20200515165231017](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515165231017.png) 

![image-20200515165240315](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515165240315.png) 

바로 위 코드에서 주의할것. 인크리스는 프로퍼티키다. 콜론 뒤는 프로퍼티 값이다. 

바로 위코드에서 디스는 윈도우다. 

![image-20200515165612971](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515165612971.png) 

디스가 없잖아요. 

![image-20200515165812829](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200515165812829.png) 

얘는 인스턴스 메소드다. 얘의 얘를 결정하려면 상위 스코프를 알아야 한다. 그럼 그 상위 스코프는 누구일까? 

이 함수의 상위 스코프를 결정해야 하잖아, 그 상위 스코프가 누구냐고. 정답은 컨스트럭터 내부이다. 컨트럭터 없는데? 왜 컨스트럭터일까? 얘는 이렇게 생각해야해. 인스턴스 프로퍼티는 컨스트럭터 내부의 디스에 담는다고 했잖아. 결국 누굴 가리킨다? 인스턴트를 가리키게 된다. 



```js
const sum = function (){
Array.prototype.slice
arguments
}
```

아규먼트가 배열이라면 

```js
arguments.slice 
이렇게 호출할수 있는건데 아니니까
```

```js
const sum = function (){
const arr = Array.prototype.slice.call(arguments);
    arr.reduce(acc, cur) => acc + cur, 0);
}
console.log(sum(1, 2, 3)); // 
```



# 배열

배열할때 주의할게 잇다. 

자스에는 [ ] 이렇게 하면 배열 객체를 만들어준다. 

미리 말하지만, 자스에서 배열이라고 하는건 배열이 아니다. 뭔얘기일까? 그럼 배열의 본뜻이 있다는거잖아. 본뜻은 데이터 스트럭쳐. 

알고리즘 공부할때 항상 따라다니는게 데이터 스트럭쳐이다. 

알고리즘을 구현할때 데이터 스트럭쳐를 바탕으로 하는 거다. 

원래는 데이터 스트럭쳐가 먼저이다. 이거 관련 책을 피면 배열이라는게 처음부터 나온다. 여기서 말하는 배열과 자스에서 말하는 배열은 다른것이다.

데이터 스트럭쳐에서 말하는 배열은 메모리 얘기부터 나온다. 

(메모장 보기) 데이터 스트럭쳐의 배열 : 밀집해서 딱딱 붙혀서 하는거, 칸마다 크기가 동일해야 한다. 

얘는 어떤 장점이 있을까?

자스는 배열을 만들때 리턴을 만든다. 진짜 배열(데이터 스트럭쳐의 배열)은 모든 요소들의 타입이 일치하여야 한다.  근데 자스는 [1, ture, {} ] 이게 된다. 자스에서 배열은 객체다. 

콘솔로그로 자스에서 배열을 들여다보면 0: 1 , 1: true, 2: { } 이렇게 나온다.다양한 타입의 ... 

해시테이블로 만들어진것으로 보여진다. 그냥 객체다. 다만, 자스엔진을 만드는 제조사가, 최적화에 힘을 엄청 쏟았다. 그래서 굉장히 복잡하게 도는데, [ ] 안에 똑같은 타입으로 만들면 데이터 스트럭쳐의 배열처럼 만든다. 







27, 28, 29 예습















