# 객체란

JS는 대부분 **<u>객체</u>** 기반의 프로그래밍 언어이며, 프로토타입의 언어이다.<br> `객체타입` 언어라고도 할수 있다.

```javascript
객체 타입 언어
: 다양한 타입의 값들을 하나의 단위로 구성된 복합적인 자료구조를 의미한다.
```

우리가 하고자 하는 프로그래밍 세상에서 <u>**객체**</u>는 내가 관심이 있는 대상에 대한 특징만<br>나열하면 된다. (내가 인지할수 있는 대상에 대한 특징)

- 객체 

  - 0 개 이상의 프로퍼티의 집합이며, 프로퍼티 키와 프로퍼티 값으로 구성된다.
  
  - 일반 함수와 구분하기 위해 **<u>프로퍼티 값이 함수일 경우에는 메소드</u>**라고 한다. 
  
- 부모관계를 맺는다. 즉, 상속되는 경우가 있다. 
  
- 함수로 객체를 생성하기도 하며 함수 자체가 객체이다. 
  
- 다양한 객체 생성 방식
  
    - `객체 리터럴` 사용
    
    >- 객체를 생성하기 위한 표기법
      >
      >- JS의 유연함과 강력함을 대표하는 객체 생성방식
    >
      >- 중괄호 내에 0개 이상의 프로퍼티를 정의(중괄호 내부의 내용들은 서로 관련이 있는 내용들로 뭉쳐있다.)
      >
      >  ```javascript
      >  중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성된다.
      >  ex)
      >  var empty = {} // 빈객체 생성
      >  console.log(typeof empty); 
      >  ----------------------------
      >  ==> 결과값으로 "Object" 란 값 도출
      >  ----------------------------
      >  ->바로 위코드가 빈 객체를 생성한 코드이다.
      >  ```
      >
      >- 숫자 리터럴로 숫자값을 만들어내고, 문자 리터럴로 문자값을 만들어내듯이, 객체 리터럴로 객체를 생성한다.
      >- <p style="color:red";>변수에 할당이 이루어지는 시점에 JS엔진은 객체 리터럴을 해석하여 객체를 생성한다.</p>
      >
      >- 객체 리터럴의 닫는 중괄호 뒤에는 세미콜론을 붙인다.
    
    - Object 생성자 함수
    - 생성자 함수
    - Object reate 메소드
    - 클래스

---

![캡쳐86](https://user-images.githubusercontent.com/62126380/80863568-57046b80-8cb8-11ea-8ced-47a5c0f00907.PNG) 

![캡쳐85](https://user-images.githubusercontent.com/62126380/80863452-6931da00-8cb7-11ea-9f8d-9fbfd2208407.PNG) 

 ## 프로퍼티 

- 객체의 상태를 나타내는 값(값이 변한다는 의미의 '상태')

- 프로퍼티를 나열할 때는 쉼표로 구분한다.<br>일반적으로 마지막 프로퍼티 뒤에는 쉼표를 사용하지 않으나, 사용해도 무방하다.

  ### 프로퍼티 키

  - 빈 문자열을 포함하는 모든 문자열 또는 symbol 값

  - 프로퍼티 키는 명사로 짓자.

  - 프로퍼티 키에 관련하여 주의할 점

    1. 프로퍼티 값에 접근할 수 있는 식별자 역할을 하며 문자열로 만들어진다.<br>프로퍼티 키를 만들때 <u>식별자 네이밍 규칙</u>을 지키면서 만들지 않아도 되지만 웬만해선 지켜서 만들자

       ```javascript
       ex)
       
       var person = {
         firstName: 'Se-jin'   // 식별자 네이밍 규칙 지킴 
           					// 내부적으로 따옴표가 생략이 되어있는 상태.
         'last-name': 'Oh'     // 식별자 네이밍 규칙 지킴
         gender-type : 'man'   // 식별자 네이밍 규칙 X // SyntaxError
       };
       ----------------------------------
       
       식별자 네이밍 규칙을 지킨 상태라면 ' '을 생략해도 되지만, 규칙을 지키지 않은 채로 식별자를 생성하려면 ' ' 을 꼭 써야 한다. <- 귀찮으니까 규칙 지켜서 쓰자
       ```

    2. 프로퍼티 키에 문자열이나, symbol 값 외의 타입으로 사용해도 되지만 암묵적 타입변환으로 인해 문자열로 바뀐다.

       ```javascript
       var foo = {
       0: 1, 
       1: 2,
       2: 3
       };
       console.log(foo); // {0:1, 1:2, 2:3}
       ------------------
       0,1,2 가 암묵적 타입변환으로 인해 문자열로 변환되었다.
       ```

    3. 이미 선언한 프로퍼티 키를 또 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다. 

       ```javascript
       var foo = {
       name: 'Lee',
       name: 'Kim'
       };
       console.log(foo);   // {name: "Kim"}
       -------------------------------------
       나중에 선언한 프로퍼티 값이 먼저 선언한 프로퍼티 값 위에 덮어씌어졌다.
       ```

  - 프로퍼티 키는 동적으로 생성시킬수도 있다. <br>이때는 프로퍼티 키로 사용할 표현식을 객체 리터럴 외부에서 [ ] 로 묶어야 한다.

  ### 프로퍼티 값

  - JS에서 사용할수 있는 모든 값



## 메소드 

- 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작

- 프로퍼티 값으로 함수가 온것(**<u>프로퍼티의 값이 함수인 프로퍼티를 메소드라 한다.</u>**)

- <p style="color:red";>프로퍼티를 바꿀수 있는 권한이 있다.</p>

  ```
  위 예시코드를 보면 메소드는 현재 중괄호{} 안에 들어가있다.
  중괄호 밖에 있으면 남남이 되는 것이다. 
  프로그램 세상에서 남남은 바꿀수 있는 권한이 없다는 것이다. 
  --> 하여, 프로퍼티를 바꿀수 있는 권한을 메소드에게만 준것이다. 
  ```

- 메소드의 프로퍼티 키는 동사 혹은 동사+목적어로 짓자.

  ![캡쳐87](https://user-images.githubusercontent.com/62126380/80908350-2c6aef00-8d5a-11ea-915c-72bebbabbb67.PNG) 

  ![캡쳐88](https://user-images.githubusercontent.com/62126380/80908363-3e4c9200-8d5a-11ea-99ec-8bc9c081f6e9.PNG) 

### 프로퍼티 접근

- 프로퍼티 값에 접근하려면 마침표 연산자(.) 를 사용하는 **<u>마침표 표기법</u>** 또는 **<u>대괄호 연산자</u>**를 사용하는 대괄호 표기법을 사용해야 한다.

  ```javascript
  console.log(circle.radius); 
  console.log(circle['radius']);
  ---------------------------------
  ① console.log(circle[1]);
    console.log(circle['1']);
  ----------------------------------
  ② console.log(circle[radius]);	// Reference Error
  ③ console.log(circle.width);		// undefined
  ```

  > ① 프로퍼티 키에 숫자가 올수도 있다. 이때의 프로퍼티는 암묵적 타입변환으로 인해 문자열로 변환이 된다. 이렇게 타입변환이 되어 문자열로 변환된 프로퍼티에 접근할 경우에는  따옴표가 생략이 가능하다. 
  >
  > ② 대괄호 연산자 내부에 지정하는 프로퍼티 키는 반드시 작은 따옴표로 감싼 문자열이 와야 한다.<br>작은 따옴표로 감싸지 않으면 프로퍼티 키가 아니라 식별자로 해석하여 레퍼런스 에러가 난다. 
  >
  > ② 객체에 존재하지 않는 프로퍼티에 접근하면 undefined 를 반환한다. 

- 객체 안에 프로퍼티가 여러개 올수도 있다. 

  ```javascript
  ex)
  
  var person = {
  	name: 'Lee',
      address: {
  		city: 'seoul'
  		}
  }
  console.log(person.address);
  console.log(person.address.city);
  -----------------------------------
  프로퍼티에 깊게 접근할수록 마침표 연산자를 늘려가며 접근해야 한다.
  // {city: 'seoul'}
  //  seoul
  ```

### 프로퍼티 값 갱신

- 프로퍼티 값의 갱신: 프로퍼티 값을 바꾸는 방법을 의미한다. 

- 값이 바뀌지 않는것이 프로그램에게 안정적이니, 웬만하면 바꾸지 말자. 

- 객체는 재할당 없이도 프로퍼티의 값을 바꿀수 있다. 
- <p style="color:red";>이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신이 된다.</p>

  ```javascript
    var person = {
      name: 'Lee'
    };
    person.name = 'Kim';
    console.log(person);  
    ------------------------
    프로퍼티 값을 'Lee' 에서 'Kim'으로 바꾸고 싶어서 사용한 코드다.
    ==> 결과값 {name: "Kim"}이란 값을 도출
    <- 재할당은 person ={ } 을 다시하는 것임을 주의하자. 
  ```

### 프로퍼티 동적 생성

- <p style="color:red";>존재하지 않는 프로퍼티를 중괄호 외부에 객체를 참조하며 생성하면 새로운 프로퍼티가 추가되고 프로퍼티 값이 할당된다.</p>

- 존재하지 않는 프로퍼티에 접근을 하면 undefined 로 평가되지만, 존재하지 않는 프로퍼티 생성후 값까지 할당을 하면 새로운 프로퍼티가 생성된다.

```javascript
var person = {
  name: 'Lee'
};
person.age = 20;
console.log(person); // {name: "Lee", age: 20}
--------------------------------------------------
- person 객체에는 age라는 새로운 프로퍼티가 존재하지 않는다.
따라서 person 객체에 age라는 새로운 프로퍼티가 동적으로 생성되고 값이 할당된다.
```

### 프로퍼티 삭제

프로퍼티를 삭제할수도 있을까? 삭제할수는 있다.<br>프로퍼티를 삭제할때는 delete 연산자를 사용해야 한다. 그렇다면, 여기서 프로퍼티를 삭제하게 되는 경우는 어떤 경우일까? <- 메모리를 아끼겠다는 이유에서 프로퍼티를 삭제하는 경우가 발생할수도 있다.



**<u>프로퍼티 삭제하지 마세요.</u>**  <- 내 판단에 필요없다고 해서 지웠지만 다른 사람에게는 필요할수도 있다.

### 프로퍼티 축약 표현

- 변수의 이름 = 프로퍼티 키 = 프로퍼티 값   인 경우에는 "프로퍼티 축약 표현" 이 가능하다.

### 프로퍼티 키 동적 생성

- ??????????

### 메소드 축약 표현

- 예약어를 생략 할수 있다.

  ```javascript
  var obj = {
    name: 'Lee',
    sayHi: function() {
      console.log('Hi! ' + this.name);
    }
  };
  
  obj.sayHi(); // Hi! Lee
  -------------------------------------------
  const obj = {
    name: 'Lee',
    sayHi() { 		// 메소드 축약 표현(function 생략 되었다.)
      console.log('Hi! ' + this.name);
    }
  };
  
  obj.sayHi(); // Hi! Lee
  ```

  

# 원시값과 객체의 비교

<p style="color:red";> 들어가기에 앞서...</p>

1. 원시값을 가지고 있는 변수를 다른 변수에 할당 (값에 의한 전달: pass by value)

   ```javascript
   var score = 80;
   var copy = score;
   console.log(score, copy);
   ```

   ==>  메모리 공간에 원본의 실제 값이 복사되어서 전달되어 저장된다.

2. 객체를 할당한 변수를 다른 변수에 할당 (참조에 의한 전달: pass by reference)

   ```javascript
   vaar person = {
   	name: "Lee"
   };
   var copy = person;
   console.log(copy === person);
   ```

   ===>  메모리공간에 참조값이 복사되어서 전달되어진다. 

---

## 원시값

원시값은 변경이 불가능한 값이라고 누차 얘기해오고 있다.<br>즉, 이미 생성된 원시값은 read only('읽기전용')한 값으로, 변경이 불가능하는 의미다. <br>여기서 말하는 변경이 불가능한 "값"이란 것은 변수가 아니라 "값"에 대한 얘기이다.

즉, 원시 값 자체를 변경 할수 없다는 것이지, 변수 값을 변경할수 없다는 것이 아니다. (변경이 가능하다는 얘기이다.(변수는 값이 아니다) *<- 뭘 이렇게 꽈서 설명해놓은거지...*)  

> **상수**
>
> 변수의 상대 개념이다. 
>
> 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할수 있지만, 할당이 단 한번만 허용되므로 변수와는 조금 다른 개념이다. 
>
> 따라서 상수와 변경 불가능한 값을 동일시 하는 것은 곤란하다.
>
> 상수는 재할당이 금지된 변수일뿐인다. 

- 원시값은 주소가 바뀌지 않는 상황하에서는 값을 못 바꾼다. 반드시 재할당을 해야 바꿀수 있다.

```javascript
ex 1) 

var o ={};
o.a =1; 
----------------------------------
프로퍼티 동적 생성한 상황이다. 
중괄호 외부에서 새로운 프로퍼티 a 라는 프로퍼티 키를 생성한 상태이며, 
새로운 프로퍼티 키 a 에 1 이란 프로퍼티 값을 할당한 상태이다. 
즉, 객체 안에 a 라는 프로퍼티 키와 1 이라는 프로퍼티 값을 생성한 상태이다.
==> o 라는 변수의 값을 변경한것이다.
-----------------------------------
o ={ } ==> 이건 재할당이다. 재할당을 하면 여기다 또 객체 만들고, 주소값이 바뀐다. 

ex 2)
var str = 'string';
str[0] = 'e';
console.log(str);
--------------------
==> 값이 도출되지 않는다. 왜냐? 문자열은 변경 불가능한 원시값이기 때문이다.
```

### 값에 의한 전달

![캡쳐89](https://user-images.githubusercontent.com/62126380/80914647-d1e88780-8d87-11ea-9a5d-7bb067b867b3.PNG) ![캡쳐90](https://user-images.githubusercontent.com/62126380/80914698-43283a80-8d88-11ea-9114-450a0937ab31.PNG)   

① undefined 가 들어갈 만큼 메모리 확보 후 그 메모리 공간을 score가 가리킨다. <br>// score 가 메모리공간의 주소를 알고 있어야 한다.<br><u>식별자로 알수 있는 것은 (결국은 값을 알수 있는것이지만) 식별자가 진짜로 갖고 있는 것은 메모리 주소라는 것을 알수 있다.</u>

②undefined 가 들어갈 만큼 메모리를 확보 후 그 메모리 공간은 copy 가 가리킨다.<br>// copy 가 메모리공간의 주소를 알고 있어야 한다.<br><u>식별자로 알수 있는 것은 (결국은 값을 알수 있는것이지만) 식별자가 진짜로 갖고 있는 것은 메모리 주소라는 것을 알수 있다.</u>

③ 할당이 이루어져서(사실을 재할당이라고 해야 한다), 새로운 메모리 공간을 만들어서 해당 공간에 80이란 값을 저장하고 score는 80이란 값을 가리키게 했다.<br>할당 연산자에 의해서 기존에 score가 기억하고 있는 메모리 주소가 바뀌었다.<br>undefined로 채웠던 메모리 공간을 바꾼게 아닌 이유는, undefined 값은 변경 불가능한 값이기때문이다.

 ④ (분홍색) copy에 score을 재할당했다.<br>copy에 원시값을 갖는 변수 score을 할당함으로 copy에는 **<u>score의 값이 복사되어 전달되어 저장</u>**되어진다. 

==> <u>copy의 주소값을 쫓아가면 score의 값 자체가 나온다.</u>



## 객체

**<u>객체는 변경 가능한 값</u>**이라고 누차 얘기해오고 있다.<br>그래서 객체는 재할당 없이도 값 자체를 바꿀수 있다.

결론적으로, 객체는 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조값에 접근할수 있다. <br>참조값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체이다.

- 객체를 여러 프로퍼티가 공유해서 쓰기 위해 객체의 자료구조를 이렇게 설계한것이다. 
- 요즘 트렌드는 객체도 원시값처럼 쓰려는 경향이 있다. <br>기존 객체를 카피해서 새롭게 만드는 것이다. <br>- 카피하는 방법 
  - 딥카피 : 객체가 여러개 있을 경우, 중첩된 객체들까지 싹 다 카피하는 하는 것이다.<br> 이걸 하려면 굉장히 퍼포먼스가 필요한 행위다.
  - 쉘로우 카피: 딥카피의 반대말이다.(얕은 복사: 1단계만 만든다)<br>                      객체를 하나만 만들고 중첩된거는 그냥  참조값에 넣는다. 

### 참조에 의한 전달

![캡쳐91](https://user-images.githubusercontent.com/62126380/80915227-f21a4580-8d8b-11ea-9ad6-93c617ba5944.PNG)  ![캡쳐92](https://user-images.githubusercontent.com/62126380/80915342-b92ea080-8d8c-11ea-8bc7-5d747c33de02.PNG)      

① 빈 객체가 먼저 생성된다.

② 객체가 생성된다.

③ person 이란 변수가 가리키는 메모리 공간에, 이미 생성된 객체가 저장된 메모리 공간의 주소가 저장된다.

④ 할당 연산자(=)에 의해서 copy가 가리키는 메모리 공간에 person이 가리키는 메모리 공간에 저장된 **<u>객체의 메모리 주소가 전달되어 복사되어 저장된다.</u>**

 ==> 결국 주소값이 전달된다. 그래서 주소값을 쫒아가면 참조값이 나온다.

-------

## 퀴즈퀴즈

```javascript
var person1 = {
  name: 'Lee'
};

var person2 = {
  name: 'Lee'
};

console.log(person1 === person2); // ① false
console.log(person1.name === person2.name); // ② true
```

==> ① false : 컴퓨터는 객체와 객체를 비교할때는 메모리 주소를 비교한다. 

​						-> person1 과 person2 의 메모리주소는 다르기 때문에 false

​		② true : 객체의 값을 물어본거기때문에 함수의 결과값이 'Lee' 가 같기 때문에 ture





# 함수

만드는 방법이 4개가 있다. 

매개변수에 객체를 전달했을때 함수 내부에서 외부에 잇는 객체를 변경 가능하다.

이렇게 하면 어떤문제가 생기냐면, 어떤 함수를 통과시켰을때 외부에 잇는 객체가 마구 바뀜.

그러면 바뀐 코드들이 그 객체를 바라봤을때 코드상에서는 x = 1 인데 함수가 통과된 다음에는 x가 100이 될수도 잇다 <- 이게 변경 추적이 어렵다고 하는것이다.

function add (매개변수) { }

매개: 이어준다. 뭐와 뭐를? 함수 바깥에 있는 값과 함수 안에 있는 변수와 연결해주는 것이다. 

함수 바깥에 있는거를 안에 있는 함수로 붓는거다. 

어떤 기계가 있는데 두개의 재료를 더하는 것만 전문적으로 하는 기계가 있는데, 외부에 있는 재료를 

안에 있는 재료를 넣어야 하는데 투입구가 있을거잖아, 그 투입구에다가 재료를 넣어주는거다,'

넣어주면 그 재료를 받아서 정해진 자기 일을 하는거다. 

function add (x, y) { 

return x + y;

} // 함수정의

add (1, 2) //함수호출. 1, 2 는 인수. 

console.log(x);

함수호출을 하면 1, 2 값 2개를 위의 괄호 안의 엑스와 와이(매개변수)에게 전달된다(할당된다). 

리턴이란 것은 뒤에 있는 표현식을 평가해서 함수 바깥으로 튕겨내야 한다.

섞은 재료를 만들엇으면 함수 바깥으로 튕겨내는것. 

원래는 (var x , var y  ) 라고 쓰고 싶었던것이다. 

기계는 호출문이 실행되야 1번 동작한다. 

함수호출문은 표현식이다. 무슨 값으로 평가된다? 반환문으로 평가된다.

function add (x, y) { 

return x + y;

} 

var result = add (1, 2)  

console.log(result); // 3

add : 함수이름

함수 이름은 함수몸체(코드블럭)안에서만 유효하다. 라는 문법이 있다. 

함수 이름으로 함수를 호출할수 없다. 그럼 뒤의 add 는 암묵적으로 함수 이름을 가지고 식별자를 만든것이다. 언제 만들었을까? (펑션~{} //함수 선언문) 이라고 하는데, .... 위치를 가리킨다.   

선언문은 런타임 이전에 실행된다. 함수 선언문도 런타임 이전에 실행된다.

var result = add (1, 2)  

console.log(result); 

function add (x, y) { 

return x + y;

} 

----> 이것도 잘 작동한다. 변수는 호이스팅한다고 했지. 함수 호이스팅이랑 다르다. 함수 호이스팅은..

호출까지 가능해. 정의 전에 호출할수 있다는 얘기네? 이건 부작용이야. 안좋은거야. 호이스팅을 이용하면 안되고 정의하고 호출하는 순서를 지키도록 하자. 



화살표 함수는 일반적으로....

화살표 함수는 굉장히 중요하다. 콜백 함수로 쓰인다. 

[ 1,2,3,4,5].filter (인수에 함수를 준다.)





 



