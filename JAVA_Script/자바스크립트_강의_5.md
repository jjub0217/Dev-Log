# 객체란

JS는 대부분 **<u>객체</u>** 기반의 프로그래밍 언어이며, 프로토타입의 언어이다.<br> `객체타입` 언어라고도 할수 있다.

```javascript
객체 타입 언어
: 다양한 타입의 값들을 하나의 단위로 구성된 복합적인 자료구조를 의미한다.
```

우리가 하고자 하는 프로그래밍 세상에서 <u>**객체**</u>는 내가 관심이 있는 대상에 대한 특징만<br>나열하면 된다. (내가 인지할수 있는 대상에 대한 특징)

- 객체 

  - 0 개 이상의 프로퍼티의 집합이며, 프로퍼티 키와 프로퍼티 값으로 구성된다.
  
  - 일반 함수와 구분하기 위해 **<u>프로퍼티 값이 함수일 경우에는 메소드</u>**라고 한다. 
  
- 부모관계를 맺는다. 즉, 상속되는 경우가 있다. 
  
- 함수로 객체를 생성하기도 하며 함수 자체가 객체이다. 
  
- 다양한 객체 생성 방식
  
    - `객체 리터럴` 사용
    
    >- 객체를 생성하기 위한 표기법
      >
      >- JS의 유연함과 강력함을 대표하는 객체 생성방식
    >
      >- 중괄호 내에 0개 이상의 프로퍼티를 정의(중괄호 내부의 내용들은 서로 관련이 있는 내용들로 뭉쳐있다.)
      >
      >  ```javascript
      >  중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성된다.
      >  ex)
      >  var empty = {} // 빈객체 생성
      >  console.log(typeof empty); 
      >  ----------------------------
      >  ==> 결과값으로 "Object" 란 값 도출
      >  ----------------------------
      >  ->바로 위코드가 빈 객체를 생성한 코드이다.
      >  ```
      >
      >- 숫자 리터럴로 숫자값을 만들어내고, 문자 리터럴로 문자값을 만들어내듯이, 객체 리터럴로 객체를 생성한다.
      >- <p style="color:red";>변수에 할당이 이루어지는 시점에 JS엔진은 객체 리터럴을 해석하여 객체를 생성한다.</p>
      >
      >- 객체 리터럴의 닫는 중괄호 뒤에는 세미콜론을 붙인다.
    
    - Object 생성자 함수
    - 생성자 함수
    - Object reate 메소드
    - 클래스

---

![캡쳐86](https://user-images.githubusercontent.com/62126380/80863568-57046b80-8cb8-11ea-8ced-47a5c0f00907.PNG) 

![캡쳐85](https://user-images.githubusercontent.com/62126380/80863452-6931da00-8cb7-11ea-9f8d-9fbfd2208407.PNG) 

 ## 프로퍼티 

- 객체의 상태를 나타내는 값(값이 변한다는 의미의 '상태')

- 프로퍼티를 나열할 때는 쉼표로 구분한다.<br>일반적으로 마지막 프로퍼티 뒤에는 쉼표를 사용하지 않으나, 사용해도 무방하다.

  ### 프로퍼티 키

  - 빈 문자열을 포함하는 모든 문자열 또는 symbol 값

  - 프로퍼티 키는 명사로 짓자.

  - 프로퍼티 키에 관련하여 주의할 점

    1. 프로퍼티 값에 접근할 수 있는 식별자 역할을 하며 문자열로 만들어진다.<br>프로퍼티 키를 만들때 <u>식별자 네이밍 규칙</u>을 지키면서 만들지 않아도 되지만 웬만해선 지켜서 만들자

       ```javascript
       ex)
       
       var person = {
         firstName: 'Se-jin'   // 식별자 네이밍 규칙 지킴 
           					// 내부적으로 따옴표가 생략이 되어있는 상태.
         'last-name': 'Oh'     // 식별자 네이밍 규칙 지킴
         gender-type : 'man'   // 식별자 네이밍 규칙 X // SyntaxError
       };
       ----------------------------------
       
       식별자 네이밍 규칙을 지킨 상태라면 ' '을 생략해도 되지만, 규칙을 지키지 않은 채로 식별자를 생성하려면 ' ' 을 꼭 써야 한다. <- 귀찮으니까 규칙 지켜서 쓰자
       ```

    2. 프로퍼티 키에 문자열이나, symbol 값 외의 타입으로 사용해도 되지만 암묵적 타입변환으로 인해 문자열로 바뀐다.

       ```javascript
       var foo = {
       0: 1, 
       1: 2,
       2: 3
       };
       console.log(foo); // {0:1, 1:2, 2:3}
       ------------------
       0,1,2 가 암묵적 타입변환으로 인해 문자열로 변환되었다.
       ```

    3. 이미 선언한 프로퍼티 키를 또 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다. 

       ```javascript
       var foo = {
       name: 'Lee',
       name: 'Kim'
       };
       console.log(foo);   // {name: "Kim"}
       -------------------------------------
       나중에 선언한 프로퍼티 값이 먼저 선언한 프로퍼티 값 위에 덮어씌어졌다.
       ```

  - 프로퍼티 키는 동적으로 생성시킬수도 있다. <br>이때는 프로퍼티 키로 사용할 표현식을 객체 리터럴 외부에서 [ ] 로 묶어야 한다.

  ### 프로퍼티 값

  - JS에서 사용할수 있는 모든 값



## 메소드 

- 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작

- 프로퍼티 값으로 함수가 온것(**<u>프로퍼티의 값이 함수인 프로퍼티를 메소드라 한다.</u>**)

- <p style="color:red";>프로퍼티를 바꿀수 있는 권한이 있다.</p>

  ```
  위 예시코드를 보면 메소드는 현재 중괄호{} 안에 들어가있다.
  중괄호 밖에 있으면 남남이 되는 것이다. 
  프로그램 세상에서 남남은 바꿀수 있는 권한이 없다는 것이다. 
  --> 하여, 프로퍼티를 바꿀수 있는 권한을 메소드에게만 준것이다. 
  ```

- 메소드의 프로퍼티 키는 동사 혹은 동사+목적어로 짓자.

  ![캡쳐87](https://user-images.githubusercontent.com/62126380/80908350-2c6aef00-8d5a-11ea-915c-72bebbabbb67.PNG) 

  ![캡쳐88](https://user-images.githubusercontent.com/62126380/80908363-3e4c9200-8d5a-11ea-99ec-8bc9c081f6e9.PNG) 

### 프로퍼티 접근

- 프로퍼티 값에 접근하려면 마침표 연산자(.) 를 사용하는 **<u>마침표 표기법</u>** 또는 **<u>대괄호 연산자</u>**를 사용하는 대괄호 표기법을 사용해야 한다.

  ```javascript
  console.log(circle.radius); 
  console.log(circle['radius']);
  ---------------------------------
  ① console.log(circle[1]);
    console.log(circle['1']);
  ----------------------------------
  ② console.log(circle[radius]);	// Reference Error
  ③ console.log(circle.width);		// undefined
  ```

  > ① 프로퍼티 키에 숫자가 올수도 있다. 이때의 프로퍼티는 암묵적 타입변환으로 인해 문자열로 변환이 된다. 이렇게 타입변환이 되어 문자열로 변환된 프로퍼티에 접근할 경우에는  따옴표가 생략이 가능하다. 
  >
  > ② 대괄호 연산자 내부에 지정하는 프로퍼티 키는 반드시 작은 따옴표로 감싼 문자열이 와야 한다.<br>작은 따옴표로 감싸지 않으면 프로퍼티 키가 아니라 식별자로 해석하여 레퍼런스 에러가 난다. 
  >
  > ② 객체에 존재하지 않는 프로퍼티에 접근하면 undefined 를 반환한다. 

- 객체 안에 프로퍼티가 여러개 올수도 있다. 

  ```javascript
  ex)
  
  var person = {
  	name: 'Lee',
      address: {
  		city: 'seoul'
  		}
  }
  console.log(person.address);
  console.log(person.address.city);
  -----------------------------------
  프로퍼티에 깊게 접근할수록 마침표 연산자를 늘려가며 접근해야 한다.
  // {city: 'seoul'}
  //  seoul
  ```

### 프로퍼티 값 갱신

- 프로퍼티 값의 갱신: 프로퍼티 값을 바꾸는 방법을 의미한다. 

- 값이 바뀌지 않는것이 프로그램에게 안정적이니, 웬만하면 바꾸지 말자. 

- 객체는 재할당 없이도 프로퍼티의 값을 바꿀수 있다. 
- <p style="color:red";>이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신이 된다.</p>

  ```javascript
    var person = {
      name: 'Lee'
    };
    person.name = 'Kim';
    console.log(person);  
    ------------------------
    프로퍼티 값을 'Lee' 에서 'Kim'으로 바꾸고 싶어서 사용한 코드다.
    ==> 결과값 {name: "Kim"}이란 값을 도출
    <- 재할당은 person ={ } 을 다시하는 것임을 주의하자. 
  ```

### 프로퍼티 동적 생성

- <p style="color:red";>존재하지 않는 프로퍼티를 중괄호 외부에 객체를 참조하며 생성하면 새로운 프로퍼티가 추가되고 프로퍼티 값이 할당된다.</p>

- 존재하지 않는 프로퍼티에 접근을 하면 undefined 로 평가되지만, 존재하지 않는 프로퍼티 생성후 값까지 할당을 하면 새로운 프로퍼티가 생성된다.

```javascript
var person = {
  name: 'Lee'
};
person.age = 20;
console.log(person); // {name: "Lee", age: 20}
--------------------------------------------------
- person 객체에는 age라는 새로운 프로퍼티가 존재하지 않는다.
따라서 person 객체에 age라는 새로운 프로퍼티가 동적으로 생성되고 값이 할당된다.
```

### 프로퍼티 삭제

프로퍼티를 삭제할수도 있을까? 삭제할수는 있다.<br>프로퍼티를 삭제할때는 delete 연산자를 사용해야 한다. 그렇다면, 여기서 프로퍼티를 삭제하게 되는 경우는 어떤 경우일까? <- 메모리를 아끼겠다는 이유에서 프로퍼티를 삭제하는 경우가 발생할수도 있다.



**<u>프로퍼티 삭제하지 마세요.</u>**  <- 내 판단에 필요없다고 해서 지웠지만 다른 사람에게는 필요할수도 있다.

### 프로퍼티 축약 표현

- 변수의 이름 = 프로퍼티 키 = 프로퍼티 값   인 경우에는 "프로퍼티 축약 표현" 이 가능하다.

### 프로퍼티 키 동적 생성

- ??????????

### 메소드 축약 표현

- 예약어를 생략 할수 있다.

  ```javascript
  var obj = {
    name: 'Lee',
    sayHi: function() {
      console.log('Hi! ' + this.name);
    }
  };
  
  obj.sayHi(); // Hi! Lee
  -------------------------------------------
  const obj = {
    name: 'Lee',
    sayHi() { 		// 메소드 축약 표현(function 생략 되었다.)
      console.log('Hi! ' + this.name);
    }
  };
  
  obj.sayHi(); // Hi! Lee
  ```

  

# 원시값과 객체의 비교

데이터타입에 살펴봤듯이 데이터 타입은 총 2가지다. 원시타입과 객체타입(참조타입).

다른 언어는 어떨까? 다른 언어도 두개로 나눌까? 대부분의 언어가 객체타입이 있고 원시타입이 있다. 

자스가 발명해낸게 아니라는 거다. 

원시값을 변수에 할당하면 실제 값이 저장되고, 객체를 변수에 할당하면 참조값이라는게 저장된다. 

원시값을 가지고 잇는 값을 변수에 할당하면 원본에 값 자체가 .... 복사되어지고 ... 할당하면 참조값이 정장되어서 전달되어진다. 



## 원시값

다른언어들도 크게 두개로 나눌까?

대부분의 언어가 객체타입이 있고 원시타입이 있다.



원시타입의 값은 변경이 불가능하다. 여기서 변경이란 말이 굉장히 애매모호하다.

객테타입의 값은 변경이 가능하다. 

원시값을 변수에 할당하면 실제 값이 메모리 공간에 저장되고, 객체를 변수에 할당하면 참조값이라는게 저장이 된다. 그리고 원시값을 가지고 있는 변수를 다른 변수에 할당하면 원본에 값 자체가 복사되어 전달되고 객체를 할당한 변수를 다른 변수에 할당하면 참조값이 복사되어 전달된다. 

이것을 패스바이 벨류 패스바이 레퍼런스라는 용어로 부르기도 하지만 자스와는 약간 안맞는다.



원시값은 변경이 불가능한 값이다. 이 말이 무슨 말이냐. 원시타입의 값은 변경이 불가능하다. 이말은  리드 온니하다는 말과 똑같은 말이다. 리드 온니하다고 얘기하면 읽기전용이라는 뜻이다. 쓰기는 안된다. 쓰기가 변경이라는 말이다.  참조할때는 문제가 없지만 바꾸지는 못한다 는 말이다. 

근데 우리가 헷갈리는건 변경 불가능하다는 값을 값과 변수를  분리해서 생각하지 않으면 헷갈린다.

값과 변수는 좀 분리해서 생각해야 한다. 

값이 뭐엿죠? 표현식이 평가되어져서 생성되거나 참조되어지는거. 메모리 안에 저장되어져있는 것이다. 

메모리에 저장되어지지 않는것은 값이 아닌가?

우리가 1 이라고 브이에스코드에 쓰고 실행을 안시켰어. 값이냐?  값 아니다. 엄밀히 따지면 리터럴이다. 이 리터럴이 자스엔진이 이걸  읽어들이려면(메모리로 불러들이려면) 값을 만들어야 하는데 어떤값을 만들어야 하는데, 어떤 값을 만들것인지 근거를  줘야할거 아니야. 그 근거를 준게 이거다. 십진수를 1로 주면서 너 이걸로 숫자를 만들어 라고 하면 이에 대응하는 2진수로 만들어서 메모리 안에 심어놓을 거다. 이게 값이다. 

그럼 변수는 뭘까? 값은 변수이냐? 아니다. 변수는 하나의 값을 저장하기 위해서 확보한 메모리 공간 그 자체다. 

변경이 불가능하다는 것은 값에 대한 얘기다. 값이 변경되지 않는다고 얘기했지, 변수의 값이 변경된다고 한적 없다. 변수의 값이 변경이 안되나요? 

재할당을 하면 변수는 값을 바꿀수 있습니다. 만약에 못바꾸면 변수라고 안하고 상수라고 한다. 

이때 값이 바뀌었냐, 하면 바뀐게 아니다. 변경 가능하다고 하면 따라가면 변수 값이 아니라 메모리주소가 나온다. 객체는 변경 가능한 값이잖아. 변경을 어케 할건데? 

```javascript
ex) 변경 어케 할건데?
var o ={};
o,x =1;
delete o,x
o ={ } ==> 이건 재할당이다. 재할당을 하면 주소값이 바뀐다. 
```

변경 가능하다는 것은 메모리 주소 변경 없이 값을 바꾸는 것이다. 원시값은 ... 반드시 재할당을 해야 한다. 객체는 재할당 없이도 값 자체를 바꿀수 있다. 라는 차이가 있다. 

변수에 할당한 값을 재할당을 안한다고 하면 한번 할당한 값은 결코 바뀔일이 없다. 하지만 객체의 경우는 재할당을 안하겠다고 약속을 하자. 그래도 바뀔 가능성이 있다. 그래서 원시값은 재할당을 안한다고 신뢰성이 굉장히 높은거다. 근데 객체는 굉장히 잘 바뀔 확률이 높다. 그래서 값을 추적하는것이 어렵다. 



그러면 왜 그런식으로 설계했을까?

객체는 프로퍼티가 여러개있을수도 있잖아. 100개일수도 있고 1000개 일수도 있다. 

그러면 확률적으로 따졌을때 객체가 원시보다 훨씬 크다. 숫자 하나가 클까 함수가 클까, 함수가 훨씬 크다. 

만약에 객체가 원시값처럼 동작해야 한다면, 값을 바꾸었을때 변경 불가능하다고 하면 새로운 메모리 공간을 만들어야 한다.  바뀔때마다 만들어야 한다. -> 이렇게 안하는 이유는 메모리에 대한 부담이 있다. 

불변객체를 만든다. (원시값처럼 불변값을 만든다.)-> 이러면 객체가 바꼈는지 안바꼈는지 알아차리기가 쉽다. 어케? 주소가 바뀌면 무조건 바뀐것이다. 

재귀. 이걸 무한반복해야 한다. 퍼포먼스가 굉장히 비효율적이다. 

- 딥카피 : 이걸 하려면 굉장히 퍼포먼스가 필요한 행위다.

- 쉘로우 카피: 딥카피의 반대말

원시값은 변경할수 없다(리드 온니하다)

그래서 원시값은 불변성을 갖는다. 문자열은 굉장히 재밌는거다. 문자열이라는건 자스에서는 원시값이다. 다른 언어에서는 원시값일 수가 없다. 원시값은 메모리를 생성할때 바이트 수가 정해져잇다. 

문자 타입이 잇다.  ['a,'b','c'] 자스에서 문자열이 원시값이라는건 굉장히 독특한것이다. 



 ### 값에 의한 전달

![image-20200428163302664](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200428163302664.png) 

저 두개의 80은 다른 값이다. 

원시값은 이런식으로 원시값을 할당한 변수를 어떠한 값에 준다해도 다른쪽에 영향을 주지 않는다. 

신뢰성이 보장된다는 것이다. 

객체를 만드는것은 원시값을 만드는것보다 훨씬 어렵다. 

**... 두번 찾아가는 거다** -> 이거 다시 자세히 듣기. 주소로 가서 찾아갔더니 주소값이 나오느냐, 값이 나오느냐. 객체를 여러명이 공유해서 쓰려고 한다. 두개의 식별자가 하나의 값을 가리키는 것이다. -> 이건 부작용이다. 메모리 공간은 객체가 많이 차지하지만 부작용이 있지만 이렇게 쓰는 것이다. 

그러면 프로그래머들에게 이런 상황이 발생한다는것을 잘 알고 있어야 한다. 이런 상황이 싫으니까 원시값처럼 쓰려고 하는거다. 

```javascript
var person1 = {
name: 'Lee'
};

var person2 ={
name: 'Lee'
};

console.log(person1 === person2); //
console.log(person1.name === person2.name); //

```





# 함수

만드는 방법이 4개가 있다. 

function add (매개변수) { }

매개: 이어준다. 뭐와 뭐를? 함수 바깥에 있는 값과 함수 안에 있는 변수와 연결해주는 것이다. 

함수 바깥에 있는거를 안에 있는 함수로 붓는거다. 

어떤 기계가 있는데 두개의 재료를 더하는 것만 전문적으로 하는 기계가 있는데, 외부에 있는 재료를 

안에 있는 재료를 넣어야 하는데 투입구가 있을거잖아, 그 투입구에다가 재료를 넣어주는거다,'

넣어주면 그 재료를 받아서 정해진 자기 일을 하는거다. 

function add (x, y) { 

return x + y;

} // 함수정의

add (1, 2) //함수호출. 1, 2 는 인수. 

console.log(x);

함수호출을 하면 1, 2 값 2개를 위의 괄호 안의 엑스와 와이(매개변수)에게 전달된다(할당된다). 

리턴이란 것은 뒤에 있는 표현식을 평가해서 함수 바깥으로 튕겨내야 한다.

섞은 재료를 만들엇으면 함수 바깥으로 튕겨내는것. 

원래는 (var x , var y  ) 라고 쓰고 싶었던것이다. 

기계는 호출문이 실행되야 1번 동작한다. 

함수호출문은 표현식이다. 무슨 값으로 평가된다? 반환문으로 평가된다.

function add (x, y) { 

return x + y;

} 

var result = add (1, 2)  

console.log(result); // 3

add : 함수이름

함수 이름은 함수몸체(코드블럭)안에서만 유효하다. 라는 문법이 있다. 

함수 이름으로 함수를 호출할수 없다. 그럼 뒤의 add 는 암묵적으로 함수 이름을 가지고 식별자를 만든것이다. 언제 만들었을까? (펑션~{} //함수 선언문) 이라고 하는데, .... 위치를 가리킨다.   

선언문은 런타임 이전에 실행된다. 함수 선언문도 런타임 이전에 실행된다.

var result = add (1, 2)  

console.log(result); 

function add (x, y) { 

return x + y;

} 

----> 이것도 잘 작동한다. 변수는 호이스팅한다고 했지. 함수 호이스팅이랑 다르다. 함수 호이스팅은..

호출까지 가능해. 정의 전에 호출할수 있다는 얘기네? 이건 부작용이야. 안좋은거야. 호이스팅을 이용하면 안되고 정의하고 호출하는 순서를 지키도록 하자. 



화살표 함수는 일반적으로....

화살표 함수는 굉장히 중요하다. 콜백 함수로 쓰인다. 

[ 1,2,3,4,5].filter (인수에 함수를 준다.)





 



