# 변수

<p style="color:red";> 들어가기에 앞서...</p>

1. <u>**bit는 지수 즉, 제곱을 뜻하며 2진수가 표현할수 있는 최소의 단위다.**</u>

``` ex
ex)
1bit : 2의 1승. 2개의 경우의 수를 나타낼수 있다 (0 또는 1)
2bit : 2의 2승. 4개의 경우의 수를 나타낼수 있다 (00, 01, 10, 11)
8bit : 2의 8승. 256개의 경우의 수를 나타낼수 있다. 
```

2. <u>**변수는 에러발생의 근본 원인이다.**</u>

   변수가 많을수록 기억해야 할 사항이 많아지는것이므로, 오류 발생 확률이 커진다. 

   ∴ 변수는 적을수록 좋다. 

---

## 변수란 무엇인가?

- <u>**하나의 값을 저장하기 위해 확보한 메모리 공간 자체**</u> <br>변수를 선언하면 메모리 공간의 영역을 확보하면 다른 애가 그 영역을 못쓴다. 

"변수는 값을 저장하기 위한 `상자`다." -> 바보같은 설명임....<br>(근데 왜= 이런식으로 설명할까? 그렇게 설명해줘야 이해하기 쉽다고 함)

```  
상자 = 메모리 (개발자들에게 메모리는 상당히 중요한 요소임)
```

##### 예시

``` 10 
<script> 
10 + 20 = 30
</script>    <- 자바스크립트 코딩하게 된다면?
```

![캡처43](https://user-images.githubusercontent.com/62126380/79992090-02116a00-84ee-11ea-9816-05e63e0692a2.PNG) 

 

- 식별자 : 하나의 값을 저장하기 위해 확보한 메모리 공간(노란색 칸) 또는 메모리 공간을 식별할수 있는 이름을 가리킨다. 

- 메모리 주소 : 0 ~ 메모리 크기만큼 정수로 표현

- 연산은 CPU가 함. 

- 값이 저장될 메모리셀의 주소는 코드가 실행이 될때, 메모리의 상황에 따라 OS가 임의로 결정한다. 

  따라서 똑같은 컴퓨터로 똑같은 코드를 실행해도, 코드가 실행될때마다 해당 메모리셀의 주소는 매번 변경이 된다.  



"30" 이란 값을 한번만 쓴다고 하면 이 과정에서 끝내도 되지만, 재사용을 하려면 해당 "30"이라고 저장한 값을 다시 읽어들여서 사용해야 한다.  

--> 이때 재 사용하기 위해 **"변수"** 라는 것을 이용한다.

``` 
변수

"30" 이란 값을 재사용하려면 "30"이란 값을 도출해낸 메모리셀의 주소를 알아야 한다.
하지만 메모리셀에 저장되었지만, 연산하여 만들어낸 값은 재사용을 할수 없기 때문에 저장을 시켜야 한다.
10 + 20 의 결과값이 있는 곳을 기억해라 고 컴퓨터에게 명령을 해야하는데 
이때 사용되는것이 "변수"다.
```



## 변수를 왜 사용해야 할까?

- **<u>변수를 사용한다는 것은 메모리를 쓴다는 것이다.</u>** 

어떠한 변수가 어떠한 메모리의 공간영역을 예약하고 확보하여 사용을 한다고 하면, 그 영역에는 다른 변수가 침범을 하지 못한다. 

그렇게 사용하지 못하는 영역이 많아질수록 렉이 걸리는 것이다. 

그래서 변수는 영역을 점유하고 있으면 안되고, 메모리의 공간영역을 확보했다면 그 영역을 빨리 사용하고 빨리 해방을 시켜야 한다. ( 변수는 생명주기가 짧아야 한다.)

- <u>**인간은 언제나 실수를 한다. 그래서 변수를 쓴다.**</u>

메모리셀에 값이 저장된 주소는 매번 바뀌기 때문에 알수가 없다. 

저장된 값을 재사용하려면 값이 저장된 주소에 직접 접근을 해서 값을 꺼내오면 될것 같은데, 인간은 언제나 실수를 하지.... *<- 엉뚱한 주소값을 가져올수 있잖아....컴터 주기지마.. 소중한 내 컴터... 내 데이터.. 내 코딩..*

JS 엔진도 우리에게 매번 바뀌는 메모리셀의 저장된 주소를 알려주지 않기 때문에  해당 주소에 접근할수 없어서 수정 및 변경을 할수가 없기 때문에 변수를 쓴다. 

- **<u>변수를 만들때에는 그 변수에 할당되어져있는 값(ex: "30")을 재사용하겠다는 의미가 있다.</u>** 

##### 예시

``` ex
var a = 10 + 20 ; => 방의 주소 위치를 기억하라고 명령한 상태(사람을 위한 표현)
----------------
JS 엔진을 위한 표현
var a ; 
a = 10 + 20 ;
```

<p style="color:red";>var <span style="color:green";>a <span style="color:black";>= <span style="color:blue";>
    10 +20 ; <span style="color:black";>

![캡처45](https://user-images.githubusercontent.com/62126380/79983970-7b578f80-84e3-11ea-9680-92429ec6a3e6.PNG) 

==> 변수선언과 변수값이 주어지면(=변수값이 할당이 되면) 값(ex:"30")이 있는 곳에는 언제든지 <br>		접속할수 있으므로 재사용이 가능하다.  

==> 위 예시로는 재사용 할수 있는 값은 오로지 "30" 뿐이다. 

​		10 과 20 에도 변수에 값을 할당해야 재사용 할수 있다. 



### 식별자

![캡처48](https://user-images.githubusercontent.com/62126380/79992279-3c7b0700-84ee-11ea-90f9-725deebe7224.PNG) ![캡쳐56](https://user-images.githubusercontent.com/62126380/80098484-eff40200-85a7-11ea-8aa2-875d61cc3e47.PNG)

- 하나의 값을 저장하기 위해 확보한 메모리 공간 (노란색 칸) 또는 메모리 공간을 식별 할 수 있는 이름

- 식별자는 고유해야 한다.(스코프 내에서 고유해야 한다.)

- 함수의 이름도 식별자이다.

- 선언하는 애들은 다 식별자구나~ 라고 생각하면 된다. 

  ``` 
  10 + 20 = 30
  ---------
  " 10 + 20 " 란 글자랑 "30" 이란 글자가 똑같지 생기지 않다. 
  하지만 식이 계산된다면 왼쪽과 오른쪽이 결국 같아진다. 
  이때 "같아진다" 라는 뜻을 "동치"라고 한다. 
  
  위 이미지로 말하자면 
  "result" 변수이름, 또는 식별자가 노란색칸을 가리키고 있다. 
  즉, "result" 라는 식별자와 노란색칸(메모리)는 동치다. 
  하여, 퉁쳐서 식별자는 고로 변수 라고 부를 수도 잇다. 
  ```

- 식별자는 어떤 값(ex:"30)이 저장되어있는 메모리 주소를 기억(저장)해야 한다.

- 식별자는 값(ex:"30")이 저장되어있는 메모리 주소와 연결관계가 있으므로, 해당 연결 정보도 저장되어야 한다.

  ===> 식별자는 메모리주소에 붙인 이름이라고 할수 있다. 

- 변수 이름, 즉 식별자는 가독성을 높여주는 효과를 준다.



## 식별자 네이밍 규칙

- 식별자의 이름을 지을때 규칙이 있다. 

  - 사용할수 있는 특수문자( 2개 ) :  "_" , "$"

  - 알파벳으로 시작하는 이름

  - 숫자로 식별자의 이름이 시작되면 안된다.

  - 식별자의 이름 중간에는 문자, 숫자, "_" , "$" 모두 사용할수 있다.  

  - SyntaxError(문법에러)를 주의하자.

  - `예약어`는 식별자로 사용할 수 없다.

    ```
    예약어: 프로그래밍 언어에서 사용되고 있는 언어
    
    await / break / case / catch / class / const / continue / debugger / default / delete / do / else / enum / export / extends / false / finally / for / function / if / implements* / import / in / Instanceof / interface* / let* / new / null / package* / private* / protected* / public* / return / super / static* / switch / this / throw / true / try / typeof / var / void / while / with / yield*
    ```

  - 쉼표로 구분해서 하나의 문에서  여러개 한번에 선언할수 있지만 비추다. 

    ```
    ex)
    var person, $elem, _name, first_name, val1;
    ```

  - 영어 외의 언어로 써도 되지만 비추다. 

    ```
    ex) 
    var 이름, なまえ;
    ```

  - 두 단어를 쓸때는 스네이크케이스, 카멜케이스, 파스칼케이스, 헝가리언케이스, 전부 소문자, 전부 대문자만  사용 

    ```
    var first_name;
    var firstName;
    var firstname;
    var FIRSTNAME;
    var FirstName;(파스칼 케이스)
    var strFirstName;(헝가리언케이스)
    var $elem = $('.myclass') (제이쿼리)
    ```

  - 가독성 좋게, 명확한 의미로, 쉽게 이해할 수 있도록 이름을 지어야 한다.

    ```
    var x = 3; ==> 명확한 의미 NG
    var d;  ==> 명확한 의미 NG
    var score = 100; ==> "100 이란 값이 점수를 뜻하는구나" OK
    var elapsedTimeIndays; ==> 경과시간,단위,날짜의 명확한의미 OK
    ```

    

## 변수 선언

<p style="color:red";> 들어가기에 앞서...</p>

1. JS 가 아닌 다른 언어들은 변수를 선언하면 반드시 초기화를 해야 한다. (이것은 약속이다.)

2. JS 는 인터프리터 언어라서 <u>**변수에 값을 할당하지 않으면**</u> 일반적으로는 오류가 발생하지만, JS를 만든 우리 브랜든 아이크씨는 친절한 분이시라 **<u>암묵적으로 오류가 나지 않게 JS를 만들어주셨다</u>** *<- 오 할렐루야*
3. 메모리셀에 한번 저장되었던 값을 초기화하지 않고 안 치운다면 값은 지워지지 않고 그대로 남는다.<br>이때 쓰였던 메모리셀은 <u>**무의미한 값(=쓰레기 값)**</u>을 가지게 되는것인데 이런 상황을 "초기화 하지 않은상황"이라고 할수있다.<br>하지만 JS는 친절한 언어이기때문에, <u>**초기화 하지 않아도 암묵적으로 초기화를 시켜준다**</u>. *<-THANKS JS*
4. **<u>변수를 사용하려면 반드시 선언이 필요하다.</u>**
5. <u>**변수를 선언할 때**</u>는 var,let,const,function, class... 같은 <u>**키워드(명령어)를 사용**</u>한다. 

---

### 변수 선언이란?

##### 예시1

JS엔진은 사람이 보기 편하게 만든 한줄 코드 " `var result` = 10 + 20 ; "을 두줄로 해석한다. 

![캡처49-1](https://user-images.githubusercontent.com/62126380/80062249-3e84aa80-856e-11ea-866d-5de314f30a74.PNG) 

- 변수를 생성하는 것

- 값을 저장하기 위한 메모리 공간을 확보하고 식별자와 확보된 메모리 공간의 주소를 연결하여 값을 저장할수 있도록 준비하는 것

- **<u>하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름</u>**

- 변수 선언단계 (변수 선언만 했을때의 상태)

  - 선언 단계 : 변수 이름(ex:"result")을 등록하여 JS엔진에 변수의 존재를 알린다

  - `초기화 단계` : 값을 저장하기 위한 메모리공간을 확보하고 변수 "result"에  암묵적으로 undefined를      할당한다.   

    - 쓰레기값이 나오는걸 방지하기 위해서 undefined 값을 할당하는 것이다.

    ===> 두 단계가 한방에 이루어진다. 

  ``` 
  초기화 단계
  
  1. 변수 선언 후 값을 할당하지 않으면 `undefined`라는 쓰레기값 만큼만 공간이 확보가 
     되어지는데 몇byte가 확보될지 모르니까 일단 무조건 암묵적으로 undefined 값이 
     들어갈만큼만 확보한 후에, undefined값이 할당되고 메모리셀이 초기화 된다.
  2. var 키워드로 변수는 선언이후 어떠한 값도 할당하지 않아도 undefined라는 값을 가진다.
  3. undefined값은 JS엔진 회사마다 byte 값이 다 다르기때문에 표준이 없으므로 
     undefined값의 크기는 모른다. 
  ```

  ##### 예시2

  ```
  var result ;
  console.log(result);
  ----------------------
  변수를 선언만 했지, 변수에 값을 할당하지 않은 상태에 변수값을 참조한 상태이다.
  -> undefined 값(쓰레기값)이 나온 상태.
  ```

  ![캡처50](https://user-images.githubusercontent.com/62126380/80004386-37718400-84fd-11ea-87f9-a4b9fe7a96ff.PNG) 



## 변수문법

- 컴퓨터는 코드를 위에서 아래로 순차적으로 실행한다.

- 명령은 value(값), operator(연산자), expresstion(표현식), comment(주석)으로 구성되며 세미콜론(;)으로 '문'을 끝마친다. 

##### 예시1

![캡쳐51](https://user-images.githubusercontent.com/62126380/80062371-8acfea80-856e-11ea-9ff9-9a1e54934f68.png) 

``` 
var result ; 

변수 선언만 하고, 값을 할당하지 않은 상태 라서 -> undefined 값이 도출
----------------------------------------------------------------
var result ;
result = 10 + 20 ;

변수 선언도 하고, 변수에 값도 할당한 상태 -> 정상 작동
```

##### 예시2

![캡쳐52](https://user-images.githubusercontent.com/62126380/80063263-80165500-8570-11ea-88b6-892dc699f08a.png) 

```
result = 10 + 20 ;

변수 선언을 안한 상태에 값을 할당했는데 왜 에러가 안나오죠?  
-> 친절한 JS씨라서 "너 선언하는거 까먹었지...? 어휴.. 내가 알아서 출력해줄게" 하고 자동으로 결과값을 도출해줌.  -> 정상 작동
------------------------------------------------------------------------------
①result = 10 + 20 ;
 var ②result ;

①result 랑 ②result 은 다른 result 다. 
왜냐? 친절한 JS씨가 "너 선언하는거 까먹었지...? 어휴.. 내가 알아서 출력해줄게" 하고 자동으로 ①result 값을 벌써 출력을 이미 다 해줬는데 또 ②result 를 선언한다. 이건 중복이다. 그래서 ①result 값을 지워버리고 다른 ②result 값이 새로 생겨버린 상태라서
-> undefined 값이 도출 
```



## 레퍼런스 에러(참조 에러)

<p style="color:red";> 들어가기에 앞서...</p>

1. 변수 참조( "cosole.log(~)" ): 변수의 값을 가지고 와서 출력해달라는 명령

   ```
   ex)
   var result ;
   console.log(result);
   ----------------------
   선언한 변수 "result" 값을 출력해줘!!!
   -> 결과 : 할당한 값이 없으므로 undefined 값 도출
   ```

---

레퍼런스 에러 : 선언된적이 없는 변수를 참조하려고 할때 발생하는 에러

##### 예시1 (레퍼런스 에러 발생)

```
var result = 10 + 20 ;
console.log(score)
------------------------
"result" 라는 변수를 선언했는데, 참조한 변수는 "score" 이란 변수라서 레퍼런스 에러 발생
```

![캡쳐53](https://user-images.githubusercontent.com/62126380/80066296-a0491280-8576-11ea-8a51-caebc85666ea.PNG) 

##### 예시2(레퍼런스 에러 X)

``` 
1. var result = 10 + 20 ;
   console.log(result) ;
-----------------------------
"result" 라는 변수를 선언 + 변수에 값을 할당 + 참조한 변수 "result"로, 선언한 변수를 참조
-> 에러 없이 값이 3으로 정상 도출

2. console.log(result) ;
   var result = 10 + 20 ;
-----------------------------
-> 결과 : undefined값 도출(레퍼런스 에러X)

위 코드는 변수 호이스팅으로 인해(호이스팅: 아래 설명 참고) 변수 선언문부터 읽히고, 
그 다음에 콘솔로그가 읽힌다.(아래처럼) 
var result ;
console.log(result);
근데 이 상태는 아직 "result"값이 할당되어있지 않은 상태라서 undefined 값이 도출된다.
그 후에 result = 10 + 20 ; 이란 "문"이 읽히는데, 이 "문"에는 어떠한 행위를 해달라는
명령어가 없기때문에 실행되는 것은 아무것도 없다. 그래서 결국 결과값으로 undefined값이 
도출되는 것이다.
제대로된 결과값을 도출하려면 아래처럼 코딩하면 된다.

console.log(result);
var result = 10 + 20 ;
console.log(result);
*"값의 재할당"과 관련있는 코드이니 아래 "값의 재할당"부분도 참고하자.
```



## 변수 호이스팅

- 런타임(run time) : 코드들이 위에서 아래로 순차적으로 읽히는 과정

- 변수 호이스팅 : 다른 언어들과 다르게, JS엔진은 런타임 이전에 <u>**변수 선언문**</u>이 다른 코드들보다 제일 먼저 평가되어 <u>**제일 먼저 실행**</u>되는 것  
- 변수 호이스팅 발생 이유 : 런타임 이전에 변수 선언을 처리, 초기화를 하기 때문이다. 

##### 예시1

![캡쳐54](https://user-images.githubusercontent.com/62126380/80074138-b14c5080-8583-11ea-9c64-82ce3b4d5b45.PNG) 

```
결과:

★ console.log(score) ;
☆ var result ;
-----------------------------
1. ☆ 코드 평가 -> 2. ★ 코드 실행 -> 레퍼런스 에러는 아니지만 undefinde값이 할당.
```

1. 코드 평가 : JS엔진은 다른언어와 다른점이 있는데, 코드를 순차적으로 읽어내려가서 실행을 하기 이전에 <br>실행을 하가 위해  코드평가가 먼저 이루어진다.
2. 코드 실행 : JS엔진은 코드 평가 과정에서 변수선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 코드에서 먼저 찾아서 변수 선언문을 제일 먼저 실행한다.

위 코드처럼 변수 참조가 먼저 되고 변수 선언이 그 다음으로 되어도 JS엔진은 실상 위 예시로는 ☆->★ 순서로     코드를 해석한다. 
위 코드의 현재 상태는 변수 선언 다음에 변수 참조가 이루어진 상태인데, 현 상태는 아직 변수값에 값이 할당되어
있지 않은 상태라서 undefined 값이 할당되어 지는 것이다. 



## 값의 할당

&#128205; &#128205; 제일 먼저 변수 호이스팅을 유의하자.

##### 예시1

![image-20200423190742998](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200423190742998.png) 

```
① console.log(score);
② var score = 80 ;
③ console.log(score);
---------------------------
-> 결과 : 80 값을 도출
```

① : 변수 score의 값을 출력해줘! -> 아직 변수 선언도 안하고, 값을 할당하지도 않았기 때문에 **undefined값 도출**

①,② : JS엔진이 ② 가 1줄로 보이지만 두줄로 해석한 후, 변수 호이스팅이 실행된다.

실상, 아래 이미지처럼 실행되어 **undefined 값 도출**

![캡쳐55](https://user-images.githubusercontent.com/62126380/80091542-35aacd80-859c-11ea-96be-e34e0017510a.PNG) 

①,②,③ : undefined 값이 도출된 상황이지만 이미 변수 선언 완료 + 값의 할당도 완료되어서 <br>				**정상적인 80이란 값이 도출**

---

##  값의 재할당

- 기존에 할당이 되어져있는 변수에 다른 값을 다시 할당하는 행위
- 가급적이면, 왠만해서는 재할당을 안하는게 좋다. 
- 재할당을 할수 없는(재할당이 금지된) 변수는 변수라고 하지 않고 상수(const)라고 한다.
  - 재할당이 금지되기때문에 처음값을 바꿀 방법은 객체타입의 경우에만 있다.

##### 예시1

![캡쳐57](https://user-images.githubusercontent.com/62126380/80106335-b1b10f80-85b4-11ea-961b-3724ed0a2991.PNG) 

![캡쳐58](https://user-images.githubusercontent.com/62126380/80107358-ef626800-85b5-11ea-8688-d809c7d08c48.PNG) 

```
① 변수 선언으로 인해 변수 "score"가 가리키고 있던 undefined 값은
② "80"이란 값을 할당함으로 인해 폐지(해방)되어 메모리가 해제 되고
③ "90"이란 값을 재할당함으로 인해 "80"이란 값이 저장되었던것도 폐지(해방)가 되어 메모리가 해제 된다.
```

==> 폐지(해방)되어 메모리가 해제가 된 값들은 가비지 컬렉터(garbage collector)가 메모리들을 훑다가<br>"어~? 이 메모리셀의 값은 더이상 필요없네?? 어떠한 변수도 이 메모리셀의 값을 가리키고 있지 않네??" <br> "그럼 이제 이 메모리(ex: undefined) 공간 써도 되~ 얘도(ex:80) 써도 되! 하지만 얘는(ex: "90") 쓰면 안되~!!"라고 재사용해도 되는 쓰레기값에 대해 판단한다.   

가비지 컬렉터가 메모리셀 공간영역의 재사용에 대해 판단을 하고, 재사용이 가능하다면 그 셀에는 다른 값들로  채워질수 있다. 

하지만 여기서 유의해야 할 점은 위의 이미지대로, 값의 할당과 값의 재할당이 이뤄지면 값으로 채워졌던<br> 메모리셀 의 값들이 지워지고 거기에 **<u>새로운 값들이 할당되는것이 아니라, 새로운 다른 메모리셀에 값이 엎어져서 채워지는 것이다.</u>** 



## 값의 교환

값을 교환(교체)하는 방법을 알아보자

예시) 변수 x 의 값과 변수 y 의 값을 바꿔라.

![캡쳐62](https://user-images.githubusercontent.com/62126380/80273633-e6d17500-870e-11ea-8f28-62db495ac371.PNG) 

해석) console.log( x, y )  -> ( 2, 1)

![캡쳐63](https://user-images.githubusercontent.com/62126380/80275359-a62c2880-871b-11ea-81b0-a50dc85a716d.PNG) 

---

# 표현식과 문

<p style="color:red";> 들어가기에 앞서...</p>

표현식이란?

1. 평가되어 값이 되어지는 것.

2. 값으로 평가될 수 있는 문.
3. 표현식이 평가되면 새로운 값을 생성하거나 기존의 값을 참조한다. 

---

## 값

- 평가 : JS엔진이 코드를 실행해서 결과물인 값을 도출하는 과정
- 표현식이 이게 뭔지 해석하는 ''코드 평가 단계'를 거쳐서 생성된 값 또는 결과물이 메모리에 저장되어지는 최소단위이다.
- 문을 보면 컴터가 해석을 할건데, 표현식이면 평가를 하는거고, 실행문이면 실행을 하는것이다. 

![캡쳐64](https://user-images.githubusercontent.com/62126380/80275782-75012780-871e-11ea-8de5-9fb7ceb68ebb.PNG) 

``` 
ex)
var x = 10 + 20 ;
x = 10 + 20 ;
------------------
10 ==> 숫자 리터럴
20 ==> 숫자 리터럴
10 + 20 ; ==> JS엔진에 의해 평가되어져서 연산자 표현식이면서 값 ( 10 + 20 ; 와 "30"은 동치)
x  ==> 식별자 표현식이면서, 결국엔 "30" 이란 값으로 평가되어져서 결과물을 생성하기때문에 값
------------------------------
```

---

### 리터럴( 기호 )

- 사람이 이해할수 있는 문자 또는 약속된 기호를 사용하여 **<u>값을 생성하는(만들어내는) 표기방법</u>**

- JS엔진에 의해서 평가되어질 코드 

- 값을 생성하기 위해 미리 약속한 표기법

- 코드에 맞는 기호를 값으로 만들어내는 것

  ![캡쳐59](https://user-images.githubusercontent.com/62126380/80170481-025f5180-8623-11ea-992d-1dfe5353a730.PNG)

  ``` ex
  개발자가 코드에 3 이라는 숫자 리터럴을 쓰면, 이건 숫자 십진수의 10 이다. 라고 JS엔진하고
  개발자가 서로 알고있는 약속을 하는것이다.
  -> JS엔진은 3 을 십진수 3으로 해석해서 메모리에는 2진수의 값으로 저장한다.
  ```

- ![캡쳐60](https://user-images.githubusercontent.com/62126380/80172179-494f4600-8627-11ea-9fd9-c5b19da03f6b.PNG) 

  ```  
  리터럴 : 값으로 평가될수 있다. 평가되면 리터럴은 결국 값이 된다.
  표현식 : 평가되어 값이 되어지는 것
  ==> 리터럴 = 표현식 (동치의 개념으로 리터럴과 표현식은 같다.)
  ```

- 리터럴의 종류(데이터 타입)

  - `원시타입 (기본형, 기본자료형)`

    ``` html
    원시타입(프리미티브 타입) :
    변경 불가능한 테이터 타입이다. (변경 불가능(immutable))
    ```

    - 숫자 리터럴 

      - JS에서는 정수, 실수 구분없이 전부 실수(부동 소숫점)로 저장된다. 
      - 계산하기 위해 쓰이는 리터럴이다. 
        - 정수 리터럴
        - 부동 소숫점 리터럴
        - 2진수 리터럴 (0b 로 시작하는 숫자)
        - 8진수 리터럴 (0o 로 시작하는 숫자)
        - 16진수 리터럴 (0x 로 시작하는 숫자)
        - NaN : 계산을 하려했는데, 계산을 못했을 때 나타나는 값

    - 문자열 리터럴 ( ' ' , " " , `` ) = string

      - ```
        개발자 : " 나 이제 문자열 타입의 값을 할당할건데.. 뭐라고 보기 쉽게 구분하지..? 
        그래!! 그럴땐 "string" 이란 식별자를 쓰자!
        ```

      - 기록과 누군가에게 읽히기 위해, 출력하기 위해 쓰이는 리터럴이다. <br> <- *함수를 통해서도 문자열을 만들수 있지만 뻘짓이야. 하지마라~*

      - 따옴표들과 백틱으로 값을 감싸지 않으면, JS엔진은 식별자와 같은것으로 해석한다.

      - JS엔진은 문자 리터럴을 만나면 문자열에 해당 하는 유니코드를 만들어내고 2진수로 저장한다. 

      - 1개만 있는건 "문자" 라고 하지만, 여러개가 있을 때는 "문자열(0개 이상의 문자들의 집합)"이라고 한다. 하지만 JS엔진은 전부 "문자열"이라고 해석한다. 

      - " ' ' " 와 ' " " ' 은 똑같이 문자열로 해석한다.

        - 템플릿 리터럴
          - 멀티라인 문자열
          - 표현식 삽입

    - 불리언 리터럴

      - JS엔진이 불리언 리터럴을 만나면, 논리적 참인지 논리적 거짓이란 불리언 값을 생성한다.
      - 조건문 같이 참과 거짓으로 구분되는 조건을 줘서 구분하고 싶을때 쓰임
      - true
      - false

    - null  리터럴 ( null ) 

      - 의도적으로 값이 없음(값의 부재)를 나타내는 값이다. 

        ``` 
        "무슨 이유에서든지 어떤 변수는 값이 없어~ 알았지~???" 
        ```

    - undefined 리터럴 ( undefined )

      ```
      우리가 undefined 값을 만들면 안되~! 만들어서도 안되. 
      이건 암묵적 초기화를 위한 값이야. JS엔진이 쓸라고 지가 만드는 값이니까
      우리가 만들면 안된다. 애초에 이거를 개발자가 쓰는 의도는.. 당췌 모르는거야.
      이걸 만드는 개발자는 이상한 개발자야. 
      ```

  - `객체 타입`

    ``` html
    객체타입(오브젝트 타입) :
    변경 가능한 테이터 타입이다. (변경 가능(mutable))
    ```

    - 객체 리터럴
      - `{ }` 를 쓴다. 
      - 객체 리터럴은 평가되어져서 객체를 만들게 된다. JS엔진은 그 객체를 기호로 만들어낸다. 
      - ex) {name: 'Lee', address: 'Seoul'}
    - 배열 리터럴
      - `[ ]` 을 쓴다. 
      - 배열 리터럴은 평가되어져서 배열을 만들게 된다. JS엔진은 그 배열을 기호로 만들어낸다.

    - 함수 리터럴
      -  function( ) { }
      -  JS엔진이 이거를 함수라는 값으로 만들어냄
    - 정규표현식 리터럴



# 표현식과 문

## 표현식

- 값으로 평가될수 있는 문
- 표현식이 평가되면 새로운 값을 생성하거나 기존의 값을 참조한다. 

- 표현식의 종류

  - 리터럴 표현식

  - 식별자 표현식

    ex) sum

    ​	  person.name

    ​	 arr[1]

    ```
    var x = 1 +2 ;
    x + 3;
    ===> 6이란 결과값 도출
    ```

    

  - 연산자 표현식

    ex) 10 + 20 

    ​	  sum = 10 

    ​	  sum !=== 10

  - 함수,메소드 호출 표현식

    ex) square( )

    ​	  person.getName( )



## 문

<p style="color:red";> 들어가기에 앞서...</p>

토큰 

- 문법적인 의미를 가지며, 문법적으로 더이상 나눌 수 없는 코드의 기본요소
- "문에 있는 하나하나의 요소"



![캡쳐65](https://user-images.githubusercontent.com/62126380/80283867-e1e3e400-8755-11ea-85e3-c405d33ded7c.PNG)



- 프로그램은 구성하는 기본 단위이자 최소 실행 단위.
- 문들은 0개 이상의 토큰들로 이루어져있다.

- 토큰들이 갖고 있는 의미들을 JS엔진이 해석한다. 
- 명령문이 실행이 되면 변수가 선언되고, 3 이란 숫자가 만들어지고, 할당이 이루어진다. 
- 문의 종류
  - 선언문 : 선언문이 실행되면 변수가 선언된다.
  - 할당문(표현식 문) : 할당문이 실행되면 변수에 값이 할당된다.
  - 함수 선언문
  - 조건문 : 조건문이 실행되면 코드블럭이 실행될지 안될지를 결정
  - 반복문 : 조건을 따라서 반복을 할건지 안할건지 결정