# 순수 함수와 비순수 함수

## 순수 함수

*<u>"부수 효과가 없는 함수"</u>*

순수함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다. <br>즉, 매개변수를 통해 함수내부로 전달된 인수에게만 의존하여 반환값을 만드는 함수를 순수함수라고 한다.

```js
var count = 0;
function increase(n) {
return ++n;
}
count = increase(count);
console.log(count); // 1
----------------------------
① count라는 변수에 undefined가 할당되었다가 초기화된다.
② count라는 변수는 새로운 메모리공간에 0 값이 할당된 곳을 가리키게 된다. 
③ 또 다른 메모리공간에 빈 객체가 생성되었다가 그 곳에 객체의 내용이 생성된다.
④ increase라는 함수의 이름이 가리키고 있는 메모리공간은 이미 객체가 생성된 곳의 메모리 주소가 채워져있다.(참조값)
⑤ 함수가 실행이 되어 1이라는 값이 반환된다. 
⑥ 반환된 1이라는 값은 또 다른 새로운 메모리 공간에 채워져서 count값으로 재할당되어,count는 결국 1이라는 값을 가리키게 된다.
-> 1 이라는 결과값 도출

count = increase(count);
console.log(count); //2
--------------------------
① 위에서 도출된 count의 1 이라는 값이 다시 매개변수에 할당된다.  
② 함수가 실행이 되어 2라는 값이 반환된다. 
③ 반환된 2이라는 값은 또 다른 새로운 메모리 공간에 채워져서 count값으로 재할당되어,count는 결국 2이라는 값을 가리키게 된다.
-> 2 이라는 결과값 도출
```



## 비순수 함수

*<u>"부수 효과가 있는 함수"</u>*

비순수 함수는 함수 외부 상태에 따라 반환값이 달라진다.<br>또한, 비순수 함수는 함수 내부에서 외부 상태(var count = 0;)를 직접 참조하면 외부 상태에 의존하게 되어 반환값이 변할 수 있고, 외부 상태도 변경할 수 있다.  

```js
var count = 0;
function increase() {
return ++count;
}
count = increase();
console.log(count); // 1
----------------------------
① count라는 변수에 undefined가 할당되었다가 초기화된다.
② count라는 변수는 새로운 메모리공간에 0 값이 할당된 곳을 가리키게 된다. 
③ 또 다른 메모리공간에 빈 객체가 생성되었다가 그 곳에 객체의 내용이 생성된다.
④ increase라는 함수의 이름이 가리키고 있는 메모리공간은 이미 객체가 생성된 곳의 메모리 주소가 채워져있다.(참조값)
⑤ 함수 내부에서 함수 외부에 있는 var count = 0; 라는 외부 상태를 직접 참조하는 함수가 실행이 되어 
0 이라는 값에서 1이라는 값이 반환된다. 
⑥ 반환된 1이라는 값은 또 다른 새로운 메모리 공간에 채워져서 count값으로 재할당되어,
  count는 결국 1이라는 값을 가리키게 된다. 
-> 1 이라는 결과값 도출

count = increase();
console.log(count); //2
--------------------------
① 위에서 도출된 count의 1 이라는 값이 다시 매개변수에 할당된다.  
② 함수가 실행이 되어 1이었던 값은 2라는 값으로 바뀌어 반환된다. 
③ 반환된 2이라는 값은 또 다른 새로운 메모리 공간에 채워져서 count값으로 재할당되어,
  count는 결국 2이라는 값을 가리키게 된다. 
  -> 2 이라는 결과값 도출
```



모든 함수가 순수 함수인게 가장 이상적이지만 항상 그렇게 되진 않는다.<br>순수 함수로 만든다면 외부 상태에 전혀 의존하지 않고 외부의 상태를 바꾸지도 않기때문에, 보다 견고한 프로그램을 만들수 있다.<br>그렇게 함수형 패러다임은 모든 함수를 순수함수로 만들어보는것을 추구하고 있지만 그렇게 만드는것이 어렵다. <br>하지만 모두 다 순수함수로 만든다면 상태를 관리하는 것이 어렵게 되므로 주의하자.