# 함수란?

![캡쳐80](https://user-images.githubusercontent.com/62126380/80487611-13e48880-8998-11ea-8dc4-10947142f816.PNG)  

JS에서의 함수를 이미지화 하여 보았다. 

외부에, 함수 밖에 있는 자료인 '인수'를 매개변수( *parameter* *: 파라미터* )인 x 와  y 에 할당하면 코드블록으로 안에 묶여있는 함수계산을 통해 <br>반환값 함수 바깥으로 출력해내는 것이 JS의 함수이다. 

- 프로그래밍 언어의 함수는, 일련의 과정을 문들로 구현하고, 코드 블록으로 감싸서 하나의 실행단위로 정의한 것이다.

- 함수 리터럴로 함수를 생성할수 있다. ( function + 함수이름 + 매개변수 목록 + 함수 몸체) = 함수 정의 *<- "함수를 만들고 싶어? 그럼 함수 리터럴을 만들어 (a.k.a "소혜야, 가수가 되고 싶어?")*

- 함수 내부로 입력을 전달받는 변수를 **매개변수**, 입력을 **인수**, 출력을 **반환값**이라 한다. <br>그리고 함수는 값이며 여러개 존재할수 있으므로 특정 함수를 구별하기 위해 식별자인 **함수 이름**을 사용할 수 있다. 

- <p style="color:red";>함수는 "함수 정의" 와 "함수 호출" 두개로 이루어져있다.<br>허나, 호출문을 굳이 쓰지 않아도 된다. 대신, "함수 호출"문을 출력하던지, 저장을 하던지 해야 한다. 호출문을 쓰고 출력문을 쓰는건 일 두번 하는 것이다. 반드시 호출문을 써야 하는건 아니다</p>

  ``` javascript
   function add(x, y) {
       return x + y
   } // 함수 정의문 끝
  add (1, 2); // 함수 호출문 끝 (호출만 하고 끝내려면 해당 호출문처럼 호출문만 사용하고 끝내라.)
  : 반드시 함수 호출문을 써야만 하는건 아니다. 
  console.log(1,2); // 출력해라. 함수 호출문을. (위 호출문을 대체할수 있는 출력문이다. (출력문에 호출문을 넣어준 상태.)
  ---------------------------
  // 3 이란 결과값 도출
  ```

![캡쳐93](https://user-images.githubusercontent.com/62126380/81039855-09b91180-8ee5-11ea-99c2-9a9f5233d6b2.PNG) <img src="https://user-images.githubusercontent.com/62126380/81069386-c7132b80-8f1c-11ea-9edc-35d554be63c7.PNG" alt="캡쳐94" style="zoom:80%;" />

  *<- 어지럽다.......*

``` javascript
위 코드에서 사용된 예약어는 'function', 
사용된 함수이름은 'add', 
반환값은 x + y , 
매개변수(x, y)에 할당될 인수는 (2, 5)이다. 
x + y 의 반환값이 result 라는 변수에 반환되어 저장된 상태이다.
```

#### 함수 정의

<u>*함수선언문이라고도 한다. 또는 함수 리터럴이라고도 한다.*</u>

- 함수는 함수 정의를 통해 생성된다.

- 함수 선언문은 런타임 이전에 실행된다.

- 여러번 반복 가능하다(재사용이 가능하다)

- 코드 블럭 안에는 0개 이상의 문들이 있다. 

  ##### 함수 이름

  - 식별자이다. 따라서 식별자 네이밍 규칙을 지켜야 한다.
  - 함수 몸체(코드블럭) 안에서만 유효하다.(함수가 실행될 동안 필요하며, 함수가 끝나면 즉, 코드블럭이 끝나면 필요없게 된다)

  - 함수의 행위를 하기때문에 그 행위를 잘 추상적으로 설명할 수 있는 "동사"로 지어야 한다.
  - 함수 이름은 생략가능하다. (함수 이름이 있는 함수: "기명 함수" / 함수 이름을 생략한 함수: "익명 함수" )
  - 함수 이름으로 함수 호출할수 없다. 하여, 호출되는 것은 식별자로 호출되는 것이다.

  ##### 매개변수( *parameter* *: 파라미터, 인자*  )

  - 0 개 이상의 매개변수가 올수 있다. 

  - 외부에서 재료를 넣어주는 투입구의 역할을 한다.
  - 매개변수를 통해서 외부에서(함수 몸체 밖에서) 값과 연결시켜줘서 값을 할당받는다.
  - 함수 몸체 내부에서만 참조 할 수 있고 함수 몸체 밖에서는 참조 할수 없다.<br>매개변수의 스코프(유효범휘)는 함수 내부라는 의미이다.
  - 매개변수에 함수 호출문을 할당할 수 있다. 
  - 배개변수도 식별자 네이밍 규칙을 지켜야 한다.
  - 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식 그대로 따른다.

  ##### 반환값

  - 함수 몸체 안에 있는 행위가 끝나면 반환값을 함수 밖으로 출력한다.

  ##### 식별자

  - 식별자 선언을 안해도 함수 선언문을 통해서, 함수 선언문이 실행될때 암묵적으로 함수이름과 똑같은 식별자가 선언된다.
  - 선언되어진 식별자가 함수 객체가 있는 위치값을 가리킨다

- 함수를 정의하는 방법

  1. 함수 선언문
  2. 함수 표현식
  3. Function 생성자 함수
  4. 화살표 함수

#### 함수 호출

*함수 할당문, 함수 호출문이라고도 한다.*

```javascript
ex)
1. add ( 2, 5);
2. var result = add (2, 5)
-----------------------
위 2줄은 동일한 표현의 함수 호출문이다.
```

- 호출문이 실행되야 함수의 코드블럭이 실행된다

- 함수 호출을 해야 함수가 일을 하기 시작한다. 호출을 안하면 함수 정의만 있는 상태인데, 그 상태에서는 함수가 동작하지 않는다.

  ##### 인수( *argument : 아규먼트* )

  - 인수를 입력 주면서 "너 일해" 라고 하는 것을 함수 호출이라고 한다.
  
  - 인수가 쓰여있는 순서와 매개변수가 쓰여있는 순서가 동일하다.
  - 함수 밖에 쓰여있는 인수를 함수에 쓰이는 매개변수에 할당한다.



## 함수 리터럴

### 1. 기명 함수 리터럴

#### 함수 선언문

---

```js
function 함수이름 (매개변수) {
    
}
```

- 코드블럭이 단독으로 사용된다.

- 표현식이 아닌 문으로 해석되기 때문에<br>값으로 평가될수 있는 문맥에 X 안온다.

- `함수 호이스팅`이 발생한다.<br>런타임 이전에 함수 객체가 먼저 생성된다. 그 후에 함수 이름과 동일한 이름의 식별자를 암묵적으로 만들고 함수를 만들어서 할당까지 해준다.

  > 변수 호이스팅은 변수가 생성되고 -> undefined로 초기화 되어지지만,<br>함수 호이스팅은 암묵적으로 함수를 가리키는 식별자가 선언되어지고<br><u>함수 객체로 초기화된다.</u>
  >
  > 따라서 함수 선언문 이전에 함수를 참조 할수 있으며 호출도 할수 있다. 

```javascript
ex) 함수 호이스팅
console.dir(add); // <- 함수 선언문 이전에 함수 참조가 가능하다 // ƒ add(x, y)
console.log(add(2, 5)); // <- 함수 선언문 이전에 함수 호출이 가능하다 // 7

function add(x, y) {
  return x + y;
}
```



### 2. 기명 함수 리터럴 & 익명 함수 리터럴

#### 함수 표현식

---

```js
ex 1)
var A = function 함수이름 (매개변수) {
    
}

ex 2)
var A = function (매개변수) {
    
}
```

- 코드블럭이 단독으로 쓰이지 X 않는다.

- 표현식인 문으로 해석되기 때문에<br>값으로 평가 될수 O있음.

- 변수에 할당이 가능하다.

- `변수 호이스팅`이 발생한다.

  > 변수 선언을 하고, 할당문 뒤에 함수 리터럴을 놓으면 함수 표현식이 된다.<br>그래서 할당문이 실행되기 직전에 함수가 생성된다. 
  >
  > 따라서 함수 표현식 이전에 함수 참조도, 함수 호출도 불가능하다.

```javascript
ex) 함수 표현식 이전에 함수참조도 불가능, 함수 호출도 불가능하다

console.dir(sub); // <- 함수 표현식 이전에 함수 참조 불가능 // undefined 
console.log(sub(2, 5)); // <- 함수 표현식 이전에 함수 호출 불가능 //ypeError

var sub = function (x, y) {
  return x - y;
};
```



## 함수 호출

### 인수가 부족하거나 초과한 경우

함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 일반적이지미나, 그렇지 않은 경우에도 에러가 발생하지는 않는다. 

1. 인수가 부족한 경우

   ```javascript
   ex)
   function add (x, y) {
       return x + y;
   }
   console.log(add(2)); // NaN 이란 결과값 도출
   --------------------------------------------
   위 코드는 인수의 갯수가 매개변수의 갯수보다 부족한 경우이다.
   이런 경우에는 순서에 맞게 현재 주어진 인수가 첫번째 매개변수에 할당이 된다. 
   인수가 전달되지 않은 매개변수는 undefined 가 나오게 되어 2 + undefined 가 된다. 
   이는 숫자+undefined 가 되어 계산되지 못하는 값으로 NaN 이란 결과값이 도출하게 된다.
   ```
   
2. 인수가 초과되는 경우

   - 초과된 인수는 무시가 되어 계산되지 않는다.<br>~고  보이지만 사실 무시가 된게 아니라 인수들은 arguments 라는 함수 내부에서 암묵적으로 생성되어지는 객체에 보관, 관리가 되어지는 것이다.
   
   - arguments 객체는 함수를 호출할 때 넘긴 인자들의 배열 형태로 저장된 객체를 의미한다. 여기서 주의할 점은 진짜 배열이 아니고 배열과 유사한 동작하는 객체이다. 

   - arguments 객체는 매개변수 개수가 정확하게 정해지지 않은 함수를 구현하거나, 전달된 인자의 개수에 따라 서로 다른 처리를 해줘야 하는 함수를 개발하는데 유용하게 사용될 수 있다.
   
   - 몇개의 인수가 전달되어도 상관없다고 헸을때는 매개변수를 비워놓고 함수를 만든다.<br>이런걸 **"가변 인자 함수"** 라고 한다. (인자라는게 가변적이다. 몇개가 올지 모른다.)
   
   - arguments 라는 객체는 공통적으로 length  라고 하는(인수의 총 갯수를 나타낸다.) 프로퍼티를 갖고있다. 
   
     > arguments와 같이, 프로퍼티의 이름이 숫자를 의미하는 문자열이고, length 프로퍼티가 있는 객체를 **유사배열 객체**라고 한다. 흡사 배열과 같이 접근할수 있기 때문이다.  
   
   ```javascript
   ex)
   function add (x, y) {
       return x + y;
   }
   console.log(add(2, 5, 10)); // 7 이란 결과값 도출
   ------------------------------------------------
   위 코드는 인수의 갯수가 매개변수의 갯수보다 초과한 경우이다.
   이런 경우에는 순서에 맞게 현재 주어진 인수가 순서대로 할당이 되어진 후, 
   초과되어 남은 인수는 무시가 된다. ....... 처럼 보이지만 arguments 라는 객체에 보관되어지는 것이다.
   
   console.log(arguments);
   // Arguments(3) [2, 5, 10, callee: ƒ, Symbol(Symbol.iterator): ƒ]
   <- arguments를 console.log 찍어보면 arguments에 인수가 보관되어진것을 확인할수 있다.
   ```
   
      ```js
   function add () { 
   var sum = 0; 
      for ( var i = 0; i < arguments.length; i++) {
            sum += arguments[i]
   	}
      	 return sum;
      }
   add (2, 5, 10);
   console.log(add(2, 5, 10)); // 15
   --------------------------------------
   arguments 객체의 length 를 사용한 함수이다.
      ```

   

### 인수에 잘못된 타입이 들어온 경우

인수는 모두 숫자 값이어야 한다. <br>만약 숫자가 아닌 다른 타입의 값이 인수에 들어온다면 TypeError가 난다.

```javascript
ex)
function add(x, y) {
    if (typeof x !=== 'number' || typeof y !=== 'number') // x 와 y 둘중에 하나라도숫자가 아니면
        {
        throw new TypeError; 
    }
    return x + y;
}
console.log(add(2)); // 인수가 매개변수 갯수보다 모다르다. 그래서 y값은 undefined가 나오게 되며,
				x 와 y 둘 중에 하나라도 숫자 타입이 아니면 TypeError 나오게 함수를 
                        동작했기 때문에 TypeError 가 도출된다. 
console.log('a', 'b') // <- 주어진 인수가 문자열이기 때문에 TypeError 가 도출된다.
```



## 반환문

함수는 return 키워드와 반환값으로 이루어진 반환문을 사용하여 실행 결과를 함수 외부로 반환ㄴ 할수 있다. <br>함수 내부에서 만든 값을 함수 외부로 아웃풋을 한다는 것이다. 

<u>**모든 함수에는 반환값이 반드시 존재한다.**</u>

- return  값은 생략 가능하다. <br>하지만 생략하게 된다면 undefined가 반환된다.

  ``` javascript
  ex)
  
  function foo() {
  
  }
  console.log(foo());
  // undefined 이란 값이 도출된다.
  ----------------------------------
  명시적으로 리턴을 안써주면 undefined 를 반환(리턴) 한다는 뜻이다.
  ```

- 반환문의 역할

  1. 함수를 종료시킨다.

     - 함수를 종료시키는 역할을 하기 때문에 함수 내부에서(함수 몸체 내부에서) 가장 끝에 위치해야 한다. <BR>리턴문 뒤에 또 다른 문이 있다면 그 문은 무시된다.

       ```javascript
       ex)
       
       function foo(x, y){
       return x * y ;
       console.log(foo());    <- 해당 콘솔로그 문은 실행되지 않는다.
       }
       console.log(foo(x, y)); // 15 란 결과값이 도출된다.
       ```

  2. 반환값을 반환한다.

     - return 키워드 뒤에 반환값을 명시적으로 쓰지 않으면 undefined  가 반환된다.

       ```javascript
       ex)
       
       function foo(){
       return:
       }
       console.log(foo());
       // undefined 라는 결과값이 도출된다.
       ```



## 참조에 의한 전달과 외부 상태의 변경

```js
function changeVal(primitive, obj) {
    primitive += 100;
    obj.name = 'Kim';
}

var num = 100;
var person = { name: 'Lee'};

console.log(num); // 100
console.log(person); // {naem: 'Lee'}

changeVal(num, person);

console.log(num); // 100
console.log(person); // {name: "Kim"}
```

![캡쳐95](https://user-images.githubusercontent.com/62126380/81188263-12e2d500-8ff0-11ea-8b7d-f799d21ff9ac.PNG) 



## 다양한 함수의 형태

### 즉시 실행 함수

함수 정의와 동시에 즉시 호출되는 함수를 말한다.

- 단 한번만 호출되면 다시 호출 할 수 없다. 

- 익명(무명) 함수를 사용하는 것이 일반적이다.

- 반드시 괄호로 감싸 주어야 한다. 그 이유는 먼저 함수를 평가하여 함수 객체를 생성하기 위해서이다.

  ```js
  ex 1) 인수가 없을때 
  
  var res = (function (){
      var a = 3;
      var b = 5;
      return a * b;
  }());
  console.log(res);   // 15
  
  ex 2) 인수가 있을때 (즉시 실행 함수는 인수를 전달할 수 있다. )
  
  var res = (function (a, b){
      return a * b;
  }(3, 5));
  
  console.log(res);   // 15
  --------------------------
  괄호로 함수문을 열고 닫아서 감싸주어야 하긴 하는데, 함수문을 아예 닫는 괄호 앞에 매개변수에 넣을 
  인수의 괄호도 넣어줘야 한다.
  ```



### 재귀 함수

함수가 자기 자신을 호출하는 것을 재귀 호출이라 한다. 즉, 재귀 호출을 수행하는 함수를 재귀 함수라고 한다.

- 재귀 함수는 자신을 무한 재귀 호출하기때문에 반드시 탈출을 해야 한다.<br> 탈출을 하지 않으면 무한반복하게 된다. -> 메모리가 꽉차게 되는 stack overflow 에러가 발생한다.

- 탈출조건은 제어문을 사용하여 만든다.

  ```javascript
  ex 1) 함수를 가리키는 식별자로 자기 자신을 재귀 호출
  
  var factorial = function foo (n){   // foo 라는 함수를 만들건데, 
    if (n =< 1) return 1;			// n이 1보다 작거나 같은게 맞으면 1이란 값을 반환해라
    return n * factorial(n - 1); 	// n이 1보다 작거나 같은게 아니면 n * factorial(n-1)이란 값을 반환해라
  }
  console.log(factorial(5)); //120
  
  
  ex 2) 함수 이름으로 자기 자신을 재귀 호출
  
  var factorial = function foo (n){   // foo 라는 함수를 만들건데, 
    if (n =< 1) return 1;			// n이 1보다 작거나 같은게 맞으면 1이란 값을 반환해라
    return n * factorial(n - 1); 	// n이 1보다 작거나 같은게 아니면 n * factorial(n-1)이란 값을 반환해라
  }
  retuen n * foo(n-1) //120 
  ------------------------------------------------
  5를 매개변수 n에 할당한다. -> if문으로 들어간다 -> if문의 조건식이 참이면 1 반환. 아니면 n * factorial(n-1) 을 
  반환해야 하는데 현재 n 이 5니까, 아닌 경우의 값을 반환해야 한다
  -> 5 * factorial(4) 라는 값이 반환되어야 하는데 factorial(4) 가 호출문이 되었다. 
  -> factorial(4)로 인해 4가 매개변수 n에 재할당이 된다 -> if 문으로 들어간다 
  -> if 문의 조건식이 참이면 1 반환, 아니면 n * factorial(n-1) 을 
     반환해야 하는데 현재 n 이 4니까, 아닌 경우의 값을 반환해야 한다
  -> 4 * factorial(3) 라는 값이 반환되어야 하는데 factorial(4) 가 호출문이 되었다.
  -> 반복한다. -> n이 1이 된 상황 -> 현재 n 은 1니까 1 값을 반환 -> 5*4*3*2*1 = 120 이란 결과값이 도출
```
  
  ```js
  ex) whlie 문을 구현한 재귀 함수
  
  function factorial (n) {
      if(n =< 1) return 1;
      var res = n;
      while (--n) res *= n;
      return res;
  }
  console.log(fantorial(5)); // 120
  -----------------------------
  5를 매개변수 n 에 할당한다 -> if문으로 들어간다 -> 현재 n이 5가 맞으면 1이란 값을 반환하고, 아니면 다른 문을 실행해야 한다.
  -> res 란 변수의 값이 현재 n이 5니까 5가 되었다 -> while 문으로 들어간다 -> n은 할당연산자에 의해서 5에서 4로 되었다.
  -> res = res * n 이란 식을 실행하게 되면 res는 현재 5니까, res는 5 * 4가 된다. 
  -> res는 20이 되었다 20이란 값을 반환하였다 -> 다시 while 문으로 들어간다 -> n은 4에서 3이 되었다 -> res는 현재 20이다 
  -> 할당 연산자에 의해서 3은 2가 되었다 -> 현재 res 는 20 이므로 res 는 20 * 3이 된다 -> res 는 50이 되었다. -> 반복한다 
  -> n이 1이 되었다. -> res는 현재 120이다. -> 할당 연산자에 의해서 1은 0 이 되었다. 
     0은 false의 값을 도출하므로 while 문을 탈출하게 된다
  -> 5*4*3*2*1 = 120 이란 결과값이 도출
  ```



### 중첩 함수

함수 내부에 정의된 함수를 중첩 함수라고 한다.

>**중첩 함수 (= 내부 함수)**
>
>함수 내부에 정의된 함수
>
>일반적으로 자신을 포함하는 외부 함수를 돕는 헳퍼 함수의 역할을 한다.
>
>**외부 함수**
>
>중첩 함수를 포함하는 함수



### 콜백 함수

반복을 하는 행위를 하는 함수를 콜백 함수라고 한다.
