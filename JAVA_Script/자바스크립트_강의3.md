# 데이터 타입

타입이 있어햐 하는 이유 : 메모리에 몇바이트 쓸거냐 / 숫자면 8바이트를 확보한다. 문자는 몇바이트인지 모름. 근데 최소 2바이트 이상일거야. 

값은 표현식이 평가된 결과물이 저장된 데이터

데이터 값을 마구마구 섞었어.

값의 종류가 있다. 

언어 종류에 따라서 데이터 타입이 다르다.

예를 들어서, int (정수라는 뜻. 음수도 정수에 포함 0 도 포함 양수도 포함. 음수를 포함한 정수라른 뜻)

int 를 선언하면 int x : x 변수는 int  타입이란 뜻이다. 

근데 자스는 var x ;라고 선언하잖아. 그럼 var 라는 키워드는 의미는 타입의 이미는 담지 않고 변수를 선언하라는 키워드일뿐이다. int 언어 var 언어는 차이가 있다. var 동적 타입 언어 int 정적 타입언어

정적 타입언어는 변수 자체에...

int x ;

x = true 라고 하면 에러다. 

정적타입을 도입하지 않고 동적 타입을 도입했다. 자스 언어에는 타입이 없다. 

그럼 타입은 누구에 대한 얘기지? 값에 대한 얘기다. 값이 타입이 있는 거다. 

var x ;  x 라는 식별자가 가리키고 있는 값은 언디파인드 타입이다. 

typeof 라는 연산자가 있는데 이 뒤에 x ; 라고 쓰면 x 의 타입은??? 이라고 물어보고 있는 뜻이다. 

이거는 변수 x 라는 애가 타입을 갖고있다고 보기보다는 변수 x 에 할달이 되어진 값에 타입이 있다는 뜻이다. 그럼 저 두 언어의 차이점이 뭘까? 

int 언어는 변수선언할때 이 변수를 사용하는 목적이 뚜렷하다. var 는 이리저리 돌려써도 되 라는 의미를 담고 잇다. x =1 ; 이라고 할당하면 넘버타입, x = true 라고 재할당하면 불리언타입이고, x = { }라고 하면 객체 타입이 된다. 

값에만 타입이 있기 때문에 어떤 값을 할당하느냐... 동적 타입언어라고 한다. 타입을 모르면 

어떤 문제가 생길까 ? 예를 들어서 1 + 1 은 2로 평가된다. 숫자타입 + 숫자타입 = 숫자타입

1 + 언디파인드 = none 값이다. (계산을 못한다. 그래서 none 이란 어거지 값을 만들어서 계산을 못하게 한다. )

원래는 편하게 쓰라는 목적이 우리의 발목을 잡는다. 그래서 어케 해야 한다? 대부분 내가 뭘 쓸때 타입이 뭔지 확인해야 한다. 



**암묵적 타입변화** : 타입이 변하기도 한다. 암묵적으로 일어난건 우리는 모른다. 암묵적으로 자스가 하는게 많기 때문에 우리가 알고 있지 않으면 실수할 가능성이 높다. 



---

- 값의 종류를 말한다. 

- 자스의 특징: 데이터 타입, 줄여서 타입이라고도 부른다. 

- 자스의 모든 값은 데이터 타입을 갖는다

- 자스에서 값이라고 부르는 것들은?(총 7개의 타입이 있는데 크게 두개로 구분할수 잇다. 원시타입이랑 객체타입이랑 성격이 많이 다르다.)

  - 원시타입(기본형, 기본자료형)

    - 숫자 : 타언어에서는 정수와 실수 구분하지만 자스는 정수 실수 구분없이 다 실수라고 숫자라고 한다.

      - 숫자는 숫자로 사용한다. 숫자의 존재의 이유. 기본목적은 계산하기 위해. 
      - 2진수로 들어갔다가 데이터 타입의 십진수로 변환해서 가지고 옴(저장할때도 바이트를 알아야하고 가지고 올때도 바이트를 알아야 함)
      - 정수로 10 숫자를 써도 10.0 다 . 
      - 메모리 안에 들어가는 .... 
      - nan : 계산을 하려했는데 계산을 못했을때 
      - 'x '*  10  // NaN

    - 문자열 : 문자들의 집합. 0 개 이상의 문자들의 집합

      - 모든 문자열은 ' '   으로 쓰자. 

      - 문자열은 기록과 누군가에게 읽히기 위해 존재. 출력하기 위해 존재.

      - 얘는 부동소숫점으로 들어감. 유니코드로 변환해서 가지고 옴(저장할때도 바이트를 알아야하고 가지고 올때도 바이트를 알아야 함)

      - 리터럴 말고 다른방식으로도 문자열을 만들수 잇다.

        함수를 통해서도 만들수 있지만 뻘짓이야.

        예시)

        ' ' : 문자 0개. = 빈 문자열

        " " : 원래 이렇게 써야 함.

        예시)'a'  / '아' 'あ' 다 쓸수 있지만 영어 외에 쓰는건 비추.  (자스는 utf 16이다. 16이란건 비트를 나타낸다. )

        왜 자스는 문자열을 원시타입으로 할까? 

        - **템플릿 리터럴** 

        - **멀티라인 문자열 헬로 하고 엔터치고 다음줄에 월드 나오게 개행 하면 에러 나옴.** 

          **개행하려면 이스케이프 시퀀스를 써야 한다. (\n  만 알면 된다)**

          **-> 이거 강의 2번에 추가 하자.**

    - 불리언

      - 조건문 같이 참과 거짓으로 구분되는 조건을 줘서 구분하고 싶을때 쓰임

      true

      false

    - 언디파인드

      - 우리가 만들일이 있을까? 없어. 만들어서도 안되. 

      - 왜? 만들어졌느냐. 왜 만들었느나. 암묵적 초기화를 위한 값이다. 자스엔진이 언디파인드가 만든다. 자스엔진이 언디파인드 쓸라고 만들어진 값이다.

      - 예시)

        var foo;

        console.log(foo):

      - var x =1 ;

        x =undefined -> 문법적으로는 에러는 안나지만 시멘틱에 맞냐는 건 오해의 요소가 있다. 이런 구문은 금지다. 이렇게 하는 의도를 모름. 

    - 널

      - 널타입의 값은 널이 유일하다. 
      - 의도적 부재를 나타내는 값.
      - 모든 언어들이 널이란 값을 갖고 잇다. 
      - 값이 없을을 나타내는 값이다. 
      - 무슨 이유에서든지 어떤 변수는 값이 없어~ 할때 주는 값이다.
      - foo = null ;   (빨리 죽이면 된다. )
      - 전역변수이다. 

    ----- > 여기까지 리터럴로 만들수 있다. 

    - 심볼타입

  - 객체타입
    - 원시타입 제외하고 대부분의 데이터들은 객체타입이다. 



"+" : 양쪽다 숫자이면 산술 연산자, 어느 한쪽 이 문자면 문자열 연결 연산자

문자열 연결 연산자 예시) '1'+1 ='11'



## 데이터 타입의 필요성

값이란 것은 메모리에 들어가야 하는데 메모리 몇바이트를 확보해야 하는지 알아야 한다. 

그 값이 메모리에 들어가기 전에 그 데이터로 ...

메모리에서 읽어들일때도 몇 바이트로 읽어들여야 할지 알아야 한다. 

그리고 읽어들일때 십진수로 읽어들여야 하는데 그걸 어떤식으로 해셕해야 하는지 지침이 잇는데 그게 데이터 타입이다. 



## 동적 타이핑

타이핑이라는 건 타입을 만든다 라는 뜻으로 받아들여야 한다. 

동적은 뭐고 정적은 뭘까

정적은 한번만들고 그 페이지가 안바뀌는걸 말한다. 

그럼 동적 웹사이트라는 건 뭘까 뭔가 내용이 바뀐다는 것이다. 예를 들어서 로그인화면, 이마리씨 어서오세요. 내가 이마리인줄 어케 알았지? 그 부분을 동적 웹사이트라고 한다. 그때그때 내용에 따라서 바뀌는걸 동적 웹사이트라고 한다. 

동적타입은 타입이 바뀐다. 언제 바뀌나요? 모르지 그건. 근데 바뀐다는 거다. 

정적타입은 타입이 안바뀐다는 것이다. 

변하느냐 안변하느냐. 뭐가? 타입이.

예시) int num ;

​		var x ; 

변수에는 타입이란게 존재하지 않는다. 하지만 타입오브라는 연산자를 통해서...

x 라느 타입을 본다고 하지만 x 라는 표현식을 통해서..

타입이 없으니까 얘는 어떤 값도 재할당을 자유롭게 할우 있다. 

x= 1;

x = 'sit'

x = ture

x= { };

x = function

등등 

동적으로 타입이 변하고 있다. 이런걸 동적 타이핑이라고 한다. 이게 좋은건가? 편리하긴 하다. 

타입에 상관없이 막 넣을수 잇으니까 , 근데 편리하면 분명히 부작용이 있다. 타입을 알기 어렵다. 

정적타입은 타입을 바로 알지만 동적타입은 타입이 변하니까 변하는 것을 알아차리기 힘들다. 거기서 실수가 나오는거다. 그래서 변수를 많이 쓰지 말라는 이유다. 그럼 어케 하지?

타입이 반드시 넘버타입이어야 하는 상황이 있다면 그때는 체크를 해야 한다. 그 때 타입이 넘버이면. 라고 체크해야 한다. 

우리는 동적타이핑이기 때문에 곤란하다. 

동적타입은 개발자 입장에서는 편하다. 하지만 메모리의 손해를 본다. 



재할당은 <u>"가급적"</u> 안하는 거다. 

따라서 var 는 재할당이 자유롭다. let 도 자유롭다 const 는 재할당...  필요없는 재할당을 막기위해서 const를 많이 쓰게 될것이다. 

만약에 재할당을 하게 됬다고 한거면 값을 교체 햇다는 건데 그건 상태가 변했다는 의미이다. 

예를 들면 지금 불이 켜져잇는데 누가 불을 끄면 불이 꺼져잇는 상태



변수는 타입이 없지만, 타입이 잇다고 가정하면 할당될때.. 

자스는 동적타입 언어이기 때문에 변수를 쓸때 주의해야 한다. 

동적타입언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할수 있다. 

편리는 하지만 위험도 있다. 



변수는 필요할때만 써라. 이건 당연한 얘기지만 필요할때만 쓰지 못하는 경우들도 있다. 

변수는 재할당이 가능해서 타입때문에 오류가 발생할 가능성이 크다. 변수는 꼭 필요할때만 써라. 

그래서 변수 선언할때 꼭 써야 하는지 생각하고 써라. 

변수가 오래살면 리소스를 차지하게 된다. 



전역변수는 적극적으로 사용을 억제해야 한다. 전역변수는 우리의 적이다. 



변수라는 개념이 있고 상수라는 개념이 있는데 변수는 변하는 수, 상수는 변하지 않는 수라고 알고 잇지만 그렇게 알고 잇으면 안된다. 변수는 재할당이 가능한것이고 상수는 재할당이 불가능한것이라고 알고 잇어야 한다. 재할당이 불필요한 애들한테는 const를 써서 상수화한다. 

![image-20200424154421863](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200424154421863.png)

일주일전의 나와 대화를 하자... 심신을 차분히 가라앉히고... 후...



# 연산자

연산을 하는 무엇인가를 연산자라고 한다. 

연산이 되는 대상을 피연산자라고 한다. 

1개 단항

2개 이항

3개 삼항 연산자

피연산자가 값이라는 명사의 역할을 한다면 연산자는 동사의 역할을 한다. 

## 산술 연산자

더하고 빼고 곱하고 나누고 나머지 

3 % 2 = 1

4 % 2 = 0 (2로 나눠서 0 이면 짝수, 1이면 홀수)

---

## 단항 산술 연산자

++ 증가

-- 감소

"+ " 아무것도 안한다. 

증가를 한다는게 뭘까?

증가를 한다는 의미. x 를 1 증가 시킨다. 증가가 되었다는건 재할당 했다는 말이다. 암묵적으로 재할당이 이뤄졌다고 한다. 이런식으로 연산자 중에서 암묵적으로 재할당이 되는건 2개가 있다. ++ / -- 

부수효과가 잇다. 

= 가 먼저고 x+1 이 다음에 이뤄진다. -> 이건 문법이다. = 보다 먼저된다 나중된다라고 할수 있다. 

암묵적 타입변환 : 지가 알아서 변환하는거

명시적 타입변환 : + 으로 명시적 타입변환 하는게 많다. 

원래 + 뒤에 숫자가 와야 하는 문맥인데 숫자가 안왔다는걸 알아차린다. 뒤에꺼를 숫자로 바꿔버린다. 

var x = '10'

---

## 문자열 연결 연산자

" + " : 피연산자 두개 모두 숫자이면 산술연산자로 동작한다. 둘중에 피연산자 중에 단하나라도 문자열이면 문자열 연결 연산자로 동작한다. 

사실 이게 숫자이기를 바랫던 상황이라면 어케 하면 될까? 그땐 오류를 발생시키겟지. 

true를 숫자로 바꾼다. (문맥에 따라서) + 뒤에 숫자가 오는 문맥이라서 true 를 1로 변환시켜서 값은 2가 된다. 

'1' + false = 1false

null 은 없다라는 뜻이라서 0 이랑 비슷하다. 그래서 0으로 평가된다. 

언디파인드 : 언디파인드 앞에 플러스 연산자 붙힌 코드의 의도는 아~ 이 사람이 언디파인드를 숫자로 바꾸려고 했네~ 였지. 근데 얘가 좀 들 알았네~? 왜? 언디파인드는 약간 부정적 의미를 갖고있지만 0 값이 아니다

1이랑 언디파인드 더하면 NaN 이 나온다. 



---

## 할당 연산자

=  : 5라는 숫자값을 x 변수값에 할당

 += : x 는 x +  5 라는 뜻

표현식이다. 

할당되어지는 값으로 평가되기 때문에 표현식이다. 

c = 0 ; 부터 처리가 된다.

c = 0 을 먼저 안하면 어쩔건데 부터 생각을 해봐라. 원래 맨처음은 0 이다. 0 을 결정하고 ...

= 0  을 0 으로 생각해야한다. b = c  = 0 까지 0  으로 평가된다

## 비교 연산자

= 하나짜리는 할당 연산자이다. 

같은 경우가 있고 틀린 경우가 있으면 트루 풜스로....

== 사용금지이다. 얘는 우리 코드에서 한번이라도 쓰이면 안된다. 

5 == 5  : 왼쪽 5도 리터러리, 오른쪽 5도 리터러리. 값 자체를 비교한것이다. 

원시값일 경우엔 값 자체를 비교한다. 

=== 왼쪽 오른쪽이 같으냐 라고 물어보는거, 같으면 트루값

왼쪽! == 세모  : 왼쪽이랑 오른쪽이랑 다르니? 다르면 트루값, 같으면 풜스

함수 이름은 동사로 지어야 한다. 값은 명사이고 함수는 행위이기 때문에 동사로 지어야 한다.



## 대소관계 비교 연산자

대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.

 var x = 1;  x 가 무슨 값인지 모르는데, x 가 짝수이면 아래 x의 ...

var result ; '' ';

if (x %2 === 0) 이게 0이면 짝수라는 뜻

result = '짝수';(

else)

---

## 삼항 조건 연산자

var x = 1; 

var result = ' ';



if ( x % 2 ===0 ;) {

result = '짝수';

}else {

result = '홀수;

'}

이게 더 가독성이 좋아보입니다. 라고 하지만 

if ( x % 2)  { result = '홀수';

}else {

result = '짝수';

}

이게 더 자연스러운거다.

x % 2?  -> x 가 트루니 풜스니 라고 물어보는것이다.

x 가 트루이면 홀수로 평가되어지고 거짓이면 짝수로 평가되어져야 한다.  ( result = x % 2 ? '홀수' : '짝수';) 



? 랑 : 이거로 이뤄져있다. 

ㅁ ? ㅁ : ㅁ -> 이게 표현식의 문이다.  

ㅁ ? ㅁ : ㅁ

if 문에 쓰여지는 조건식 ? 평가되어지는 표현식 : ㅁ 

- if else를 대체 할수 있다.

  var x = 1;

  var result = x % 2? '홀수' : '짝수';

  이렇게 될수 잇다.

결론 : 일단 if 문으로 만든다 -> 그래서 얘를 삼항 조건 연산자로 고치면 어케 될지 해봐야 한다 -> 더럽다 -> 다시 돌아간다. 

---

## 논리 연산자

논리합 :

true or true = true ll true

하나라도 참이면 참으로 평가한다. 

논리곱: true && true

어느 한쪽이라도 풜스면 풜스

부정: ! true

------

암묵적 타입 변환

10 ;   여기에 트루 풜스가 와야 하는 문맥이야. 

! 'hello' ; 

---

var x ;

var result = ' ';

if (x){

}

: 값을 할당하지 않으면 안하겟다. 

---

## 단축평가

빈 문자열이면 풜스, 아니면 트루 

'cat' 얘가 트루여도 뒤에있는 'dog' 도 봐야한다. 'dog'  가 결정하니까 이 표현식을 결정지어줄 애는  'dog'

## 쉼표 연산자

쓰지 마세요

표현식인 문이다. 

---

## 그룹 연산자

## 타입오브 연산자

## 지수 연산자

math pow(2,2)

-> 첫번째 2 가 밑, 두번째 2 가 지수

반드시 (-5)를 해야 에러가 안난다. (-5 ** 2 )하면 에러난다.

2 * 5 ** 2 ;

 -> "** " 얘가 우선순위 톱이다.

## 연산자의 부수 효과

부수효과 : 연산자가 3개야. 플러스플러스 / 마이너스마이너스  /딜리트 / 

변수의 값이 교체되느냐 를 말하는 것이다. 