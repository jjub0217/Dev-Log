## 원시값과 래퍼 객체

심볼만 함수로 만든다.

심볼은 생성자 함수처럼 생겼지만 생성자 함수가 아니다.

래퍼객체는 정리하자면 넘버, 스트링, 불리언, 심볼이라는 원시값을 객체처럼 사용할때.... 래퍼 객체처럼 만든다.

예를 들어서 (아이패드 보기)

![image-20200511141307868](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511141307868.png) 

불리언 래퍼객체는 우리게에 무의미하다.

목차 4-1 에서 4-2까지는 에크마스크립트에 올라온것들이다. 

윈도우.인피니티 / 윈도우.NaN....

타입오브 인피니티: 넘버 

지금 다 전역객체의 메소드라는 얘기잖아. 얘네는 윈도우.이벨 또는 이벨 하면 된다. 그럼 만약에 이런 함수들을 올려놨다고 하면 얘네는 무슨 함수일까?

대부분의 메소드들은 프로토타입에 들어가있는데..... 얘네도 많이 쓸놈들이다라는 말이긴 한데 꼭 그렇지만도 않다. 

이벨: 사용금지-> 스코프를 교란시키고 보안에 취약하다. (위드 문이라는 것도 쓰지마라)

isFinite : 좀 쓴다. 이름을 보면 대충 감이 와야 한다. is라고 왔으면 얜  뭘 리턴할거 같아? 불리언이다. 얘는 무슨 뜻이냐면 "유한하니?" 라는 뜻인데, 뭐가? 주어가 있을거야. 그 주어를 우리가 알려줘야 한다. 인수를 줘야 한다. "뭐가 유한하니?" 할때 뭐는 수 일것이다. 

얘가 만약에 인수를 .... 하면 풜스가 나온다. 만약에 1을 주면 트루 나온다. 만약에 숫자가 아닌걸 주면 NaN나온다. 

isNaN : NaN이니? NaN응 NaN과 같지않다. ... 유일한 값이 NaN 이기 때문에 if (x ===NaN) <- 이렇게 쓰면안되고 if(inNaN) 이렇게 써야 한다. 

parseFolat: 부동소수점 배정밀도는 플로트 했다고 한다. 어떤 문자열이 주어졌을때 그 문자열을 플로트로 해석한다. 그래서 인수는 문자열로 준다. 

parseInt : 얘 많이 쓴다. 해석한다. 정수를. 얘도 문자열을 주는데 그 문자열을 정수로 해석한다. 

![image-20200511143342048](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511143342048.png) 

## encode URI / decode URI

 인코드: 어떠한 문자열을 형식을 바꾸는거다.

디코드: 형식이 바뀌져있는걸 원복시키는 거다.

예를 들어서 암호화하는거. 암호화해서 디비에 집어넣는거.기본적으로 암호를 넣었을때 그 회사도 암호를 몰라야하기때문에 암호화해서 집어넣는거다. 

암호가 맞는지 틀린지 원복해봐야 하는거다.

인코드, 디코드 라고 하면 암호화가 아니라 URI 랑 연관이 있다.

http : 하이퍼텍스트트랜스퍼프로토 <- 이걸로 통신하면 약속을 해야해. 그 약속을 누군가가 만들었어. 누가 만들었지? html 은 누가 만들었어? 팀 워너스 리 가 만들었는데 얘가ㅣ http 까지 만들었다.

얘가 규약을 만들때 아스키코드만 들어올수 있다고 정했다. 

### 암묵적 전역

![image-20200511144307407](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511144307407.png) 

위에 코드 조심해야 함.

# this

... 상태 데이터를 나타낸다.

... 프로퍼티의 값을 참조하거나 조작한다.

메소드 내부에서 프로퍼티에 접근할수 있어야 한다.

메소드가 프로퍼티의 값을 참조하거나 조작할수 있어야 한다. 또는 다른 메소드에 접근할수 있어야 한다. 

메소드 내부에서는 다른 프로퍼티에 접근할수 있어야 한다. 그럼 어케 접근할건데?

![image-20200511150138357](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511150138357.png) 

... 반지름이란 상태를 나타낸다. 혹은 이 상태를 가지고 다른 계산을 할수가 있다. 

겟 다이어미터라는 메소드가 있는데 얘는 지름을 구하는건데 얘는 값에 접근할수 있어야 한다.

레디우스는 프로퍼티다. 그럼 어케 접근할건데? 디스라는 개념을 모를땐

리턴 2 * 서클.레디우스 <- 이렇게 접근한다. 이 함수의 내부 코드는 언제 실행될까? 호출이 되어야 실행된다.

호출되기 전에는 한줄도 실행이 안된다. 호출되려면 이때 서클이 있어야 하나 없어야 하나? 있어야 얘를 호출할수 있다. 

... 반드시 이 객체가 존재하여야 한다. 따라서 이렇게 접근할수 있다. 

근데 이렇게 접근하는건 부작용이다.

또 다른 케이스를 봅시다. 

![image-20200511150408068](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511150408068.png)

디스라는게 필요한 이유는? 왜 필요하지? 디스의 존재 이유가 뭐지? 객체의 프로퍼티에 접근하기 위해서 존재한다. 

디스는 자신이 속한 객체 또는 자신이 생성한 인스턴스의 프로퍼티나 메소드를 참조할수 있다.

그런데 이 디스의 값은 어케 결정되어지냐면, 이 디스의 값이라는건, 디스는 어디서도 쓸수 있다. 이 뜻은 전역에서도 쓸수있고... 

근데 전역에서 디스를 쓴다는 건 무슨 의도일까? 뻘짓이다. 그럼 일반함수로 호출될건데, 그 일반함수에서 디스를 쓸수 있다는 말이잖아. 어디서든 쓸수 있다고 햇으니까. 그럼 이때 디스는 어떤 목적인가?

아까 디스는 무슨 목적으로 만든다고? 프로퍼티나 메소드에 접근한다고 했잖아. 무슨 목적이냐고? 뻘짓이다. 그럼 왜 자스 만든 사람이 일반함수로 호출될수 있는 함수 내부에 디스를 사용할수 있다고 했냐?

얘가 생성자 함수로 노출될수 있기 때문이다. 그러면 디스는 어디서든 쓸수 있는데 어떤식으로 바라봐야 하냐면, 식별자 비스무리한 놈으로 바라봐야 한다. 얘가 어떤 값을 가리키고 있다고 이해해야 한다. 

근데 그 값이 어케 결정되느냐? 어떤 공식대로 결정되는게 아니라 함수가 어케 호출되느냐에 따라서 동적으로 결정된다. <- 이게 불행의 시작이다. 

다른 언어, 클래스 기반 언어는 디스를 어디서 쓸수 있지? 클래스 안에서만 쓸수 있다. 클래스 기반 언어는 메소드 이외의 방식으로 호출할수 없다. 그래서 디스는 무조건 뭐냐면.... 

꼭 디스를 써야하는것도 아니다. 

근데 자스는 얜... 생성자 함수로도 호출될수 있다. 그래서 디스는 어떤식으로 결정되냐면 함수가 어떤식으로 .... 동적으로 결정된다. 

지금은 3가지 케이스를 알면 된다. 

1. 함수가 어케 호출될수 있을까? 일반함수로 호출된다고 가정: .. 푸를 열고 닫고.. 

   ...얘는 전역객체를 가리킨다.

2. 함수가 메소드로 호출된다고 가정: ... 이런식으로 호출

   메소드 내부에서의 디스는 메소드가 속한 객체를 가리킨다고 생각하면 안된다.

   메소드를 호출한 객체를 가리킨다. 라고 생각해야 한다. 

3. 함수가 생성자함수로 호출된다고 가정: 뉴 .... 괄호 열고 닫고

   생성자 함수가 생성할 인스턴스를 가리킨다.

![image-20200511151324406](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511151324406.png) 

스퀘어라는 함수는 무슨 함수냐? 이 상황에서는 모른다. 얘는 다양한 방식으로 호출할수 있다. 

호출되야 안다. 호출되기 전까지는 모른다. 그럼 얘를 일반함수가 아닌걸로 호출할수 있을까?

.... 함수 정의가 ... 될때 결정된다.

함수 정의가 위치한 곳이 바로 상위 스코프다.만약에 함수정의가 전역에 위치한다. 그럼 ... 이다.

푸 함수... 그럼 그 함수는 푸 함수 내부에 정의되었으니까 걘 푸 함수이다. 

정적 스코프, 스태틱 스코프, 렉시컬 스코프 다 같은 말이다. 

다이나믹 스코프, 동적 스코프 이렇게 하는것도 있다.

대부분이 렉시컬 스코프를 따른다.

상위 스코프는 함수 정의가 평가에 따라서 위치에 .... 결정된다.

디스는 함수 호출에 의해서 동적으로 결정된다. 

생성자 함수로서 호출될수 있는 함수만 가지고 있다.

없는게 두가지가 있었다. 화살표 함수랑 축약표현. 

메소드로서 호출된 함수 내부의 디스는 누굴 가리키냐? 위 코드에서는 퍼슨이다. (콘솔로그 (펄슨.겟네임());)

![image-20200511152406754](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511152406754.png) 

바인드: 묶는다. 변수에 값을 할당하잖아.  x = 1; <- 이걸 네임 바인딩이라고 한다. 

어떠한 값을 묶는다고 해서 디스바인딩이라고 한다. 이러면 

이 푸 함수 내부의 디스가 bar가 된다. 디스를 강제적으로 갈아끼운다고 한다.

그러면 중첩함수는 어떨까?

![image-20200511152834724](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511152834724.png) 

위에서 디스는 일반함수다.

만약에 스트릭트 모드를 사용한다면 아래 코드다

![image-20200511152922845](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511152922845.png) 

일반함수로 호출되었을 경우 함수 의 .... 무의미하다.

일반함수 내부에서 디스는 무의미하다. ... 에만 유의미하다. 달리 얘기해서 함수가 일반함수로 호출되면 무의미하다. ... 할때만 유의미하다.

![image-20200511153536170](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511153536170.png) 

메소드 안에 중첩함수를 정의할수 있나? 있다. 

![image-20200511153911058](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511153911058.png)

위 코드가 세련된 코드다. 이렇게 많이 쓰게 될것이다. 

푸( ){  } : 함수의 코드 블럭. 함수의 몸체다. 

함수 몸체에서 디스를 참조하면 함수 내부의 디스는 어케 결정되어진다? 함수를 어케 호출하느냐에 따라서 결정된다.

세가지가 있다. 일반함수로 호출할수도 있고 메소드로도 호출될수 있다. 생성자 함수로도 호출할수 있는데 위 코드는 생성자 함수로는 호출할수 없다. 

셋타임에서의 디스는 이 함수내부의 디스이므로 밖의 디스와 반드시 일치한다고는 말할수 없다. 

함수 내부와 외부가 있을때, 중첩함수는 윈도우를 가리키잖아. 

여기 셋타임 아웃의 콜백함수는 일반함수로 호출이다. 

## 메소드 호출

![image-20200511154252952](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511154252952.png) 

위 코드로 하면 객체가 몇개 만들어질까? 이 객체 리터럴이 평가되면 객체가 몇개 만들어질까?

두개다. 겍네임이라는 프로퍼티가 참조할 뿐이다. 

원래 독립적인 객체다. 그런데, 얘가 갖고 잇는 프로퍼티의 값 을 참조할 뿐이다. 

 ![image-20200511154424717](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511154424717.png)

어나더 펄픈이라는 객체를 만들고 얘를 바라볼수 있 할수있을까 없을까.

![image-20200511160819081](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511160819081.png) 

![image-20200511161026709](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511161026709.png) 

위 코드 주의하시기 바랍니다.

![image-20200511161700796](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511161700796.png) 

그 디스를 조작하려면 이런식으로 콜 메서드, 어플라이 메서드, 바인드 메서드를 사용한다. 

## Function.prototype.apply/call/bind 메소드에 의한 간접 호출

펑션.프로토타입에 있기때문에 뭐로 호출할수 있다? 디스가 누구여야 하냐는거랑 똑같다.

함수객체로 한다. 반드시 콜 어플라이 바인드 쩜 앞에는 함수 객체가 와야 한다.

콜이랑 어플라이가 한 세트이다. 

... 함수를 호출하는것이다. 

디스를 호출하는것이 1번

얘를 호출하면서 디스를 교체한다. 이게 2번. 

누구의 디스? 겟디스바인딩의 디스를 호출한다. 

![image-20200511162440842](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511162440842.png)

일반함수 호출이다. 

겟디스바인딩.어플라이(디스에이알지): 함수다. 

그러면 함수를 호출했을때 인수가 있을수도 있잖아. 인수를 어케 전달하지? 

![image-20200511163609474](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511163609474.png) 

호출문입니까 함수입니까?

콜백은 우리가 호출하는거 아니야. 고차함수더러 호출하라고 한거다. 

그래서 함수정의를 줘야 한다. 우리가 콜백함수는 명시적으로 주면 안된다.

![image-20200511164009520](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200511164009520.png) 

... 메소드가 속한 객체가 아니다. 

생성자 함수에서 ... 인스턴스를 가리킨다.

펑션.프로토타입.콜 또는 어플라이. 바인딩으로 함수를 호출하거나 교환할 수 잇따. 

---

# 자료구조와 알고리즘

```js
function myParseInt(binary) {
    const RADTX = 2l
    let res = 0;
    for (let i =0; i < bunary.length; i++) {
        res +- binary[i] * RADIX ** binary.lenth - (i +1);
        console.log(res); // 8, 8, 10, 10
    }
    return res;
}
console.log(myParseInt('1010')); // 10 인줄 알았는데 22 가 나옴.
```

