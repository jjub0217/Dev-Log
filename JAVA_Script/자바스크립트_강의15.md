![image-20200520132332558](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200520132332558.png) 

 폴리필이란 건 자스말고 css에서도 쓰인다.

포이치는 인수 두개 받는다(콜백이랑 디스).  우리 머릿속에 포이치를 구현해봐야 한다.첫번째 전달받은 인수가 함수여야 한다. 함수 아니면 어떤 일이 발생하나? 호출을 못한다. 문자열을 넣었다고 생각해봐라. 문자열 호출 못하잖아. 

첫번째 인수가 함수인지 체크해야 한다. 함수 아니면 에러를 발생시킨다. 치명타다. 회피방법이 없는거다.

두번째는 뭐로 넘어오지? 디스로 사용할 객체가 넘어온다. 두번째 매개변수는 옵션이다. 옵션이란 얘기는 포이치를 호출하는 사용자가 콜백을 반드시 줘야 하지만 ... 전달하지 않을 수도 있다는 얘기다.그럼 두번째 매개변수는 언제 쓰이는거지? ... 디스에 할당하는거다. 

원래 디스라는 키워드에는 할당을 못한다. 디스는 리드온니하다. ㅇ디스에이알지가 넘어올때가 있고 안넘어올때가 있다. 



포이치하고 맵은 공통점이 있다. 전달되는 인수가 같다. 

필터도 같다.  그런데 맵은 리턴값이 뭐였지? 포이치는 리턴값이 언디파인드고 맵은 배열이다.

배열의 요소는 어케 채워지지? 맵의 콜백함수가 리턴한 요소가 값이 된다. 

포이치를 맵을 하려면 새로운 빈 배열을 만들고 푸쉬를 하던지, 빈 배열에다가 하나씩 리턴값을 담아주면 된다. 

맵은 뭐다? 콜백함수가 리턴하는 값으로 채워진다. 반드시 맵의 콜백함수는 리턴이 있어야 한다.

명시적으로 리턴이 없으면 언디파인드가 채워진다.



무조건 맵의 콜백함수가 리턴하는 걸로 채운다.

필터는 콜백함수의 리턴값이 트루인 v 로만 채운다. 

결과론적으로 맵은 원본배열과... 항상 같을 수밖에 없다. 



화살표 함수를 안쓰면......

함수 표현식 쓸 생각하지 말고 화살표 함수를 쓸 생각을 해라.



---

##  reduce

얘도 콜백으로 순회한다. 

얘는 인수가 콜백으로 전달받는게 4개다. 

![image-20200520134334772](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200520134334772.png) 

위 코드는 콜백함수 4번 호출되는 코드다

여기서 디스는 초기값이다. 안주면 골때리니까 무조건 줘라. 

초기값이 첫번째 순서, 두번째는 배열에서 1이 들어온다. [ 0, 1]

첫번째 인수랑 두번째 인수를 더하네? 그럼 1이 리턴되겟네? 그 리턴값이 다시 두번째에 순회한다. 

첫번째 인수에 1 두번째 인수에 2. 더하네? 그럼 3이 되겟네? 이걸 반복한다. 

리듀스를 쓰면 효율적으로 쓸수 있다. 

얘는 조금 어렵기 때문에 여러가지 문제들을 줬으니까 풀어봐라.

중복요소 제거 풀줄 알면 신입으로 인정받는 정도다. 

매스의 .... 인수를 뭘로 받냐면 인수의 목록으로 받는다. 

![image-20200520141345322](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200520141345322.png) 

일단 순회하면서 어케 해야해? 얘를 일단 기억해야 겠네? 일단 기억하기 위해서 프로퍼티 키를 만든다. 

객체를 하나 만들어서 얘를 프로퍼티 키로 기억하는거다. 그리고 1로 세팅한다. 

그리고 두번째 순회. 처음 등장하는지, 두번째 등장하는지는 어케 알수있어?

포문을 쓴다고 가정해보자. 일단 무조건 프로퍼티키를 참조한다. 





![image-20200520142408146](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200520142408146.png) 

....컨켓으로 합친다. 

플래트를 써야 한다.



### 중복 요소 제거

이거 단골 문제다. 입사 시험 뿐 아니라 코테에 많이 나온다.

중복을 싹다 제거하고 유일한 요소들로만 채워진 배열을 만들고 싶은거다. 

![image-20200520142503677](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200520142503677.png) 

포문으로 일단 해보자. 

![image-20200520142921592](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200520142921592.png) 

위 코드가 제일 간편한 방법이다. 



초기값을 안주면 무슨 일이 일어날까? 안주면, 그냥 첫번째 요소가 오는거다. 

![image-20200520143102047](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200520143102047.png) 





### 어레이.프로토타입.썸

![image-20200520143308624](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200520143308624.png) 

썸이라는 것은 이 배열의 요소들 중에 이걸 가지고 한번씩 호출할거잖아.

하나라도 트루로 반환된다면, 트루로 반환한다.

요 조건을 만족하는 요소가 1개 이상 있느냐는 말이다.

필터로 이런식으로 이해하면 된다.  이 조건을 만족하는 요소만 반환한다고 이해하면 된다. 그래서 이프문의 조건식을 줘라 . 라고 하는건데 헷갈릴수 도 있어서 위 코드처럼 쓴거다

에브리는 뭘까? 모든 요소에 대해 콜백함수가 트루로 반환하는거다.



### 파인드

찾다지. 뭘 찾을까? 파인드가 있고 파인드인덱스가 있어. 파인드 인덱스는 인덱스를 찾는거고 파인드는 요소를 찾는거다. 

![image-20200520143502943](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200520143502943.png)

... 표현식을 리턴한다. 

요소 자체를 리턴하는거다.



필터는 뭘 ... 요소들로 이루어진 배열을 리턴한다.

파인드인덱스는 말그대로 인덱스를 찾느다. 

그럼 여러개 만족할수도 있잖아. 

찾는 요소가 없으면 -1 를 반환한다.

---

---

아래 배열을 사용하여 아래 코드가 나오도록 html을 생성하는 함수를 작성하라.

 ```js
const todos = [
    {id: 3, content: 'HTML', completed: false},
    {id: 2, content: 'CSS', completed: true},
    {id: 1, content: 'Javascript', completed: false},
];

function item() {
    let html = '';

    
    todos.foreach(todo => {
        
    });
    return html;
}
console.log(render());


// <li id="3">
  <label><input type="checkbox">HTML</label>
</li>
<li id="2">
  <label><input type="checkbox" checked>CSS</label>
</li>
<li id="1">
  <label><input type="checkbox">Javascript</label>
</li>
*/
 ```

(투두 =>); 이게 3번 돌거다. 이게 콜백함수다.

```js
{id: 3, content: 'HTML', completed: false},
=> `<li id="${todos[0].id}">
  <label><input type="checkbox">${todos[0].content}</label>
</li>`
```

```js

    todos.foreach(todo => {
        html += `<li id="${todo.id}">
  <label><input type="checkbox">{todo.completed ? 'checked' : ''}>${todo.content} </label>
</li>`
    });
```



요소의 프로퍼티(id, content, completed) 를 문자열 인수로 전달하면 todos의 각 요소 중, 해당 프로퍼티의 값만을 추출한 배열을 반환하는 함수를 작성하라.

단, for 문이나 Array#forEach 는 사용하지 않도록 하자.

```js
const todos = [
   {id: 3, content: 'HTML', completed: false},
    {id: 2, content: 'CSS', completed: true},
    {id: 1, content: 'Javascript', completed: false},
];

function getValues(key) {

}

console.log(getValues('id')); // [3, 2, 1]
console.log(getValues('content')); // ['HTML', 'CSS', 'Javascript']
console.log(getValues('completed')); // [false, true, false]
```

위 코드에서 맵을 써야하는건 어케 안거지...?

```js
const todos = [
   {id: 3, content: 'HTML', completed: false},
    {id: 2, content: 'CSS', completed: true},
    {id: 1, content: 'Javascript', completed: false},
];

function getValues(key) {
    //const arr = [];
todos.map(todo => arr push()) // <- 이걸 안할라고 맵을 쓴거다
todos.map(todo => todo[key])
}

console.log(getValues('id')); // [3, 2, 1]
console.log(getValues('content')); // ['HTML', 'CSS', 'Javascript']
console.log(getValues('completed')); // [false, true, false]
```



요소의 프로퍼티(id, content completed)를 문자열 인수로 전달하면 todos의 요소를 정렬하는 함수를 작성하라.

단, todos는 변경되지 않도록 하자

참고: Array.prototype.sort

```js
const todos = [
       {id: 3, content: 'HTML', completed: false},
    {id: 2, content: 'CSS', completed: true},
    {id: 1, content: 'Javascript', completed: false},
]

function sortBy(key) {

}
console.log(sortBy('id'));
/*
[
  { id: 1, content: 'Javascript', completed: false },
  { id: 2, content: 'CSS', completed: true },
  { id: 3, content: 'HTML', completed: false }
]
*/
console.log(sortBy('content'));
/*
[
  { id: 2, content: 'CSS', completed: true },
  { id: 3, content: 'HTML', completed: false },
  { id: 1, content: 'Javascript', completed: false }
]
*/
console.log(sortBy('completed'));
/*
[
  { id: 3, content: 'HTML', completed: false },
  { id: 1, content: 'Javascript', completed: false },
  { id: 2, content: 'CSS', completed: true }
]
*/
```

정렬메소드 소스는 뮤테이터다. 뭘 리턴하냐? 정렬된 배열을 리턴하다. 

원본배열을 재 리턴한다.

```js
const todos = [
  { id: 3, content: 'HTML', completed: false },
  { id: 2, content: 'CSS', completed: true },
  { id: 1, content: 'Javascript', completed: false }
];

function sortBy(key) {
return todos.slice().sort((a, b) => (a[key] > b[key] ? 1 : a[key] < b[key] ? 1 : 0) );
}

console.log(sortBy('id'));
/*
[
  { id: 1, content: 'Javascript', completed: false },
  { id: 2, content: 'CSS', completed: true },
  { id: 3, content: 'HTML', completed: false }
]
*/
console.log(sortBy('content'));
/*
[
  { id: 2, content: 'CSS', completed: true },
  { id: 3, content: 'HTML', completed: false },
  { id: 1, content: 'Javascript', completed: false }
]
*/
console.log(sortBy('completed'));
/*
[
  { id: 3, content: 'HTML', completed: false },
  { id: 1, content: 'Javascript', completed: false },
  { id: 2, content: 'CSS', completed: true }
]
*/
```



### 새로운 요소 추가 ( O )

새로운 요소( 예를 들어 { id: 4, content: 'Test', completed: false } )를 인수로 전달하면 todos의 선두에 새로운 요소를 추가하는 함수를 작성하라. 단, Array#push 는 사용하지 않도록 하자.

```js
let todos = [
  { id: 3, content: 'HTML', completed: false },
  { id: 2, content: 'CSS', completed: true },
  { id: 1, content: 'Javascript', completed: false }
];

function addTodo(newTodo) {
    todos = [newTodo].concat(todos);
}

addTodo({ id: 4, content: 'Test', completed: false });

console.log(todos);
/*
[
  { id: 4, content: 'Test', completed: false },
  { id: 3, content: 'HTML', completed: false },
  { id: 2, content: 'CSS', completed: true },
  { id: 1, content: 'Javascript', completed: false }
]
*/
```



### 특정 요소 삭제 ( O )

todos에서 삭제할 요소의 id를 인수로 전달하면 해당 요소를 삭제하는 함수를 작성하라.

```js
let todos = [
  { id: 3, content: 'HTML', completed: false },
  { id: 2, content: 'CSS', completed: true },
  { id: 1, content: 'Javascript', completed: false }
];

function removeTodo(id) {
   todos = todos.filter(todo => todo.id !== id);
}

removeTodo(2);

console.log(todos);
/*
[
  { id: 3, content: 'HTML', completed: false },
  { id: 1, content: 'Javascript', completed: false }
]
*/
```

### 8. completed 프로퍼티의 값이 true인 요소의 갯수 구하기 ( O )

todos에서 완료(completed: true)한 할일의 갯수를 구하는 함수를 작성하라.

단, for 문, Array#forEach는 사용하지 않도록 하자.

```js
let todos = [
  { id: 3, content: 'HTML', completed: false },
  { id: 2, content: 'CSS', completed: true },
  { id: 1, content: 'Javascript', completed: false }
];

function countCompletedTodos() {
  let odds = todos.filter(todo => todo.completed === true);
  return odds.length;
        
   
}

console.log(countCompletedTodos()); // 1
```



# id 프로퍼티의 값 중에서 최대값 구하기

todos의 id 프로퍼티의 값 중에서 최대값을 구하는 함수를 작성하라.

단, for 문, Array#forEach는 사용하지 않도록 하자.

```js
let todos = [
  { id: 3, content: 'HTML', completed: false },
  { id: 2, content: 'CSS', completed: true },
  { id: 1, content: 'Javascript', completed: false }
];

function getMaxId() {
const max = todos.reduce(acc, cur) => (acc > cur ? )
}

console.log(getMaxId()); // 3
```









