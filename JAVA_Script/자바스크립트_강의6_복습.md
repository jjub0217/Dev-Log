# 함수란?

함수 자체를 값이라고도 한다. 

함수를 왜 쓸까? 함수를 미리 정의해놓는다는 것은 여차하면 할일들을  미리 세팅한다는 것이다. 

그걸 개발자들이 호출이라는 형식을 빌려서 적절한 타이밍에 적절한 재료를 주입해서 함수를 여러번 실행할수 있을것이다.

그러면 함수를 안쓰면 어떤 일이 발생할까? 그러면 코드의 중복이 생길것이다.

중복이 발견되면 이걸 함수로 만들어야 하나? 라고 떠올려야 한다. 

코드를 고치는 일이 많을수록 실수할일이 많아지는데 , 중복되는 행위들을 함수로 만들었다. 그러면 

수정은 한번만 하면 된다. 어디에다가 수정하면 되지? 함수 를 수정하면 된다. 

함수에 이름이 있으면 어떤 장점이 있나? 값을 대변할수 있다. 잘 설명할수 있다. 코드블럭을 수정하면 된다. 

함수 이름을 한글로 되긴 한데, 영어로 한다. 왜냐면 일반적이지 않다. 

==> 함수를 통해 중복을 제거하고, 코드를 재사용 하려고 함수를 쓴다. 

그 함수 객체를 가리키는 식별자가 있어야 할까 없어야 할까? 있어야 한다. 없으면 어떤 문제가 생길까?

호출을 못한다. 뭘 호출을 할줄 알아야 호출을 한다. 따라서 식별자가 있어야 한다. 



함수정의는 코드블럭은 값을 만드는 표기법이다. 

함수를 만들고 싶으면 함수 리터럴을 만들면 된다. 함수정의는 함수를 만드니까 함수 리터럴이라고 한다. 

그럼 함수정의는 표현식인 문이어야 한다. 그런데 예시는 표현식이 아닌 문이 아니다. 이상하다?

함수 리터럴이라고 했는데? 함수 리터럴은 반드시 표현식인 문이어야 한다. 근데 형식은 함수리터럴이 맞긴한데, 콘솔 찍으면 언디파인드 찍힐것이다. 이상하다? 할당이 되긴 하는데...? 뭐지? 

표현식이 아닌 문이 아닌가? 표현식인 문인가? 왜 콘솔찍으면 언디파인드 나올까? 결론은 이 표현은 중의적 표현이다. 두가지 해석의 방법이 있다. -> { } : 중괄호 리터럴을 보면 자스엔진은 두가지 해석이 가능하다. 뭐냐면 블록문으로 해석이 가능하고 객체 리터럴로 해석이 가능하다. 둘중에 결정해야 한다.

어떨때 불록문으로, 어떨때 객체 리터럴로 해석하는데, 문맥을 봐야 한다. 값이 오는 문맥이냐 아니냐를 보는것이다. 이게 객체 리터럴이라고 가정하면 중괄호 내용은 값으로 평가되어져야 한다면 그건 코드블럭일수가 없다. 

중괄호 표현이 값으로 평가될수 있는 문맥에서 사용되면 객체 리터럴인것이다.

그런데, 이도 저도 아닌 문맥이다 블록문으로 해석한다. 



함수리터럴로 해석할수도 있고, 함수 선언문이라는 표현식이 아닌 문으로도 해석이 가능하다. 

쟤가 값으로 평가될수 잇는 문맥상에서 쓰여지면 함수 리터럴로 해석이 되면 이도저도 아니면 함수 선언문으로 해석된다.  단독으로 쓰여지면 함수 선언문으로 해석되는데, 그건 표현식이 아닌 문으로 해석된다. 



왜 이름을 함수 선언문이라고 지었을까?

함수 리터럴: 펑션 이라는 키워드가 반드시 오고, 두번째는 스페이스가 오고 함수의 이름이 올 자리다. 

함수 리터럴인 경우에는 함수이름을 생략할수 있다. 그 다음에는 괄호 열고 닫고 매개변수 목록이 올자리다. 0 개이상인 매개변수를 나열한다. 그 다음에는 코드블록이 오는데 그 코드블록을 함수몸체라고 한다. 



함수선언문일때는 함수 이름을 생략할수없다.  : 함수 선언문은 값으로 평가되지 않기때문에 함수 표현식이 아니다. 함수 정의 라는 거에 포함된다. 함수를 생성해야 한다. 표현방법만 다를뿐 함수를 생성해내야 한다. 자스 엔진이 함수 선언문을 읽으면 함수 객체를 생성해야 한다. 



근데 함수몸체 밖에는 함수이름 못쓰는데, 밖에서 쓰면 그걸 암묵적으로 해준다. 

함수 선언문이 아니게 하면 .... 

괄호 안에 펑션 add 가 있으면..... 왜냐면 함수선언문은... 이 상황에서 함수이름은 호출이 될까? 

똑같은 기명 함수 리터럴인데... 함수 선언문으로 해석될때도 있고 함수 리터럴로 해석될때도 있구나. 

어떨때만 함수 선언문으로 평가된다고? 단독으로 사용될때. (펑션 함수이름(매개변수)가 코드블럭 밖에 잇을때. )

var foo 와 펑션 foo  에서 두 foo 는 다른거다. 함수 선언문은 엄밀히 말하면 내부 동작이 다르다. 호이스팅이 다르다. -> 이때 첫번째줄은 변수 할당문으로 해석해야 한다. 



함수 호출은 반드시 함수 정의 밖에서 해야 한다. 

함수 호출과 참조를 헷갈리면 안된다.

콘솔로그(푸) // 펑션: 푸 

펑션 푸(x) {{콘솔로그( x) ;  };

위코드가 변수 호이스팅 되면 언디파인드가 나와야하는데. 안나오는거 보면 

함수 선언문은 암묵적으로 .... 선언하고 할당해주는것이다. 



함수 선언문은 암묵적으로 함수를 가리키는 식별자가 선언되고 함수 객체로 초기화된다. 

그래서 위코드는 밑에 함수정의를 써도 아무렇게나 자유롭게....



함수 리터럴이라는게 있다. ... 표기법인 함수 리터럴이 있는데 얘는 이름을 붙힐수도 안붙힐수도 있다.

근데 안붙히는 애를 무명 함수 리터럴이라고 하고, 그 반대는 기명 함수 리터럴이라고 한다.

기명일때는 두가지 해석방법이 있다. 

기명 함수 리터럴을 쓰면 함수 선언문이라는 표현식이 아닌 문으로 된다, ,

얘는 암묵적인 변환이 나타내는데, ./..... 할당까지 해준다. 언제? 런타임 이전에. 

기명이든 무명이든 걔네들이 값이 오는 문맥에서 쓰이면 함수 리터럴로 해석이 되서 함수 객체를 만들어준다.  .... 걔는 그 구문을 함수 표현식이라고 부른다. 이때 함수 표현식이라고 할때 함수 객체는 언제 만들어지느냐? 할당 하기 직전에 만들어진다. 

함수선언문을 함수.... 조금 어패가 있다는 것이다. 



파스칼 케이스(앞에가 대문자)로 되어있는 영어는 전부 생성자 함수 또는 클래스라고 한다. 얘네들은 객체를 생성용 함수다. (클래스도 함수다)



함수는 식별자로 호출하는 것이다. 자기 자식을 호출해야 할 필요가 있다고 하면(=재귀)... 무한루프가 된다. 그래서 반드시 탈출조건이 있어야 한다. 탈출조건을 잘못 만들면 에러가 난다. 재귀를 웬만해서는 안쓴다. 어떨때 쓴다? 포문이랑 똑같이 알고리즘에서 쓴다.

 

생성자 함수는 쓸일도 없을거고, 쓰면 안된다. 



화살표 함수는 우리가 나중에 집중적으로 공부할거야. 꽤나 중요해서. 왜냐면 얘는 일반 함수랑 여러 측면에서 다르다. 



함수 호출되면 ... 안에서 파고드는거다. 

실행순서가 바뀌는거는 .... 

비동기는 순서가 보장되지 않는다. 그래서 결국엔 순서의 의미가 없다. 



인수: 함수가 실행되기 위한 재료다(인풋이다)

매개변수는 함수 외부에서 할수 없다. 



```javascript
function add(x, y) {
  return x + y;
}

console.log(add(2)); // NaN
```

```javascript
function add(x, y) {
  if (typeof x !=== 'number' || typeof y !=== 'number) {
  throw new Error('number!');
  }
  return x + y;
}

console.log(add(2));
```

```javascript
function add(x, y) {
  if (typeof x !=== 'number' || typeof y !=== 'number) {
  throw new Error('number!');
  }
  return x + y;
}

try{
add(2);
} catch(e) {
    
}

위 트라이 캐치문은 에러가 존재한다. 트라이 캐치할수 없는 에러. 
비동기.... 그래서 프로미스가 나온다.(던진다, 받는다)
```





... 이럴땐 아예 매개변수를 선언안한다.

아규먼츠라는 프로퍼티: 함수 객체가 갖고잇는 프로퍼인데, 얘네한테 접근하려면 어케 해야해? 

코드 블럭 안에서 그냥 선언안했지만 보이는 것이다. 그런게 몇개 있는데 그런 애들은 함수 객체 만들때 

... 세팅 해주는 것이다. 



콘솔로그가 표준이 아니다. 표준이 없기때문에 알아서 만드는 것이다.  

프로퍼티 키는 문자열, 빈문자열이다. ... 내부적으로 문자열을 갖고 있다. 

 legth 가 있는 이유는... 포문..

0 : 2

1: 5

2: 10   -> 유사 배열 객체라고 한다. 

 : 2  에서 말하는 2 라는 값에 접근하려면 어케 해야 하나? 얘의 객체의 이름은 뭐였지?  이 객체를 만드는 생성자 함수가 있다는 것이다. 접근하려면 arguments[0] 이걸 코드블럭 안의 콘솔로그 괄호 안에서 해야 한다. 



.... 다 아규먼트를 갖고 있다. 단, 화살표 함수가 아닌 애들. 

인수 3개를 줬을때 다 합산하고 싶은데, 합산하고 리턴하고 싶다. 

```javascript
ex)
function add (a, b = 5, c = 10) { 
console.log(arguments);
 return = x + y
    }
    add (2, 5, 10);
```

```javascript
function add () { 
    var sum = 0; 
    for ( var i = 0; i <arguments.length; i++) {
	 sum += arguments[1]
	}
	 return sum;
}
	add (2, 5, 10);
console.log(add(2, 5, 10)); // 15
```

위 코드 같은 함수를 가변 인자 함수라고 한다. 파라미터가 가변적이다 라는 뜻이다. 인수를 꼭 3개 안줘도 된다.  가변 인자 함수를 떠올리면 아규먼트 객체를 떠올려야 하고, 유사 배열 객체를 떠올려야 하고, 렝스 프로퍼티가 떠올라야 한다. 렝스가 01234 이런 식으로 나열될것이다. 



매개변수는 몇개까지 지정할수 있을까? 몰라요. 몇백개는 충분히 가능하지만 그럴 사람이 있을까? 없어~~~ 매개변수가 많아진다고 가정하자. 7개 8개라고 하면 생각을 다시 해보자. 이 함수를 하나로 만든다는 생각을 하지말자. 그만큼 재료가 많다는 뜻이다. 그럼 그만큼 많은 일을 한다는 뜻이다. 그럼 걔는 하나의 함수가 아닐 가능성이 있다. 함수의 단위를 어케 정할지 결정해야 한다. 

함수는 하나의 일만 하는거다. 그래야 문이 이쁘게 나온다. 함수바디를 만들때 몇줄이 제일 좋을까?

한줄이 최고다. 그만큼 함수는 작게작게 만드는 것이 좋다. 특히 자스는 그렇다. 콜백이라는게 잇으니까. 

또하나의 팁은 이름 짓기가 애매하면 일단 생각을 다시 해보자. 함수의 단위를 다시 생각해보자. 이름이 잘 지어진다는 뜻은 함수가 하는 일이 명확해진다는 뜻이다. 



매개변수는 0개가 최고다. 0개 일때 함수 사용법이 제일 쉽기 때문이다. 함수를 쓰는 사람을 고려해줘야 한다. 함수의 매개변수가 4개면 인수도 순서대로 3개를 나열해줘야 한다. 10개면 10개를 순서대로 나열해줘야한다. 하나만 삐끗해주면 함수가 이상하게 도는거다. 인수가 많아지면 실수가 발생할 확률이 높아지는거고 사용하기에도 어려워진다. 매개변수는 3개를 넘지 않도록 노력하자. 

3개가 넘으면 이걸 객체로 주면 어떨까 라는 생각을 하면 된다. 객체는 복합적인 자료구조이기 때문에 100개가 되고 하나의 값으로 줄수 잇다. 프로퍼티의 순서에 의미가 객체일 경우에는 상관이 없다.



제이쿼리가 나쁜걸까? 안쓸까? 아주 간단한 웹사이트 만들때는 제이쿼리 쓴다. 근데 복잡한 애플리케이션 쓸때는 프레임워크 쓰는게 낫다. 



# 반환문

리턴을 생략할수도 있다. 

리턴을 안써주면 리턴 언디파인드가 있는것과 똑같다. 명시적으로 리턴을 안하는 경우가 많다. 

반환문의 역할은 2개있다. 

첫번째는 함수를 종료한다. 함수의 최종목적이 뭐다? 아웃풋을 만들어서 반환하는거다. 그러면 역할을 다 했기 때문에 함수를 끝내줘야 한다. 그래서 리턴문은 함수 마지막에 만들어줘야 한다. 

두번째는 반환값을 반환하는 것이다. 

리턴만 쓸수 있는데 리턴만 쓰면 언디파인드가 있는것고 ㅏ똑같다. 

리턴문 생략하면 함수 가장 밑에 리턴이 있다는 것과 똑같다. 

반환값이 존재안하는 함수는 없다.



리턴문은 맥락상 함수 내부에서만 써야 하잖아, 근데 이프 문 에 쓰면 에러다. 





## 참조에 의한 전달과 외부 상태의 변경

```javascript

function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
}

// 외부 상태
var num = 100;
//var person = { name: 'Lee' };//

// 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.
changeVal(num, { name: 'Lee' });

```

```javascript
function foo(x) {
x = x + 1;
}
var x = 1;
foo(a);
```

```javascript
비순서 함수
function foo(x) {
x = x + a;
}
var x = 1;
var a - 10;
foo(a);   -> foo 함수는 .... x  값에 의존하고 있는 것이다. x 값이 바뀌면 함수의 리턴값도 바뀐다. 동일한 인수값을 전달해도 ....
console.log(x);  //  11
```

순서함수는 수학적함수다. 

수학점 함수는...

프로그래밍은 외부값에 의존하게 되면 외부값이 바뀌면 리턴값이 바뀐다. 

외부에 있는 값을 직접 고쳐가는 애들도 비순서 함수라고 한다. 

그래서 함수형 프로그래밍 언어라고 있는데 거기서 순수함수를 지향 한다. 백퍼센트는 아니더라도 가급적 순수함수를 만들어야 겟다. 가 함수형 프로그래밍인다. 



 

## 다양한 함수의 형태

### 즉시 실행 함수

함수긴 함수인데 즉시 실행한다. 정의 되자 마자 즉시 실행된다는 뜻이다. 

```javascript
// 익명 즉시 실행 함수
(function () {   -> 여기서 ( ) 이게 이름이 잇다고 하면 두가지 해석이 잇다. 
코드블록 안에 값이 와야 한다. 코드 블록 안은 함수 리터럴이다. 
  var a = 3;
  var b = 5;
  return a * b;
}());-> ( ) 이건 호출 연산자다. 
```



var 키워드인 경우에 중복을 허용한다.

```javascript
ex)
var x =1;
var x = 10;
```

```
(function () {
  // ...
}()); -> 이렇게 써도 된다.

(function () {
  // ...
})();   -> 이렇게 써도 된다. 이게 좋을거 같다. 

!function () {
  // ...
}();

+function () {
  // ...
}();
```



## 재귀 함수

재귀 함수: 함수 바디에서 함수 몸체에서 자기를 호출하는 문이 있으면 그걸 재귀함수라고 한다.

탈출을 안하면 무한반복 하게 된다. 



## 중첩 함수 (중요하다)

콜백 함수와 친척이다.

함수가 중첩됬다는 뜻. 함수 안에 함수를 선언하였다는 뜻이다. 

```javascript
function outer() {
  var x = 1;

  // 중첩 함수
  function inner() {
    var y = 2;
    // 외부 함수의 변수를 참조할 수 있다.
    console.log(x + y); // 3
  }

  inner();
}

outer();
```

컴퓨터 함수에서는 중첩이라는 뜻은 '부자' 관계라고 한다. (= '부모'관계)

의미론적 부자관계라고 하는데, .... 스코프가 연결되는데, .... 자식같은 개념이다. 

외부 함수의 헬퍼 역할을 한다. 외부 함수가 뭘 할건데, 중첩함수가 도와준다. 일의 일부를 중첩함수가 한다. 

그런데 클로저랑 밀접한 관계가 있다. 



## 콜백 함수

반복을 하는 함수 

포문을 내포하고 있는 함수를 만든다. 

인수로 숫자를 주면 그 숫자만큼 반복한다. 안에서 포문이 그 만큼 반복한다. 

근데 이 함수에는 문제가 잇다. 왜 반복을 하지? 반복을 하면서 뭔가를 해야 하잖아. 콘솔로그가 반복하면서 하는일이다. 포() 랑 콘솔로그 부분이 반복한다. 리핏()은 조절할수 잇는데 포()콘솔로그 는 조절할수 없다. 

횟수를 인주로 준것처럼 반복 하는 일이 바뀔수 잇잖아. 

 리핏 계열 함수 : 반복한다, 반복하면서 뭔가 한다. 반복한다는 것은 정해진것이다. 안 바뀜. 반복하면서 하는 일만 바뀜 반복하면서 하는 일만 외부에서 전달해주면 여러가지 일을 하나의 함수로 할수 있다.

함수가 할 일이다. 함수는 동사잖아. 

골백함수는 사용빈도가 많다.



예습 : 13. 14, 15 예습





























