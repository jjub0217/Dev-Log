# 순수 함수와 비순수 함수

콘솔로그 : 예측을 못한다.

![image-20200501141439323](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501141439323.png) 

밖에 있는 2를 전달받앗어. 예측하기가 쉽다. 예외가 없으니까

그런데, 얘는

![image-20200501141620788](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501141620788.png) 

위 코드에서 카운트는 전역변수다. 





함수라는 것은 함수 내부에 있는 값만 컨트롤 할수 있는게 아니고 외부에 있는 값도 컨트롤 할수 있다.

뭐 덕분에? 스코프 덕분에.

만약에 스코프라는 게 없다면....

무조건 다 순수함수가 될 가능성이 높다. 그렇게 되면 상태관리하기가 어렵다. 



---



# 스코프란?

스코프: 유효범위

영어로 스코프는 무슨뜻이냐? 망원경으로 볼때 시야. 스코프라는게 어떤 개념이냐

함수의 중첩에 의해서 체인이 된다. 만약에 자신의 스코프에서 무언가를 찾아. 무언가가 없으면 위에꺼를... 자신의 스코프에도 식별자가 있고 상위 스코프에도 식졀자가 있으면 자신의 식별자부터 보고 위에 있는 식별자는 못본다. 그래서 시야를 가린다. 가려진다. 라고도 얘기한다. 



스코프 하면 식별자와 관련이 있다고 생각하자. 스코프 안에 식별자가 있다. 그리고 함수하고도 관련이 있다. 함수 이름은 원래 함수 내부에서만 유효하다 라는 표현이 있다. 함수 내부의 스코프는 함수 내부이다. 그리고 또하나 우리가 함수를 만들었을때... 

funtion foo(x,y) {

}

log(x)

---> 위의 x, y 는 중괄호 안에서 하는거다. 코드블럭 밖에 있다고 생각하면 안된다. 이건 이 안으로 주입되는 인터페이스이기 때문에 안에 있는걸로 생각해야 한다. 얘네들은 함수 내부가 유효범위다. 

```javascript
var x = 0;

function foo{
var x = 1;
}
```

두개의 x 는 중복이냐? 중복이 아니다. 왜 아니냐. 스코프가 다르다. 스코프가 다르면 이름이 중복되지 않는다고 얘기한다. 그럼 중복의 기준은 논리적으로 따져봣을 때 스코프가 기준이 된다.

그럼 스코프가 뭐냐? 

펑션{ }  : 지역 (함수 내부는 다 지역이다.) 지역은 함수가 만든다. 

var x = 0 ; : 전역 (전역에 위치해서 전역변수)

변수는 자신의 위치에 .... 유효범위가 결정된다. 자신이 선언된 위치에  따라서

```javascript
var x = 0;

function foo{
var x = 1;
}
function bar {
var x = 1;
}
-----------
    두개의 펑션{} 은 다른 지역이다.
```

var 키워드로 선언한 변수는 함수 내부의 지역으로만 인정한다. 

그 외의 키워드로 선언한 변수는 코드블록도 스코프로 인정한다. 

그러면 이프문에 있는 코드블록 있잖아요, 

```javascript
var x = 0;

function foo{
var x = 1;
}
function bar {
var x = 1;
}

if (true) {
var x = 10;    -> 전역변수(함수가 없다. )
}

for (var x = 0; x <1; x++) { }
```

다른언어에서는  바 키워드로 선언한 변수는 ... 지역변수로 인정하기때문에...

```javascript
var x = 0;

function foo{
var x = 1;
    function bar {
var x = 1;
}
}
```

위 코드는 중접함수이다. 

스코프들은 서로 연관관계가 있다. 이걸 스코프체인이라고 한다. 연쇄가 되있다는 말인데, 이건 위아래가 있다는 말이다. 가장 위가 누구? var x = 0; 

전역에 가장 위에 있는것이다. 



변수선언이 뭐라고? 

var x ;

변수선언이란? 식별자의 존재를 자스엔지에 알리는것이다. 나 이제 엑스라는 이름이 있어., 라고 자스엔진에게 알리는것이다. 안 알리면 여기서 콘솔로그 엑스햇을때 안알렸으니까 모르지. 모르니까 어케되? 참조를 못한다. 그럼 알린다는 말은 자스엔지 앞으로 아! 앞으로 엑스라른 식별자라는것이 있다. 라고 알고 있다. 



```javascript
var x = 0;

function foo{
var x = 1;

    function bar {
	var x = 2;
	console.log(x);
}
bar();
}
foo{};
```

알린다는 말을 다른말로 하면 등록한다. 라고도 한다. 식별자도 태어나면 등록을 해야 한다.

자료구조.... 실행컨텍스트라고 한다. 식별자를 실행컨텍스트에 등록이 된다. 실행컨텍스트 는 자료구조라고 생각하면 된다. 

스코프를 구분해서 등록하게 된다. 

어디 출생이냐에 따라서 스코프를 구분해서 등록이 된다. 스코프가 구분되어져잇다. 모든 스코프가 일직선으로 연결되어있다. 찾아서 없으면 위로 가고 거기서도 없으면 위로 가고 한다.

변수가 선언이 되면 등록이 되어진다. 등록이 되어지기 때문에 우리가 찾을수 있다. 

우리는 스코프에서 찾을수 있다. 전역, 푸, 바 에 스코프가 있다. 

![image-20200501144500577](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501144500577.png) 



변수만 스코프가 있을까? 함수에는 없을까?

![image-20200501150040703](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501150040703.png) 

전역변수는 어디서 참조가 가능한가? 다 참조 가능하다. 전역변수는 어디서 호출가능할까? 어디서나 다 호출가능하다. 함수선언문이니까 식별자 만들수 있다. 위 코드에서는 푸가 그 식별자이다. 

식별자는 어디에 등록될까? 전역 스코프에 등록된다. 

위에서부터 실행한 선언문은 두개이다. 펑션 {} 이건 런타임 이전에 실행되고 ....

펑션 { }안에 있는 내용은... 현시점에는 안합니다. 함수객체만 만들고 끝.  선언문 두개 끝.

맨처음 x 를 찾는다. ... 확인한다. 만약에 선언이 된 변수가 아니라면 할당을 못한다. 그래서 먼저 찾는다.

어디서? 전역 스코프에서 찾는다. 

두개의 선언문을 먼저 한다. 먼저 전역변수 x 를 등록해야 하잔항. 전역 스코프에 등록해야 해. 

그럼 이 시점엔 전역 스코프의 실체가 있어야 한다. 그 실체를 만든다. 

 

함수는 정의된 위치가 중요하다. 위 코드는 전역에 정의 되었기 때문에 전역스코프가 상위 스코프다. 

스코프 : 자스엔진이 식별자를 찾는 규칙이 바로 스코프다. 

스코프라는 규칙 : 식별자를 찾으러 다닌다. 

사실은  자스엔진은 객체지향이라서 프로퍼티를 찾는데, 스코프 체인이라는 자료구조에서 별도로 찾는다.  자스엔진 모든 코드는 뭘 찾는다고 하면 식별자는 스코프에서 프로퍼티는 프로퍼티 체인에서 찾는다 

이것들이 협력하면서....

식별자 이름이 갖다고 해도 스코프가 분리되어있기 때문에 다른 애다. 

모든 식별자는 프로퍼티 키로 생각하면 된다. 

정확히 얘기하면 식별자는 스코프 내에서 중복되면 안된다. 그러면 스코프를 왜 만들었을까?

스코프가 없으면 어케 되? 프로그램을 만들때 한번 변수 이름만들면 두번다시 못쓴다. 이름짓기가 아주...

큰 애플리케이션 만들때 식별자 몇개일까? 몇천개이다. 그걸 다 유니크하게 지어야 하는데 가능할까? 굉장히 어려울것이다. 그렇게 되면 변수에 의미를 주지 못하고 일련번호로 주게 될것이다.



스코프가 있기때문에 유의미한 이름을 지을수 잇다. 

식별자는 폴더 안에 들어가있다고 생각하면 쉬울것이다. 



## 렉시컬 스코프

그 유명한 클로저랑 연결이 된다.

![image-20200501152802524](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501152802524.png) 

대부분 렉시컬 스코프이다. 

어디서 호출되엇는지 별로 안중요하지만

변수의 스코프는 어디서 선언됬느냐, 함수도 어디서 정의 되었느냐가 중요하다

위 코드에서 푸는...

바는... 전역에서 정의 되었다. 그래서 상위 스코프는 전역이다. 

그래서 위 코드 정답은 1 1 이다.



함수는 객체라서 프로퍼티가 있다. ... 감춰진... 이게 바로 클로저다. 



# 전역변수의 문제점

전역변수를 안쓰려면 클로저... 허다하다.

전역변수는 일단 가장 큰 문제점이 뭐냐면 생명주기가 길다. 

변수는 생명주기가 있는데 태어나면 죽는다. 등록이 되어지는걸 태어난다고 한다. 태어나서 언제 죽을까

가비지 컬렉터에 의해서 해방되는걸 죽는다고 한다. 

![image-20200501154312776](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501154312776.png) 

함수가 호출되면 태어났다. 

함수 호출 되기전에 x 는 안태어난다. 호출을 해야 지역변수가 생기다. 

리턴하면 함수가 종료된다. 코드블럭 안에 있는것들이 이때 별볼일 없게 된다. 이때 렉시컬 환경이 해방되어진다. 함수가 호출되면 지역변수가 태어나고 함수가 종료되면 지역변수가 죽는다. 

저 함수가 호출되고 종료될때까지 얼마나 걸릴까? 모르지만 0.001초나 걸릴까말까 하는데 금새 태어낫다가 금새 죽는다. 메모리 공간을 확보하고 다른 애들이 못쓰게 킵한다. 로컬이 6개글자니까 최소 12바티으 공간을 확보하고 다른애들이 못쓰게 한다. 다 쓰면 더이상 이 객체를 아무도 안본다. 가비지 컬렉터에 의해서 해방된다. 함수가 종료되면 해제된다. 죽는다고 생각하자.



따라서 지역변수는 금새 죽는다. 함수를 작게 만들수록 더 빨리 죽는다. 아무리 많은 변수를 만들어도 눈깜짝할 사이에 해방된다. 

근데 전역변수는 어떨까? 전역변수는 언제 태어나고 언제 죽을까? 바 키워드로 선언한 전역변수는..

```javascript
var x = 1;
x  // 1
window.x //1
```

바 키워드로 선언한 엑스라는 전역변수는 언제 죽을까? 윈도우가 살아있으면 안죽는다. 

그럼 윈도우가 언제 죽을까? 윈도우는 창을 닫지 않으면 안죽는다. 

그니까 지역을 써야 한다. 



그래서 우리는 함수를 만들때 함수는 어케 만들어야 한다? 작게 만들어야한다. 왜 작게 만들어야 하나?

스코프를... 하려고. 

하나의 일만 간단하게 짧게 해라 가 기본이다. 

함수만들때 예를 들어서 몇백줄만드는건 심각한거다. 

함수 선언은 스코프 기준으로 올라간다. 스코프 단위로 올라간다. 



전역변수의 문제점은 너무 오래 살아남는다. 

전역변수는 어디서 참조할수 있다? 어디서라고 말하지 말고 어느 코드가 참조할수 잇다? 모든 코드가 참조할수 있으므로 모든 코드가 고칠수 있다. 고칠수 잇으니 변경이 될 확률이 높아지므로 추적이 어려워진다. 



지역변수는 지역에서만 참조할수 있어서, 지역변수는 고칠수 있는 찬스도 적고 변경 될 가능성도 적다.

그래서 지역변수가 전역변수보다 안전하다. 



네임 스페이스가 오염된다. 이름들이 기억되어지는 공간을 네임 스페이스라고 한다. 

이름이 중복될 가능성이 크다. .... 메인 스페이스를 공유한다. 따라서 전역은 안쓰는게 좋다.



## 전역 변수 사용 억제 방법

1. 즉시 실행 함수로 막는다.
2. 네임 스페이스 객체 (좀 올드한 얘기) : 전역변수를 하나만 만든다. 전역변수로 쓰고 싶은 애들은 이 객체의 프로퍼티로 등록한다. <- 이거 하지마세요
3. 모듈 패턴 <- 이건 클로저를 알아야 한다.
4. 모듈





# let, const 와 블록 레벨 스코프



1. 변수 중복 선언 허용

2. 함수 레벨 스코프 :블록 레벨을 지원하지 않는다

    바 키워드로 선언.... 다 전역변수다. 

3.  변수 호이스팅이 발생한다

   선언하고 씁시다.



## let 키워드

변수 중복 선언하면 에러난다. 같은 이름으로 선언하면 에러난다.

렛과 컨스트는 블록 레벨을 지원한다. 이때는 지역변수다. 포문에 변수선언문을 렛으로 선언하면 어디를 지역으로 보나? 포문의 ..... 

![image-20200501162854593](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501162854593.png) 

두 푸는 다른 애다.

그렇다면 호이스팅은 어떨까? 결론적으로는 호이스팅이 발생하긴 하지만 발생 안하는것처럼 동작한다.

![image-20200501162934331](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501162934331.png) 

여기서 바 하면 언디파인드다. 할당이 안되있으니까. = 1 해도 언디파인드다. 

그러면 렛은? 레퍼런스 에러난다. 위 코드만 보면 호이스팅 안일어나네~  할수 있지만 호이스팅 일어나지만 안일어나는것처럼 보인다. 

![image-20200501163035356](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501163035356.png) 

만약에 위 코드에서 호이스팅이 안일어나면 푸는 1이 나와야 한다. 런타임 이전에 변수가 선언되어져야 하는데...  초기화 하기 전까지는 푸에 억세스 못한다. 이게 바로 호이스팅 한다는 거다. 

템퍼러리 데드존 : 일시적 사각지대

언디파인드가 절대 안나온다. 참조 자체가 안된다. 그러면 위코드의 두번째 푸는 초기화가 어케 될꺼 같아? 일단 푸가 등록이 되긴 한다. 특별한 조치를 취한거 같아. 뭐냐면 접근했을때 에러를 발생시킨다고. 그러면 값은 뭘까? 값은 모른다. 그 값으로 평가되면 에러를 발생시킨다고 되어잇다.

모든 식별자를 만드는 .... 전부 호이스팅을 하는데 언디파인드로 초기화되는건 바 키워드가 유일.

함수 선언문은 먼저 식별자가 만들어지고 .... 

렛 컨스트로 선언한 변수는 스코프에 변수가 해당되어지는 스코프에 가장 선두부터 선언문에 도달할때까지 일시적 사각지대에 빠져서 참조할수 없다.



## 전역 객체와 let

브라우저 환경에서는 프론트엔드는 윈도우, 셀프 여러가지 이름이 있지만 우리는 윈도우라고 하면 된다.

글로벌 디스라고도 한다. 

예를 들어서 윈도우 창을 들여다보자. 어떻게 생긴애인지. 



# const 키워드

컨스트는 컨스턴트의 줄임말이다.

컨스턴트는 상수에 대해서만 쓰여야 할거 같은 느낌이다.

상수는? 수학의 상수는 변하지 않는 수. 한번 고정되면 고정된 값에서 변하지 않는 수.

자스에서 상수는 조금 다르다.

재할당을 선언과 동시에 이루어져야한다.

변수에 컨스트가 붙으면 재할당이 금지된 변수다 라는 뜻이다. 그이상 그이하의 뜻이 없다.

즉 객체를 할당했을때 객체를  고칠수 있다. 원시값일때는 못바꾼다. 그러면 우리가 컨스트로 원시값을 할당하면 재할당이 안되잖아? 그때 상수라고 할수 있다. 왜냐면 절대 못바꾸니까. 그때 컨스트를 렛으로 바꾸면 재할당 할수 있다. 



만약에 바 키워드 쓸거면 싹다 바 쓰자. 바도 쓰고 컨스트도 쓰고 하면 안된다. 

---

배열은 렝스 프로퍼티가 있고 객체는 렝스 프로퍼티가 없다. 

아규먼트는 왜 렝스가 잇었지? 걔네는 특별히 유사배열 프로퍼티라서 잇는 것이다. 

```
const arr = [];
const arr = [1]; // 렝스는 요소릐 길이를 나타내기때문에 1 . 순서는 0번이다. 
-----------------
const arr = [1, 2, 3];  
console.log(arr.length);   // 렝스 3 나온다.
-------------------------

for (let i =0; i< arr.length; i++){     // 0 1 2 해서 3번 돌것이다.
console.log(arr[i]);
}
```



---

 선형검색 

선형 : [1, 2, 3] -> 1차원 배열

여기서 2 가 있냐, 있으면 2의 인덱스를 출력. // 1 



```javascript
function linearSearch(array, target) {

}

console.log(linearSearch([1, 2, 3, 4, 5, 6], 1)); // 0
console.log(linearSearch([1, 2, 3, 4, 5, 6], 3)); // 2
console.log(linearSearch([1, 2, 3, 4, 5, 6], 5)); // 4
console.log(linearSearch([1, 2, 3, 4, 5, 6], 6)); // 5
console.log(linearSearch([1, 2, 3, 4, 5, 6], -1)); // -1
console.log(linearSearch([1, 2, 3, 4, 5, 6], 0)); // -1
console.log(linearSearch([1, 2, 3, 4, 5, 6], 7)); // -1
----------------------------------------------------------
array 가 현재 6개 짜리라서 6으로 주면 안된다. 어레이.렝스 줘야 한다. 
순회하면서 target 랑 같은지 봐야한다
인덱스를 나타내는게 i 다.
포문을 돌면서 싹다 찾았는데 못찾았어. 그럼 어케 하지? = 포문을 통과 못햇다.
리턴은 함수내부에서 단 한번만 해야 한다.
우리가 let 뭘 리턴해야 하는거지? 인덱스를 리턴해야 한다.
껄쩍지근한건 렝스다. i < 어레이.렝스 <- 여기서(i) 여기까지가(렝스) 몇번 돌거같냐? 

function linearSearch(array, target)
let index -1;
const length = array.length;

for (let i = 0; i < array.length; i++) {
    if (array(i) === target) index = i;
}
    return index;
```

==>  이거 문제 풀기





예습 :  16, 17



