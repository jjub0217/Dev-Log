# 원시값과 객체의 비교

<p style="color:red";> 들어가기에 앞서...</p>

1. 원시값을 가지고 있는 변수를 다른 변수에 할당 (값에 의한 전달: pass by value)

   ```javascript
   var score = 80;
   var copy = score;
   console.log(score, copy);
   ```

   ==>  메모리 공간에 원본의 실제 값이 복사되어서 전달되어 저장된다.

2. 객체를 할당한 변수를 다른 변수에 할당 (참조에 의한 전달: pass by reference)

   ```javascript
   vaar person = {
   	name: "Lee"
   };
   var copy = person;
   console.log(copy === person);
   ```

   ===>  메모리공간에 참조값이 복사되어서 전달되어진다. 

---

## 원시값

원시값은 변경이 불가능한 값이라고 누차 얘기해오고 있다.<br>즉, 이미 생성된 원시값은 read only('읽기전용')한 값으로, 변경이 불가능하는 의미다. <br>여기서 말하는 변경이 불가능한 "값"이란 것은 변수가 아니라 "값"에 대한 얘기이다.

즉, 원시 값 자체를 변경 할수 없다는 것이지, 변수 값을 변경할수 없다는 것이 아니다. (변경이 가능하다는 얘기이다.(변수는 값이 아니다) *<- 뭘 이렇게 꽈서 설명해놓은거지...*)  

> **상수**
>
> 변수의 상대 개념이다. 
>
> 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할수 있지만, 할당이 단 한번만 허용되므로 변수와는 조금 다른 개념이다. 
>
> 따라서 상수와 변경 불가능한 값을 동일시 하는 것은 곤란하다.
>
> 상수는 재할당이 금지된 변수일뿐인다. 

- 원시값은 주소가 바뀌지 않는 상황하에서는 값을 못 바꾼다. 반드시 재할당을 해야 바꿀수 있다.

```javascript
ex 1) 

var o ={};
o.a =1; 
----------------------------------
프로퍼티 동적 생성한 상황이다. 
중괄호 외부에서 새로운 프로퍼티 a 라는 프로퍼티 키를 생성한 상태이며, 
새로운 프로퍼티 키 a 에 1 이란 프로퍼티 값을 할당한 상태이다. 
즉, 객체 안에 a 라는 프로퍼티 키와 1 이라는 프로퍼티 값을 생성한 상태이다.
==> o 라는 변수의 값을 변경한것이다.
-----------------------------------
o ={ } ==> 이건 재할당이다. 재할당을 하면 여기다 또 객체 만들고, 주소값이 바뀐다. 

ex 2)
var str = 'string';
str[0] = 'e';
console.log(str);
--------------------
==> 값이 도출되지 않는다. 왜냐? 문자열은 변경 불가능한 원시값이기 때문이다.
```

### 값에 의한 전달

![캡쳐89](https://user-images.githubusercontent.com/62126380/80914647-d1e88780-8d87-11ea-9a5d-7bb067b867b3.PNG) ![캡쳐90](https://user-images.githubusercontent.com/62126380/80914698-43283a80-8d88-11ea-9114-450a0937ab31.PNG)   

① undefined 가 들어갈 만큼 메모리 확보 후 그 메모리 공간을 score가 가리킨다. <br>// score 가 메모리공간의 주소를 알고 있어야 한다.<br><u>식별자로 알수 있는 것은 (결국은 값을 알수 있는것이지만) 식별자가 진짜로 갖고 있는 것은 메모리 주소라는 것을 알수 있다.</u>

②undefined 가 들어갈 만큼 메모리를 확보 후 그 메모리 공간은 copy 가 가리킨다.<br>// copy 가 메모리공간의 주소를 알고 있어야 한다.<br><u>식별자로 알수 있는 것은 (결국은 값을 알수 있는것이지만) 식별자가 진짜로 갖고 있는 것은 메모리 주소라는 것을 알수 있다.</u>

③ 할당이 이루어져서(사실을 재할당이라고 해야 한다), 새로운 메모리 공간을 만들어서 해당 공간에 80이란 값을 저장하고 score는 80이란 값을 가리키게 했다.<br>할당 연산자에 의해서 기존에 score가 기억하고 있는 메모리 주소가 바뀌었다.<br>undefined로 채웠던 메모리 공간을 바꾼게 아닌 이유는, undefined 값은 변경 불가능한 값이기때문이다.

 ④ (분홍색) copy에 score을 재할당했다.<br>copy에 원시값을 갖는 변수 score을 할당함으로 copy에는 **<u>score의 값이 복사되어 전달되어 저장</u>**되어진다. 

==> <u>copy의 주소값을 쫓아가면 score의 값 자체가 나온다.</u>



## 객체

**<u>객체는 변경 가능한 값</u>**이라고 누차 얘기해오고 있다.<br>그래서 객체는 재할당 없이도 값 자체를 바꿀수 있다.

결론적으로, 객체는 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조값에 접근할수 있다. <br>참조값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체이다.

- 객체를 여러 프로퍼티가 공유해서 쓰기 위해 객체의 자료구조를 이렇게 설계한것이다. 
- 요즘 트렌드는 객체도 원시값처럼 쓰려는 경향이 있다. <br>기존 객체를 카피해서 새롭게 만드는 것이다. <br>- 카피하는 방법 
  - 딥카피 : 객체가 여러개 있을 경우, 중첩된 객체들까지 싹 다 카피하는 하는 것이다.<br> 이걸 하려면 굉장히 퍼포먼스가 필요한 행위다.
  - 쉘로우 카피: 딥카피의 반대말이다.(얕은 복사: 1단계만 만든다)<br>                      객체를 하나만 만들고 중첩된거는 그냥  참조값에 넣는다. 

### 참조에 의한 전달

![캡쳐91](https://user-images.githubusercontent.com/62126380/80915227-f21a4580-8d8b-11ea-9ad6-93c617ba5944.PNG)  ![캡쳐92](https://user-images.githubusercontent.com/62126380/80915342-b92ea080-8d8c-11ea-8bc7-5d747c33de02.PNG)      

① 빈 객체가 먼저 생성된다.

② 객체가 생성된다.

③ person 이란 변수가 가리키는 메모리 공간에, 이미 생성된 객체가 저장된 메모리 공간의 주소가 저장된다.

④ 할당 연산자(=)에 의해서 copy가 가리키는 메모리 공간에 person이 가리키는 메모리 공간에 저장된 **<u>객체의 메모리 주소가 전달되어 복사되어 저장된다.</u>**

 ==> 결국 주소값이 전달된다. 그래서 주소값을 쫒아가면 참조값이 나온다.

-------

## 퀴즈퀴즈

```javascript
var person1 = {
  name: 'Lee'
};

var person2 = {
  name: 'Lee'
};

console.log(person1 === person2); // ① false
console.log(person1.name === person2.name); // ② true
```

==> ① false : 컴퓨터는 객체와 객체를 비교할때는 메모리 주소를 비교한다. 

​						-> person1 과 person2 의 메모리주소는 다르기 때문에 false

​		② true : 객체의 값을 물어본거기때문에 함수의 결과값이 'Lee' 가 같기 때문에 ture