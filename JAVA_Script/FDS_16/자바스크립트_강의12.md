소스코드: 텍스트파일을 만들건데, 만드는 도중에 실행이 되? 실행을 시켜야 실행될거잖아. 어케 하면 실행되냐? 우리가 만든 텍스트파일을 어케 하면 실행이 되나?

자스파일을 ... 어트리뷰트에 패스를 지정해준다. 그러면 에치티멩리이 실행되는 도중ㅇ....마자 실행이 된다.

우리가 만든 텍스트파일은 순수한 텍스트파일일뿐이다. 그건 저절로 실행이 된다고 생각하면 초짜이다.

실행시켜주는 다른 프로그램이 있는데 걔네들을 그게 바로 자스엔진이라고 한다. 

그래서 여기서 말하는 소스코드는 코드로 한줄한줄 타이핑한 소스이다. 실행하기 이전의 텍스트파일을 말한다.

그런데 여기의 소스코드의 종류가 있다.

그 종류를 나누는 기준이 있을텐데, 그 기준이 뭘까? 어떠한 실행컨텍스트를 만드느냐에 따라서 종류를 나눈다.

전역코드, 함수코드, 이벨코드, 모듈코드 이렇게 4가지 기준으로 나눌수 있다. 

근데 대부분의 코드는 전역코드 또는 함수코드다. 나머지 두개는 아주 특수한거다.

남은 두개까지 얘기하면 힘들거다. 우리가 많이 다루게 될 전역코드랑 함수코드만 살펴볼것이다.

---

전역코드: 전역이란? 코드를 쓸때 코드의 가장 탑레벨을 전역이라고 한다. 

```js
const a = 1;
```

함수코드: 

```js
function foo(){
  ... <-  얘네가 함수코드다
}
-------------------------
function foo(){
	//
    function bar(){
    // 
 }
}
```

소스코드의 타입을 구분하는 이유는 : 실행컨텍스트가 만들어진다. 이 코드가 평가되면 실행컨텍스트가 생성된다. 

그러니까 구분해놓은거다.

즉 실행컨텍스트가 만들어지는 기준으로 4가지를 구분해놓은거다.

그러면 저 4가지말고 다른 코드가 있다면 걔네는 뭘까? 포문 코드, 이프문 코드라는건 없잖아. 걔넨 실행컨텍스트를 안만들기때문에 없다. 걔네는 렉시컬 환경만 만든다.



전역코드: 전역변수를 관리할수 있어야 함. 그리고 뭘 만들어야? 전역 스코프를 만들어야 함.전역 스코프라는 애는 누가 만드냐? 전역 코드가 만든다. 그러면 전역에 우리가 선언한 식별자는 걔넨 어디에 등록되어져서 관리되나? 전역 스코프에 만들어져서 관리되어져야 한다. 

예를 들어서 전역에 c 라는 변수를 만들었다. 재할당하면 값이 바뀐다. 그걸 추적해야 한다. 현재 값을 알아야 한다. 그걸 관리 하는 애가 전역 스코프라는 애다. 그럼 전역 스코프라는 애가 자료구조로 실체가 있어야 한다. 

우리는 전역 스코프라고 불렀던것을 이걸 전역 실행 컨텍스트의 렉시컬 환경의 선언적 환경 레코드다. 

```js
let x = 1;
var x = 1;
-------------
이거 에러난다.
```

위코드의 let 의 변수 x 를 찾을때 console.log(x); ... 위치한...

이 코드가 실행될 당시에... 찾는다.

전역코드가 할일은 전역 함수를 관리해야 한다. 전역객체와도 연결이 되어야 한다. 

바로 선언한 변수랑 ... 전역객체의 메소드와 프로퍼티가 되기 때문에 따로 띄어서 설명할수 없다.

함수코드: 함수 스코프를 만들어야 한다. 지역변수가 등록되어져야 한다. 매개변수도 등록되어져야 한다. 

매개변수는 함수내부에서 선언한 거랑 똑같은거다. 다만, 바가 붙은거로 생각해야 한다.

함수가 붙은 매개변수는 아규먼츠가 보여야 한다. 그래서 아규먼츠로 식별자로 존재한다.



모든 소스코드는 평가과정을 거친다.

두단계에 걸쳐 실행된다. 

그 식별자가 등로되어져야 한다. 실행컨텍스트에 등록되어져야 한다.

그러면 평가단계에서 ... 만들어야 되? 만들어야 한다. 그릇을 만들어야 등록을 한다.

그러니까 평가단계에서는 소스코드를 평가하면 실행컨텍스트라는게 만들어진다.

우리는 전역코드랑 함수코드만 신경쓰자. 전역코드는 로드되자마자 평가된다.

전역코드는 특이한 애다. 함수 안에 있는 것들을 호출되야 실행되는데 전역코드는 진입점이 없는게 특이점이다. 그래서 로드되자마자 실행된다. 그럼 로드가 뭐냐? 브라우저가 스크립트태그를 실행할거잖아, 브라우저가 html 을 한줄한줄 실행하는데 스크립트 태그를 만낫네? 그런식으로 만나면 자스코드를 일단 불러와야 한다. 

서버에 있는 자스 파일을 클라이언트로부터 가져와야 하는데 그걸 로드라고 한다. 다운로드라고 생각하자. 다운로드하면 뭐할꺼야? 바로 실행시켜버린다. 그래서 로드하자마자 라고 말한거다.

한줄한줄 바로 실행한다? 식별자를 등록하려고 평가하는거다. 식별자를 등록하려면 실행 컨텍스트가 있어야 한다. 호이스팅이랑 연관이 있다. 

이제부터는 소스코드를 평가했다 라고 말할수 있다. 그럼 소스코드를 평가하면 뭘해야 하지? 평가하면 실행컨텍스트가 만들어지고, 선언문들이 실행되고 식별자들이 실행컨텍스트에 등록된다.

그러고 선언문 빼고 런타임이 시작된다. 런타임에 콘솔로그 엑스를 했다고 치자.  

실행컨텍스트는 식별자랑 스코프랑 관련이 있다. 

실행 컨텍스트 스택이란 곳에서 맨꼭대기에 있는것부터 찾는다. 

전역 실행컨텍스트의 렉시컬 환경으로 찾으러 가서 거기서 두개로 나눠지는데 거기서 식별자가 있는지 없는지 찾는다. 전역 변수는 전역 객체에 있으니까 전역객체랑 연결되어있어야 한다. 

전역객체의 프로퍼티를 전역변수처럼 다룰수 있어야 한다.  



## 실행 컨텍스트의 역할

![image-20200513144136981](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513144136981.png) 

위 코드는 전역코드랑 함수코드로 이루어져있다. 

이 자스코드가 파일로 존재한다고 가정하면, 에치멜에 연결되어있다고 가정하고 로드되엇다고 하면

전역코드의 평가부터 이루어진다. 그때 어떤 전역 실행 컨텍스트가 만들어진다. 그 후에 선언문만 먼저 실행 한다. 위코드는 3개의 선언문이니까 식별자 3개이다. 



.... 에 연결되있는 전역 객체로 만들어진다.

전역 스코프에 등록되어진다. 전역 코드 실행에 들어간다. 엑스에 이전에 무슨 값이었는지 몰랐지만 1로 초기화 되고, 2로 초기화된다. 

함ㅁ수 코드 내부 스킵이다. 

foo(100) 에서 100이란 리터럴을 평가한다. 그 다음에 함수 호출 연산자가 푸를 전달한다. 함수 객체가 가지고 있는 내부 메소드를 호출한다. 푸가 호출되면 100을 인수로 전달하면 위로 올라가서 함수 내부가 실행된다. 그러고 이번엔 함수 내부 코드를 평가된다. (<- 함수 코드의 평가) 그러고 함수 실행 컨텍스트가 만들어지고 선언문  (a, x, y) 3개가 함수 실행컨텍스트에 등록된다.

그 후에 컨스트로 선언되있기 때문에 값은 못봄. 근데 a 는 a 앞에 바가 있는거랑 똑같기 때문에 언디파인드가 된다. 

콘솔로그(a+x+y) 에서 콘솔은... 얘는 어디서 찾지? 함수 실행컨텍스트에서 찾는다. 근데 그 안에 없을거다. 그래서 상위 스코프로 가야 하는데 상위스코프를 어케 알지? 이 코드가 실행되기 전에 상위스코프랑 연결되어져야 한다.

함수는 자신이 정의된 위치에 따라서 상위 스코프를 결정한다. <- 이걸 렉시컬 스코프라고 한다.

렉시컬 스코프로 인해 함수 객체가 태어나면... 어디에 위치하고 있어? 전역에 위치하고 있으니까. ..

이 함수 객체의 내부 슬롯인 인바이러블에 저장한다. 못찾았으니까 상위스코프인 전역으로 간다. 그 상위스코는 전역객체다. 찾앗따. 찾앗으니까 콘솔로그(a+x+y) 평가하고 실행되어야 한다. 여기서 log 는 프로퍼티다. 그래서 프로토 타입체인에서 찾아야 한다. 누구의 프로토 타입 체인? 콘솔의 프로토타입 체인에서 찾아야 한다. 

원래, 콘솔로그(a+x+y) 뒤에는 리턴 언디파인드가 잇고 } 이렇게 되있는거다. 

---

실행컨텍스트의 역할은 소스코드를 실행하기 위해서 특별한 환경을 제공한다.

여기서 컨텍스트를 한글로 문맥이라고 생각하면 된다.

이 문맥에서 뭘 제공하냐면 대부분 식별자를 제공한다.

구체적으로 얘기하면 실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.

스코프는 실행 컨텍스트의 렉시컬 환경이라는 컴포넌트가 하는거고 코드 실행 순서는 실행 컨텍스트 스택으로 관리한다.

스택은 후입선출이다. 밑에가 막혀있는 그릇이다. 

빼온다는 행위를 팝 한다고 한다. 나중에 들어간것이 자료구조상 먼저 나온다. 

큐는 선입후출이다. 

실행 컨텍스트 스택이라는 자료구조 가 있는데 여기에 실행 컨텍스트들이 들어간다. 

실행 컨텍스트를 하나의 큰 객체로 봐야 한다.

![image-20200513151841881](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513151841881.png) 

실행중인 실행 컨텍스트: ... 현재 실행중인것이다. 

그래서 평가하고 실행되면 바 호출되고 바 함수로 들어가면 바 함수 실행된다. 이때 푸 함수 안끝난 상태다. 바 함수 끝나면 바 함수 빠져나와야 한다. 그렇게 되면 실행 컨텍스트에서 팝된다. 함수 코드의 실행이 종료되엇다. 

그러면 푸쉬되었다는건 실행되기 시작되었다 라고 얘기하거나 평가되기 시작했다라고 얘기해야 한다.

그러면 .... 지금 어떤 코드가 실행중이다. 라고 말할수 있다. 

![image-20200513152411488](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513152411488.png) 

현재 실행중인 실행 컨텍스트를 ... 할 필요가 있다. 

... 현재 실행중인 실행 컨텍스트를 관리할수 있다. 

## 렉시컬 환경

실행 컨텍스트가 하나 있으면 렉시컬 환경이 1개 있다.

렉시컬 환경 = 스코프 

외부 스코프의 참조 = 상위 스코프의 참조

스코프 체인은 구체적으로 뭐에 의해서 만들어진다? 외부 렉시커 ㄹ환경 참조로 만들어지는데... 환경 레코드다.

![image-20200513153839380](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513153839380.png) 

환경 레코드는 뭘 나타내는 객체냐? 스코프를 나타내는 객체인데, 식별자를 관리하는 객체이다.

식별자만 관리하면 되? 저 화살표 도 있어야 하잖아. 그래서 외부 렉시컬 환경에 대한 참조도 가지고 있어야 한다. 

![image-20200513153904118](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513153904118.png) 

두개의 컴포넌트를 갖고 있는데 두개의 참조를 갖고 있는데 얘네는 렉시컬 환경을 가리키고 있다. 

위 그림보면 왼쪽에 두개인거잖아. 

![image-20200513154010690](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513154010690.png) 

이게 바로 상위 스코프를 가리키고 있는거다. 

![image-20200513154107752](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513154107752.png) 

이 코드가 로드되기 이전에, 브라우저를 키면 전역 객체(윈도우 객체)가 만들어지고 

윈도우의 프로퍼티 쫘악 있잖아. 그 프로퍼티에 값을 할당하기 위해서.... 주루룩 만들어야 한다.

거기에 뭐가 있나? 거기에 표준 빌트인 객체도 있고 호스트 객체도 있고, 사용자 정의 객체는 아직 없는 상태이다. 그 상태에서 전역코드를 평가하기 시작한다. 

전역 객체와 빌트인이 다 있는 상태에서 전역코드를 평가하기 시직한다. 

그러면 선언문들을 먼저 실행하기 전에 전역 실행 컨텍스트를 생성한다.(현재 전역 실행 컨텍스트는 빈 객체이다. ) 그러고 전역 실행 컨텍스트 스택에 푸쉬된다.  맨 밑 바닥에 깔리게 된다.  현재 빈 실행 컨텍스트이다.  값은 렉시컬 환경이다. 전역꺼니까 전역 렉시컬 환ㄷ경이다.  여기에 바인딩 하게 된다. 

전역 렉시컬 환경은 현재 빈 객체이다. 걔가 비어있으면 안되고 두개의 프로퍼티가 있다. 환경 레코드가 있고 외부 렉시컬 환경에 대한 참조가 있다. 환경 레코드가 또 프로퍼티가 두개 있다. 객체 환경 레코드랑 선언적 환경레코드가 있다. 객체 환경 레코드가 만들어지면 거기에 프로퍼티를 하나 만들어. 이게 바인딩 오브젝트인데 얘가 .... 를 가리킨다. 

함수 코드는 렉시컬 환경에서 객체 환경 레코드로 가서 윈도우 객체로 간다. (선언적 환경 레코드로 안간다)

코드 실행의 준비를 한거다. 

외부 렉시컬 환경 참조 레코드 : 

푸는... 넘기면서 호출하죠? 그러고 푸 함수 내부로 간다. 간 순간 함수 실행 컨텍스트가 만들어진다.

그러고 스택에 들어온다. 푸 함수의 실행 컨텍스트가 현재 실행중인 실행 컨텍스트가 된다. 만들어졋다. 

푸 함수 렉시컬 환경이 만들어진다. 

전역 렉시컬 환경은 환경 레코드랑 외부 참조가 있는데 

함수는 환경 레코드의 내용이 다르다. 

전역 렉시컬 환경은 객체 레코드랑 선언적 두개인데 

함수 환경 레코드는 하나로 되있다. 

![image-20200513160343744](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513160343744.png) 

위 이미지 빨간거 동그라미 친거 하나로 되있는 것이다. 

..... 일반함수로 호출되었으므로 얘가 누굴 가리켜? 윈도우를 가리키게 된다. 

상위 렉시컬 환경.... 누구냐를 결정해야 한다. 

얘는 누굴 결정해야 하냐? 

그게 언제 결정되? 얘가 태어날때. 그럼 기억해야 할거 아냐, 자신의 상위 스코프를. 왜 기억해야 할까?

얘는 어디서 호출될지 모르기때문에. 그래서 함수 객체 자신이 내부 슬롯을 하나 가지고 있다. 그 내부슬롯의 이름이 인바이러먼트다. 그 인바이러먼트의 값이 이 함수 객체가 위치한 전역 렉시컬환경의 참조를 가지고 온다. 그 값이 (값= 함수객체가 가지고 있는 내부슬롯이 기억하고 있는 상위스코프)

지금까지의 설명을 한마디로 얘기하면 렉시컬 스코프라고 한다. 

렉시컬 스코프 : 함수가 자신의 렉시컬... 을 결정하는 방법이라고 했다. 

![image-20200513162246143](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513162246143.png) 

![image-20200513162301593](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513162301593.png) 

![image-20200513163229768](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513163229768.png) 

위에 이프문 선언문 아니다.  

이프문은 실행컨텍스트 안만들지만, 렉시컬 환경은 만든다. 

이걸 그림으로 나타내면~ 아래처럼 나올거다.

![image-20200513163604670](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513163604670.png) 

모든 코드블럭이 실행 컨텍스트를 만드는건 아니다. 실행 컨텍스트를 만드는건 전역과 함수다. 

그 외에 것들중에 스코프 만드는 것들은 코드블럭 쓰는거 다다. 단, 그 코드블럭 안에 렛이나 컨스트로 쓴 식별자가 있는 한이다. 

포문은 조금 특이하다. 

---

---

# 클로저

클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

위 한줄을 이해하려면 "함수가 선언된 렉시컬 환경" 이라는걸 이해하자. 

이게 무슨 뜻인가? 렉시컬 환경 = 스코프. 함수가 정의된 위치의 스코프 와 함수가 묶여있다는 뜻이다.

함수가 있고, 함수의 상위 스코프 가 컴비네이션 되있다는 뜻이다. 

아까 뭐라그랬어. 함수 정의가 평가되어서 함수 객체가 만들어질때 렉시컬 스코프에 의해서 함수의 상위 스코프를 결정하는 방법. (함수가 위치한 곳이 바로 상위 스코프다. )

렉시컬 스코프에서 함수 객체가 평가되어서 함수 객체가 만들어질때 자신의 스코프를 기억한다고 햇다.

어케 기억하지? 함수 객체에 내부 슬롯이 있는데 그 내부 슬롯은 임바이어러먼트인데 거기에 참조값을 가지고 있는데 그게 함수가 선언된 렉시컬 환경이다.

그렇다면 모든 함수는 클로저 다 라고 할수 있다. 왜? 저게 클로저에 대한 정의니까. 모든 함수는 자신이 선언된 렉시컬 환경과 컴비네이션 되어있으니까. 

결론은, 아 자스의 모든 함수는 클로저였다. 그런데, 일반적으로 모든 함수를 클로저라고 하진 않는다.

![image-20200513164848855](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513164848855.png) 

아우터 펑크, 이너펑크 두개가 있다. 얘는 함수 정의가 어디에 위치하나? 전역에 위치한다. 우리 아까 클로저에서 뭐라 했지? 함수와 그 함수선언의 렉시컬 환경의 조합이라고 했잖아

이 함수가 선언된 렉시컬 환경이 누구? 전역 실행 컨텍스트의 전역 렉시컬 환경이다. 얘가 상위 스코프다. 

이너펑크는 아우터펑크 라는 함수 내부에 정의되있잖아. 이 위치가 얘의 상위스코프다. 얘가 만든 렉시컬 환경이 상위 스코프다. 그런데 이 함수(이너펑크)도 스코프가 있죠. 얘의 상위 스코프도 있조. 두개의 스코프가 컴비네이션이다.

**함수 객체의 내부 슬롯 [[Environment]]에 저장된 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 바로 상위 스코프이다. 또한 자신이 호출되었을 때 생성될 함수 렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장될 참조값이다. 함수 객체는 내부 슬롯 [[Environment]]에 저장한 렉시컬 환경의 참조, 즉 상위 스코프를 자신이 존재하는 한 기억한다.**

함수가 태어나자마자 자기의 상위 스코프에 대한 참조를 여기다가 가지고 있다. 언제까지 가지고 있을까? 죽을때까지. 바뀔까 안바뀔까? 바뀐다는 얘긴 상위 스코프가 바뀐다는건데, 그런 경우는 없기때문에 안바뀐다. ... 픽스되어져있다. 

![image-20200513165205489](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513165205489.png) 

이 함수가 있고, 이 함수가 있네?

전역 코드가 평가되는 시점이... 전역 렉시컬 환경이기때문에 얘의 인바이러먼트에 뭐가 들어잇다? 

얘의 상위 스코프는 전역이다. 라고 할수 잇다. 

위 코드의 펑션 바는? 얘도 마찬가지. 콘솔로그 엑스의 엑스는 누굴 가리키냐? 어디서 호출되던지 관계없이 자기의 상위 스코프를 태어날때부터 알고 있다. 상위 스코프, 걔가 전역 렉시컬 환경이다. 75





함수 객체가 평가될때 함수 객체의 위치가 곧 상위 스코프다. 이걸 실행 컨텍스트 관점에서 얘기하면 어케 될까요? 함수가 평가되어져서 함수 객체가 만들어지는 시점에 실행중인 실행 컨텍스트가....

위 코드에서 푸함수가 평가되어져서 태어나는 시점에 현재 실행중인 실행 컨텍스트의 렉시컬 환경이 이 함수객체의 상위 스코프다.

... 전역 실행컨텍스트 입니다.

그러면 바 함수는?

바 함수가 평가되어지는 시점에 전역 실행 컨텍스가 실행중인 실행 컨텍스트일때 이 함수의 상위 스코프이다. 이 함수 객체에 인바이러먼트에... 참조되어있는 값이다. 

![image-20200513171335556](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513171335556.png) 

푸 함수가 호출되어져서 푸 함수의 렉시컬 환경이 만들어졌는데 거기서 두개가 만들어지는데..

그 링크가 어떻게 결정되어지는가? 정답은 푸 암수 객체의 값이다. 위 그림에서 분홍색. 

위에 감춰놧는데 

... 바 함수의 오브젝트의 인바이러먼트의 값이다. 결국 전역 렉시컬 환경의 값이다.

## 클로저와 렉시컬 환경

![image-20200513171859435](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513171859435.png) 

아우터라는 함수가 있네?

뭔가 리턴값을 받네요?

전역코드의 평가가 되고 실행이 되면 할당이 되어지고 아우터 함수가 호출된다.

할당문은 오른쪽에서 호출되어져서 왼쪽으로 간다. 

... 호출이 되면 콘솔로그 엑스로 간다. 그러면 이너 펑션 ()이 실행된다. 

... 실행 컨텍스트만 죽은거다.

![image-20200513172358655](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513172358655.png) 

외부함수보다 내부 함수가 오래살아남았다 라고 할수 있다.

외부함수는 죽엇다. 근데 렉시컬 환경은 살앗다. 누군가가 보고 있으니까. 

중첩함수가 더 오래 살아남아야 하는 상황은 리턴해야 한다는 뜻이다. 

리턴했으니까 원래 내부함수가 죽어야 하는데, 안죽는 이유는 중첩함수가 얘를 바라보고 있으니까 안죽는다

![image-20200513173237150](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513173237150.png) 

... 하더라도 렉시컬 환경은 살아남아있다. 더 오래살아남은 바 함수로 인해서. 더 오래살아남은 중첩함수가 외부함수의 모든 식별자를 다 볼수 있다. 그런데 얘는 뭐만 보고있지? 자신만 보고있지?

이때 원래는 기억해야 한다. 

일번. 외부함수보다 중첩함수가 더 오래 생존해주셔야 합니다. 위 코드의 경우에는 일번이 맞냐? 맞다

이번. 중첩함수가 외부함수의 식별자를 참조하려면 ..

위 일번 이번 다 충족해줘야... 클로저다.

원칙적으로는  모든 함수가 다 클로저인거다. 

함수와 그 함수가 선언된 렉시컬 환경의 조합이라매.

## 클로저의 활용

상태를 안전하게 유지할때 클로저를 쓴다.

상태가 뭘까? 예를 들어서 변수 num 이 있고 1이 할당되어져잇다. 현재 num의 상태는? 1이다. 

그러면 재할당이 이뤄졌다. 3으로. 그럼 현재 num의 상태는 3으로 변경되어졌다.

상태라는 건 바뀐다는 뉘앙스가 있다.

현재는 이렇다 라는 얘기다. 그럼 앞으로도 바뀔거다. 라는 뉘앙스다.

만약에 상수는? 상수는 상태라고 하나? 상수는 상태라고 안한다. 값이 재할당이 이뤄지거나 객체를 할당하고 있는 변수가 바뀌는걸 상태라고 한다.

근데 그 상태가 바뀔텐데, 안전하게 유지하고 싶다라는 얘기다.

![image-20200513174157548](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513174157548.png) 

1씩 증가하는 값을 변수로 관리해야 하잖아 그래서 let num = 0; 이라고 선언했다.

아까 버튼을 누르면 num 을 1씩 증가시키는 거다. 버튼을 클릭하면 상태가 변경되어야 한다라는 얘기다.

그 상태를 변경하는 함수를 인크리즈 라는 함수로 만들었다. ++num 이건 num의 재할당이다. 즉, 비순수함수다.  위 코드는 잘 증가된다. 근데 문제가 있다. 위 코드는 상태를 유지한다라는 말이지만 "안전하게"라는 말이 빠졌다. 전역변수라서 그렇다. 전역변수라는건 밑에 있는 모든 코드가 얠 바뀔수 있다는 말이다. 

안전하다는 말은 변수를 바뀔수 있는 권한을 인크리즈 함수한테만 줘야 한다는거다.

누를때마다 0부터 시작이다. 

![image-20200513174955458](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513174955458.png) 

위 코드에서 리턴 펑션은 완벽한 클로저다.

위 코드는 패턴으로 외우세요.

클로저하면 기본적으로 일단 전역코드를 써야 하는 상황이라고 생각해라. 

.. 걔를 리턴하는거다. 공식이다.

전역 변수를 하나 만드었다. 전역 변수는 누구든지 고칠수 있어서 심각하다.

전역 변술 안쓰면서 변경하고 싶다면 지역으로 옮겨야 하는데 지역으로 옴기면 호출될때마다 재선언되야 하니까 ...

1, 즉시 실행함수를 만든다

그 즉시 실햄수 안에 .. 변술 넣는다

2. 그 즉시실행삼수를 변경하는 함수를 만들고 걔를 리턴해서 받아줘라 

   위 두가지 조건을 만족시켜라 그리고 외부함수에서 호출해라.

   

![image-20200513175549715](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200513175549715.png) 

위 코드는 감소시키는 함수다. 

메소드 두개를 리턴하면 되겠죠? 



예습 : 25, 26

클래스에서 목차 7번까지만 예습하고, 8번 이후부터는 설렁설렁 읽기

26장 의 목차 3번이랑 4번은 꼼꼼히 예습해오기.