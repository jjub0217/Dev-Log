# 배열(많이 코드를 쳐보면서 공부해라)

자스는 누구에게 종속? 에치티멜에게 종속되있음

우리의 최종목표는 에치티멜 만들어서 뷰에 올리는 거다.

옛날에는 따로따로 만드는게 좋다 라고 배웟었지만 지금은 아니다.

에치티멜이랑 씨에스에스를 선언형 언어라고 한다.  프로퍼티들이 정의되어져 있다.

우리는 어케 코딩한다? 정의되어져있는 걸 선택해서 선언한다. 나열하는것이 일이다. 나열하는 식으로 코딩한다. 에치티멜이랑 씨에스에스는.



근데 우리가 컴포넌트라는 개념. 우리가 궁극적으로 컴포넌트를 만들어야 한다. 

에치티멜에서 제공하지 않는 태그를 우리가 만드는거다. 태그가 정해져있지? 우리가 태그를 만드는거다. 

컴터에서 가장 관심있는건 재사용이다. 재사용안하면 돈이 많이 든다. 사람은 실수를 하기 때문에. 고쳐야 할때 돈이 든다.  

따라서 중복이 발생하면 실수가 발생하면 유지보수에 난항이 예상된다. 그러면 버그가 발생되고 회사가 망한다. 

배열을 왜 쓰냐? 그럼 우리가 결국 에치티멜만드는게 일인데, 이거가지고 뭘 만들거야? 프로그램이란건 지시를 한대로만 움직이잖아. 재료를 주면서 에치티멜을 만들라고 하는거다. 

그럼 최고 쉬운 방법은 뭘까? 재료는 다 어디있어? 백엔드에 있어. 그럼 거기에 있든 디비를 가져다가 에치티멜을 만드는거다. 그럼 가장 쉬운 건 뭘까? 백엔드가 디비 갖고와서 에치티멜 만드는거다. 

옛날엔 서버가....

그러면, 클라이언트에서 에치티멜을 만든다. 그럼 어케 해야하지? 클라이언트라고 하면 브라우저라고 생각하면 된다. 그럼 브라우저에서 에치티멜을 만드는거다.

데이터들을 자료들을 구조화할때 배열로 구조화하는거다. 그럼 배열로 구조화한다고 하면 어떻게 할까?

```js
[ 

// 여러 데이터 값들 모아서 하나의 데이터를 가지고 있다. 
// { id: 1, title: '---', writer: '---'...}

]
```

map 의 활용빈도는 자스를 통틀어서 제일 높다.

리액트에서 map 쓴다. 

---

자료구에서의 배열과 자스에서의 배열은 다르다

(메모장보기)

![image-20200518140845315](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518140845315.png) 

기호죠? 배열이란 객체를 만들었기 때문에 리터럴이다. 위 이미지는 배열 리터럴이라고 한다. 

기본적으로 배열 리터럴을 만들어서 쓴다고 생각하면 된다. 

그럼 위 코드에서 arr 은 선두 어드레스를 가리키고 있는거다. 

위 코드에서 '애플', '바나나', '오렌지' 는 요소라고 한다. 배열은 안에 0개 이상의 요소로 이루어진다.

위 코드에서는 프로퍼티 키가 없잖아. 얘는 순서에 의미가 있다. 0번째, 1번째, 2번째라고 하는데 그 번째를 인덱스라고한다.

배열은 값을 찾을때 인덱스를 찾는다. ....  프로퍼티 키에 의미가 있다. 

요소로 쓰일수 있는 것들은 뭐가 있을까? 자스에서 값으로 인정하는 것들은 모두 배열에서 쓸수 있다.

사실은 요소는 프로퍼티 값이 될수 있다. 애플이 바나나 보다 메모리 사이즈가 작다. 

자스는 자료구조 배열처럼 만드는건 어렵다.

접근할땐 어케 접근할까? 대괄호 표기법으로만 접근한다.

인덱스는 0 이상의 정수가 온다. 

배열은 인덱스과 렝스가 있다. ... 쩜을 찍어보면 렝스값을 갖고 있는걸 볼수 있다. 

순차적으로 접근할수 있다. <- 인덱스를 1씩 증가시키면 된다. 



어레이라는 타입은 없다. 

객체는 프로토타입이 있다. 

객체 리터럴은 프로토 타입이 오브젝트다. 

배열 ... 어레이 생성자 함수가 만들엇다고 보면 된다.   

![image-20200518141624719](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518141624719.png) 

배열도 객체다. 

위 이미지를 보면서 비교를 해보면, 

 객체는 뭘 요소라고 하냐면, 프로퍼티로 구성되어져 있고, 배열은 인덱스와 요소 값으로 이루어져있다. 

그리고 값을 참조할때 객체의 경우는 프로퍼티 키로 하는데 배열은 인덱스로 한다. 

어떨때는 대괄호표기법만 사용하지? 프로터피 키가 문자열이어야 되잖아? 문자열이어야 되는데 비극의 시작은 식별자 명칭 규칙은 따라도 되고 안따라도 된다. 따르는 경우에는 둘다 쓸수 있고 둘 같이 안되면 대괄호 표기법으로 써야 한다. 

배열은 순서가 곧 인덱스이기 때문에 순서가 중요하다. 

객체는... 없다. 유사배열 객체는 있다. 배열은 반드시 있는거다. 

![image-20200518141918105](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518141918105.png) 

위 코드보면 배열에 프로퍼티 어트리뷰트를 확인해본것이다. 

저거 뭐야. 배열이 유사배열이랑 똑같네? 얘도 프로퍼티 키가 있고 값이 있내? 아 자스의 배열은 배열이 아니라 객체였다. 객첸데 일반 객체랑 안 똑같고 구현이 다를것이다. 

이 배열은 활용도가 굉장히 높아서 회사에서 굉장히 힘을 들여서 만든다. 

근데 위 모드처럼 만들거면 진짜 배열처럼 만들면 된다. 

근데 갑자기 요소 하나를 추가하면서 스트링을 만들면 진짜 배열이 아니라 객체처럼 동작하게 된다. 

그럼 우리는 ... 생각해야 한다? 가능한한 타입을 일치 시켜라. 

배열의 요소가 백만건이면, 이거 자체부터 틀려먹은거다. 

![image-20200518142405878](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518142405878.png) 

위 이미지처럼 모든값을 다 쓸수 있다고 했으니까 배열 안에 배열을 쓸수 있다.

일반적인 배열은 자료구조에서 말하는 배열을 말하고, 자스에서의 배열의 장단점은

자스는 랜덤 엑세스보다 새로운 요소가 추가되고 삭제되고 하는것에 더 취했다.  



렝스 프로퍼티 하면 반복, 순회 하기 위해서 필요하다는 것이 떠올라야 함. 



![image-20200518142707384](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518142707384.png) 

모든... 렝스 프로퍼티를 갖고 잇다. 요소의 개수라고 생각하면 된다. 꼭 요소의 개수와는 일치 하지 않는다. 

![image-20200518142718734](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518142718734.png)

![image-20200518142823309](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518142823309.png) 

 바로 위 이미지에서 인덱스는.... 4죠. 

위 이미지에서 렝스는 현재 5다. 하지만 두번째 줄처럼 할수 있다. 그렇게 되면 렝스가 줄어든다. 

위는 줄인거잖아, 그럼 늘리면 어케 되지? 

![image-20200518142930198](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518142930198.png) 

희소배열이라는걸 만든다. 위처럼 늘리면 어케 되냐면 이 객체의 프로퍼티 어트리뷰트를 살펴보면 어떤 상황이 되었을가? 0 프로퍼티의 벨류는 1 은 무조건 잇고, 1프로터티가 있을가? 안만든다는 거다. 만들면 메모리가 엄청 차지않다. 렝스값만 바꾼거다. 

렝스값과 실제 요소가 불일치한걸 보여준거다. 

그럼 이런 상황을 만들면 어떻게 되는건가? 허용은 되어있지만, 결론적으로 렝스값 건드리지 말자. 

arr[2] 하면 언디파인드 나온다. 객체라는 말이다. 

1만 사실 존재하고, 렝스값만 바뀐 상황이라고 이해해야 된다. 

![image-20200518143255897](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518143255897.png) 

위 이미지에서 렝스는 몇? 4개다. 이런 배열을 희소배열이라고 한다. <- 이런 상황 만들지 말자. 이런 상황은 안좋은 상황이다. 



## 배열의 생성

가장 일반적인건 배열 리터럴을 쓰는거다. 

어레이 생성자 함수도 있는데 잘 안쓴다. 

![image-20200518143356006](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518143356006.png) 

위 이미지는 렝스가 10인 희소배열을 만들으라는 코드다.

한 43억개 정도 인수를 줄수 잇다. 

## 어레이 오브

이 안에 인수로 준것을, 어레이 생성자 함수는 하나를 준게 렝스값이었지만, 얘는 모든 인수를 요소로 취급한다. 얘는 정체가 뭐냐면. 어레이의 정적 메소드다. 

오브가 있고 프롬이 있다. 어레이 오브는 인수로 요소를 만든다는 것이다. 

얘네는 이터러블이란 걸...

![image-20200518143719105](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518143719105.png) 

얘는 어떤 특징을 가지고 있냐면, 스프레드 문법에 대상이 될수 있고, 또하나 포 오브 문의 대상이 될수도 있다. 일단 그렇게만 알아둡시다. 

유사배열 객체와 이터러블은 비슷하다. 

es5 이전에는 유사배열이라는 애들을 es6에서는 ... 개념안으로 묶는다. 



그럼 어레이 프롬에 인수는 이터러블 또는 유사배열 객체가 올수 있는데, 이걸 가지고 배열을 만드는거다. 더 깊게 설명 안하겠다. 

![image-20200518144200158](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518144200158.png) 

어레이 프롬은 장점이 하나 있다. 예를 들어서 0부터 1억까지 정수의 요소를 가지고 있는 배열을 가져야 한다는 필요가 있다고 가정해보자. 

0부터 1억까지 계속 쳐야해서 틀리기도 할거다. 그래서 이터러블로는 안된다. 그때 쓸수 있는게 어레이 프롬이다. 얘는 두번째 인수에....  

첫번째 요소 값이 뭐였지? 없으니까 언디파인드다. 인덱스는 0 이 온다. 리턴 아이죠? 화살표 함수. 리턴한 값으로 요소값을 채운다. 



## 배열 요소의 참조

배열은 객체이기 때문에 희소배열 만들지 말자는 말이다.



## 배열 요소의 추가와 갱신

객체의 프로퍼티에 동적 추가 할수 있었잖아. 없는 프로퍼티 키에 값을 할당할수 있었잖아. 얘도 마찬가지다. 

![image-20200518144522946](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518144522946.png) 

0 이란 프로퍼티 키란 키가 없는 상황이잖아. ... 바뀐다. 

![image-20200518144543262](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518144543262.png) 

위 코드는 되지만 희소배열이 만들어진다.  위 코드는 쓸데없이 포문을 100번 돌거다. 

 arr['1'] = 2; 이거 될까? 됩니다. 

arr['foo'] = 3; 얘도 된다.

프로퍼티를 열거 하는건 포 인문으로 한다. 포 인문은 어떤 애들만 열거 하나?

상속관계 있는 애들은... 다만, 이뉴머러블이 트루인 애들만 열거한다. 

우리가 포문으로 배열을 순회할수 있고 포 인문으로도 순회할수 있다. 왜냐면 이뉴머러블이 트루일때이니까. 포인문으로 배열넣으면 어케 될까? 포인문은 객체 대상이다. 포 인문은 배열에서 쓰면 안된다. 



## 배열 요소의 삭제

배열의 요소는 프로퍼티잖아. 그래서 딜리트 연산자 사용이 되긴 하는데.... 적용이 안된다. 기본적으로 딜리트 연산자는 쓰는게 아니다. 그럼 어케 지울까? 메소드에서 스프라이스라는게 있는데 그걸로 지우는거다. 



## 배열 메소드

주의할게 있다. 뭐냐면 

```js
const arr = [1, 2, 3];

arr.push(4);
console.log(arr); // [1, 2, 3, 4]

const res = arr.filter(v => v % 2);
console.log(arr); // [1, 2, 3, 4]
console.log(res); // [1, 3]
```

이렇게 하면 arr이 바뀔까 안바뀔까 하는거다. 푸쉬라는 애는 바꾼다. 

필터 쓰면 arr 안바뀌고 고대로 얘다. 



... 대부분 억세스다. ... 명백한... 무조건 억세스, 무조건 뮤테이터 라고 해야 한다. 

뭐가 더 나은 방법이다? 억세스가 더 나은 방법이다. 억세스는 = 가 있어야 하기때문에. 억세스만 쓰면 어떤 이점이 있냐? 헷갈리는 상황이 발생하지 않는다. 따라서 우리는 어떤식으로 마음을 먹어야 하냐면, 뮤테이터는 가급적 안쓴다. 이제 억세스를 써야 한다. 

푸쉬는 뭐한다? 배열의 마지막에 인수로 전달 받은 값을 추가한다. 그때 원본 배열을 수정한다. 

푸쉬는 새로운 요소 값을 ... 하는거다. 

crud 관점에서 바라봐야 한다. 뒤에 값을 빼오는 거. 

```js
const arr = [1, 2, 3];

arr.push(4);
console.log(arr); // [1, 2, 3, 4]

위에서 배열 요소 4를 빼고 싶은거면

arr.pop();
console.log(arr); // [1, 2, 3]
---------------------------------
뒤에서 넣고 뒤에서 빼는 거다. 쌍으로 하는거다. 
```

앞에서 넣는건 언쉬프트. ...

큐는 선입선출이잖아. 



## 어레이.이스어레이

이스가 붙으면 불리언이다. 배열이니? 하는 거다. 왜 이런 메소드가 필요한거지? 타입오브 찍으면 알수 없다. 

그러면 인수를 뭘로 줘야 해? 확인하고자 하는 배열을 주는거다. 

![image-20200518151756477](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518151756477.png) 

배열이면 다 트루, 배열이 아니면 다 풜스



## 어레이.프로토타입.인덱스오브

배열.인덱스 오브 한거잖아. 무슨무슨 배열의 어떤것의 인덱스는? 이렇게 물어보는거다.

그럼 인수를 뭘로 줘야 하는거지? 

![image-20200518152013976](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518152013976.png) 

위에서 인덱스 오브(2) 에서 2 가 요소 값이다. 

위에서 맨 마지막 코드는, 이건 진짜 싫다. 요소가 있다는 거다. 그거 확인할때 많이 쓰는거다.  ... 확인하고 싶을때 많이 쓴다. 그래서 이프문이랑 많이 쓴다. 

중복을 만약에 제거한다면? 중복된 값을 제거해서 123 으로 만들고 싶으면 어케 할가?

셋을 이용해서 중복값을 제거할수도 잇다. <- 그냥 참고로 하자. 

 

![image-20200518152952066](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518152952066.png)  

없으면.. 중복을 방지하는거겠죠? 

인덱스오브는 뮤테이터일까 억세스일까? 하는 일 자체가 억세스이다. 

![image-20200518153121150](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518153121150.png) 

![image-20200518153130731](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518153130731.png) 

위 코드에서 컨스트럭터 : 스택이 없으면....



클래스 내부에서 클로저를 쓸수 있는 방법이 없으니까 프라이빗을 썼다. 

![image-20200518153612781](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518153612781.png) 

![image-20200518153623339](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518153623339.png) 





혼자 구현할수 있는 능력이 있어야 한다.



## 어레이.프로토타입.컨켓

컨켓 이라고 하면 이어붙힌다고 생각하면 된다. 

그럼 배열에 연결한다는 건 무슨 말일까? 

![image-20200518153849074](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518153849074.png) 

위 코드 되게 중요한거다. 컨켓은 대등한 관계에서 잇는거다. 한몸이 된다. 는 뜻이다. 

컨켓은 억세서니까 아래 코드처럼 쓸수 있지만 잘 안쓰는 분위기다. 

![image-20200518154307906](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518154307906.png) 

위 코드가 스프레드 문법이라는거다. 펼친다는 거다. 그래서 결국에 어케 되? 객체 리터럴 내부에 요소를 추가하는 거다.  이게 컨켓보다 나은게 뭘까? 비교했을때 아래가 더 좋은ㄴ거다. 위는 컨켓을 모르면 못쓴다. 즉 메소드를 호출해야 한다는 거다 . 얘를 알아야 하면 인수.. 리턴값을 알아야 한다.

아래는 그냥 메소드를 호출하지 않고도 표현식으로 호출할수 잇다. 요즘 컨켓 거의 안쓰는 분위기니까  스프레드를 써야 한다. 



## 어레이. 프로토타입.스프라이스

그럼 중간은 어케할건데? 그게 스프라이스라는 거다. 중간에 빼는 경우도 있고 넣는 경우도 있을거잖아. 그걸 스프라이스가 한다는 거다. 스프라이스는 뮤테이터일까? 왜일까? 나머지 네개랑 같은 역할을 하니까 뮤테이터다. 

![image-20200518154621618](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518154621618.png) 

위 코드에서 (1, 2, 20, 30 ) 이거 인덱스다. 

우리가 함수를 만들었는데

![image-20200518160154006](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518160154006.png) 

맨처음에 있는지 없는지 봐야 해. 인덱스오브로.

콘솔로그 리무브 (arr, 2) 여기에서 2를 리무브 앞에 하고싶으면? 이거 숙제다~ 리무브만 만들면 됩니다~

아이템 2를 준거잖아.  

![image-20200518160546646](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518160546646.png) 

인수는 누가 줄수 있느냐~? 

브이 !=== 아이템 이게 리턴값이다. ... 이게 다야. 이 경우에는 브이가 아이템이 아니면 2가 넘어갔으면 무슨 얘기? 2가 아닌 요소들로만 이루어진 걸 반환한다. 따라서 모든 요소를 제거한다. 

## 어레이.프로토타입슬라이스

슬라이스는 잘라낸다는 거다. 일부분을 드러낸다는 거다. 일부분, 부분집합을 취하고 싶다는거다.

일부분을 드러낼수도 잇고, 다 드러낼수도 있지? 다 드러내면 복사가 되는거다. 

슬라이스에는 인수를 뭘 줘야 할까?  즉, 슬라이스를 그냥 호출하면 복사하는거다.

![image-20200518161405143](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518161405143.png) 

![image-20200518161536666](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518161536666.png) 

투두스는 객체인데 요소다. 

_투두스랑 투두스는 메모리 주소가 다르다 (const _todos = todos.slice();)

우리가 .. 하려면 얕은복사만 해야 하는거다. 1레벨만. 컨테이너만.

깊은복사는 이 안에 있는 모든 객체들이 싹다 복사되는거다. 

그럼 깊은 복사 할라면 어케 해야 할까? 얕은 복사할때는 슬라이스 하면 된다. 

그땐 우리가 만들어야 한다. 재귀로 만들어야 한다.  재귀는 힘드니까 라이브러리 써야 한다. 



배열 메소드를 쓰고 싶으면 아규먼트 객체를 배열로 전환할수 있다. 이때 슬라이스를 쓸수 있다. 

이때 콜을 써서 아규먼츠를 호출하면서 디스로 써라

## 조인

얘는 문자열을 합치는 거다. 



## 리버스

요소들의 정렬상태를 거꾸로 돌리는거다.



# 필

요소들의 정렬을 채우는거다.



## 플랫

es10 문법이다

말그대로 평탄화한다. 안에 중첩된걸 푼다는 거다.

그러면 중첩의 중첩이 있으면 어케 하지? 

![image-20200518163400651](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518163400651.png) 



## 배열 고차 함수

고차함수는 배열만 있을까? 아니다. 근데 배열의 고차함수가 활용도가 너무 높다

지금까지 배운 메소드들을 써야 하는 경우를 생각해봐야 한다.

기본적으로 배열의 고차함수들은 무조건 싹다 억세스다. 



## 어레이.프로토타입.소트

![image-20200518164116870](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518164116870.png)  

소트가 뭘 리턴하냐면, 정렬된 배열을 리턴한다. 이 얘기는 여기서 소트를 했을때, 쩜 소트 앞에 잇는걸 바꾼다. 

얘는 뮤테이터이다. 

자신을 리턴하면 어떤 일이 벌어지냐? 

근데 숫자인게 문제다. 얘를 인수를 안주고 소트해보면 아래처럼 나온다. 

![image-20200518164248602](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518164248602.png) 

트루 풜스가 정렬이 되냐? 객체는 정렬될까? 정렬 안되는데 정렬을 해야 하니까 모든 요소를 문자열로 

변환해서 문자열로 소트 한다. 그래서 문자열은 아무 문제가 없던 거엿다. 

콜백함수는 인수가 ... 두개의 매개변수를 뺀다. 

![image-20200518164801111](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518164801111.png) 



그럼 아래 코드처럼 이런 식은 어때?

![image-20200518164920483](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200518164920483.png) 

conpare('id') 얘를 호출했져? ... id 줬죠. 중첩함수입니다.  클로저입니다. 

... 자유변수. 저기 위 코드에서 왜 부등호를 썼을까?

a[key] 얘가 숫자요, 문자열이다.  문자열에서 문자열을 빼면 뭐지? 난이다. 문자열과 문자열을 빼면 난이다. 문자열때문에 비교한거다. 



## 어레이.프로토타입.포이치

```js
const arr = [1, 2, 3];

arr.forEach(여기에 인수를 3개 받는 콜백을 줘야 한다.)
--------------------------------------------------
const arr = [1, 2, 3];

arr.forEach((v, i, array) => {
    console.log(v, i, array);
});
```

포이치는 포문 대용이다. 그럼 왜 포문 안쓰고 포이치 쓸까? 

```js
arr.forEach(v, i) => {
    console.log(v, i);
});
----------------------
이렇게하면 어케될까? ... 받고 안받고 책임은 콜백을 만드는 사람 마음이다.
--------------------------
arr.forEach(v) => {
    console.log(v);
});
---------------------------
나는 v 필요업고 i 만 필요할땐? 
    
arr.forEach( _, i) => {
    console.log(i);
});

아 v 는 필요없고 i 만 필요하구나~
```

포이치는 억세서 일수도 있고 포이치( _, i) => {
    console.log(i);
});    <- 애가 억세서 아닐수도 있다. 

```js
const arr = [1, 2, 3];

arr.forEach((v, i, array) => {
    array.push(v);
});

console.log(arr);
---------------------------
    이런코딩은 가능하지만 이렇게 쓰면 안된다.
```

우리는 포문보다 포이치를 쓰도록 하자. 단, 배열이 엄청 크다. 배열이 요소가 만개다. 이럴땐 포문을 쓰자. 포문이 빠를거 같아? 포이치가 빠를거 같아? 포문이 빠르다. 

성능보다 가독성이 우선이다.  사실 포이치를 쓸일이 그다지 없다. 



## 맵

포이치과 매우 유사하다.

반드시 리턴이 있어야 한다. 

```js
const arr = [1, 2, 3];

arr.map((v, i, array) => v ** 2);   <- 맵 뒤에 괄호 전체가 콜백함수다.
```

원본배열 3개, 내가 만든거 1개 이러면 필터 써라

```js
const arr = [1, 2, 3];

console.log(arr.map((v, i, array) => v ** 2)) 1번
console.log(arr.map(v => v ** 2) 2번
```

```js
let todos = [
    { id: 1, content: 'HTML', completed: false },
    { id: 2, content: 'CSS', completed: true },
    { id: 3, content: 'Javascript', completed: false }
]


// [1, 2, 3] 이 나오도록 포문으로 구현해라
--------------------------------------------------------------

let todos = [
    { id: 1, content: 'HTML', completed: false },
    { id: 2, content: 'CSS', completed: true },
    { id: 3, content: 'Javascript', completed: false }
]

const _todos = [];
for (let i = 0; i < todos.length; i++){
    _todos.push(todos[i],id);
}
console.log(_todos);
--------------------------------------

console.log(todos.map(todo => todo.id));
```



예습 : 28, 29 읽어오고, 27 에서 32까지 읽어와라







