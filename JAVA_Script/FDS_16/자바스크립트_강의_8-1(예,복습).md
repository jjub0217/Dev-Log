# 프로퍼티 어트리뷰트

- 내부 슬롯 
  - JS의 엔진을 구현하는 알고리즘을 설명하기 위해 ECMAScript에서 사용하는 의사 프로퍼티이다.
  - 감춰진 프로퍼티  라고 말할 수도 있다.
- 내부 메소드 : JS의 엔진을 구현하는 알고리즘을 설명하기 위해 ECMAScript에서 사용하는 의사 메소드이다. 

내부 슬롯과 내부 메소드는 [[ ]] 으로 감싸서 나타낸다.

----------

내부 슬롯과 내부 메소드는 원래 외부로 공개된 객체의 프로퍼티와 메소드가 아니다. 그래서 직접적으로 접근하거나 호출 할 수 있는 방법이 없지만, 간접적으로는 접근할 수 있다. 

1. [[prototype]] 이란 내부 슬롯에는 원래 직접적으로 접근하는것은 불가능하지만, _ _ prototype _ _이라는 것으로 간접적으로 접근이 가능하다.(모든 객체는 [[prototype]]) 이란 내부슬롯을 가지고있다)

   ```js
   const o ={};
   
   o. [[prototype]] // SyntaxError <- [[prototype]]이라는 내부 슬롯에 직접적으로 접근했더니 에러가 났다.
   o.__protot__ // object.prototype <- [[prototypr]] 이라는 내부 슬롯에 __proto__ 라는 것을 사용하여 
   간접적으로 점근한 상태이다. 에러가 안난걸 보니 정상적으로 동작하는것이다.
   ```

2. Object.getOwnPropertyDescript 라는 메소드를 사용하여 `프로퍼티 어트리뷰트` 라는 내부슬롯에 간접적으로 접근이 가능하며, 접근을 하면 프로퍼티 디스크립터 객체를 반환한다.

   - Object.getOwnPropertyDescript 라는 메소드를 호출하면, 첫번째 매개변수에는 객체의 참조를 전달하고, 두번째 매개변수에는 프로퍼티 키를 문자열로 전달한다.

   > __데이터 프로퍼티 어트리뷰트__(=내부 슬롯)
   >
   > 프로퍼티의 상태를 나타내는 것이다. 
   >
   > ① [[Value]] : 프로퍼티의 값을 나타낸다.
   >
   > - 프로퍼티 키를 통해 프로퍼티 값을 변경하면 [[Value]]에 값을 재할당한다.
   > - 프로퍼티가 없으면 프로퍼티를 동적 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다. 
   >
   > ② [[Writable]] : 값의 갱신이 가능한지, 프로퍼티 값의 변경이 가능한지 여부를 나타낸다.<br>     (Value 의 값을 쓸수 있느냐?)
   >
   > - [[Writable]] 값이 false인 경우에는 [[Value]] 의 값을 변경할수 없는 readOnly한 프로퍼티가 된다.
   > - 단, [[Writable]]이 true면 [[Value]] 의 변경과   [[Writable]]을 false로 변경이 가능하다.
   >
   > ③ [[Enumerable]] : 열거가 가능한지 여부를 나타낸다. 
   >
   > - for in 문으로 열거
   > - object 라는 객체의 keys로 열거 <br>(객체의 keys : 프로퍼티의 키들을 뽑아서 배열로 리턴해준다.)
   > - [[Enumerable]] 의 값이 false인 경우에는 for in문이나 Object.keys 메소드 등으로 열거할수 없다.
   >
   > ④ [[Configurable]] : 재정의가 가능한지 여부를 나타낸다.
   >
   > - [[Configurable]]값이 false인 경우에는, 해당 프로퍼티의 삭제, 값의 변경, 프로터피 재정의가 금지된다.
   >
   > > __프로퍼티 디스크립터 객체__
   > >
   > > 프로퍼티 어트리뷰트들을 모은 객체

   ```js
   const person = {
       name: 'Lee'
   };
   console.log(object.getOwnPropertyDescriptor(person,'name');
   // {value: "Lee", writable: true, enumerable: true, configurable: true}
   -----------------------------------------------------------------
   // value: "Lee" <- 프로퍼티의 값인 'Lee'를 문자열로 반환했다.
   // writable: true <- 객체 리터럴로 프로퍼티를 만들면 내부슬롯의 값은 기본적으로 true로 세팅이 된다. 
   //enumerable: true <- 객체 리터럴로 프로퍼티를 만들면 내부슬롯의 값은 기본적으로 true로 세팅이 된다. 
   //confiurable: true <- 객체 리터럴로 프로퍼티를 만들면 내부슬롯의 값은 기본적으로 true로 세팅이 된다.             
   ```

즉, 프로퍼티에는 프로퍼티 어트리뷰트라는 내부슬롯이 있고, 그렇기 때문에 프로퍼티 자체가 객체라는 뜻이다. <br>또한, 모든 객체는 [[Prototype] 이란 내부슬롯을 가지고있는 것이고, [[Value]], [[Writable]], [[Enumarable]]. [[Configuarable]], [[Prototype]] 각각의 내부슬롯을 __프로퍼티 키__라고 생각하면 된다. 



## 데이터 프로퍼티와 접근자 프로퍼티

### 데이터 프로퍼티

<u>" 키와 값으로 구성된 __일반적인 프로퍼티__ "</u>

- 프로퍼티가 생성될 때 [[Value]]의 값은 프로퍼티 값으로 초기화가 되며, [[writable]]과  [[Enumarable]], [[Configuarable]] 의 기본값인 true 로 초기화된다. <br>이는, 프로퍼티를 동적 추가하여도 마찬가지다.

### 접근자 프로퍼티(_ _ proto _ _)

<u>" [[Value]]을 가지고 있지 않고, 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 __접근자 함수로 구성된 프로퍼티__"</u>

__프로퍼티 처럼 생긴 함수__

① [[Get]] : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수

- 접근자 프로터피 키로 프로퍼티 값에 __접근하면__ `getter 함수`가 호출이 되고, 그 결과가 프로퍼티 값으로 반환된다. 

- 반드시 리턴을 해야 한다.

- 인수를 전달할 방법이 없기때문에 매개변수를 쓸 이유가 없다. 

  > __getter 함수__
  >
  > [[Get]] 이라고 하는 프로퍼티 어트리뷰트의 값인 함수 

```js
get fullname(){
    return `${this.firstName} ${this.lastName}`;
}
console.log(person.fullName);
```

② [[Set]] : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수

- 접근자 프로터피 키로 프로퍼티 값에 __저장하면__ setter 함수가 호출이 되고, 그 결과가 프로퍼티 값으로 반환된다. (프로퍼티 값을 할당하면 `setter 함수`가 호출이 된다.)

- 반드시 리턴이 없어야 한다.

- 반드시 인수를 받아야 하는데, 반드시 1개만 받아야 한다.

  >__setter 함수__
  >
  >[[Set]] 이라고 하는 프로퍼티 어트리뷰트의 값

```js
set fullName(name){
    [this.first, this.lastName] = name.split(' ');
}
person.fullName = 'Heegun Lee';
```

③ [[Enumerable]] : 열거가 가능한지 여부를 나타낸다. 

- for in 문으로 열거
- object 라는 객체의 keys로 열거 <br>(객체의 keys : 프로퍼티의 키들을 뽑아서 배열로 리턴해준다.)
- [[Enumerable]] 의 값이 false인 경우에는 for in문이나 Object.keys 메소드 등으로 열거할수 없다.

④ [[Configurable]] : 재정의가 가능한지 여부를 나타낸다.

- [[Configurable]]값이 false인 경우에는, 해당 프로퍼티의 삭제, 값의 변경이 금지된다.



예시 코드)

![캡쳐107](https://user-images.githubusercontent.com/62126380/82121912-652fad00-97cb-11ea-97a8-74dcf8e5ab73.PNG) 

![캡쳐108](https://user-images.githubusercontent.com/62126380/82121942-960fe200-97cb-11ea-9e0b-7cc98fc63023.PNG)   

 

** getOwnPropertyDecriptor 함수로 데이터 프로퍼티만 가져올수 있는게 아니라 <br>접근자 프로퍼티도 가져올수 있다.

```js
Object getOwnPropertyDecriptor(Object.prototype, '__proto__');
// {get: ƒ, set: ƒ, enumerable: true, configuarable: true}

Object.getOwnPropertyDecriptor(function(){}, 'prototype');
//  {value: {...}, writable: true, enumerable: true, configuarable: true}
```



## 프로퍼티 정의

### 프로퍼티 정의

- __새로운 프로퍼티를 추가__ 하면서 __프로퍼티 어트리뷰트를 명시적으로 정의__ 하거나,<br>기존 프로퍼티의 프로퍼티 어트리뷰트를 __재정의__ 하는 것을 말한다.
- __Object.defineProperty 메소드__를 사용하면 __프로퍼티의 어트리뷰트를 정의__ 할수 있다.
- Object.defineProperty 메소드는 한번에 하나의 프로퍼티만 정의할수 있지만,<br>Object.defineProperties 메소느는 여러개의 프로퍼티를 한번에 정의 할수 있다.

---

#### 데이터 프로퍼티 정의

![캡쳐109](https://user-images.githubusercontent.com/62126380/82138066-7e326f80-9858-11ea-8824-af081055a416.PNG)

- Object.defineProperty 메소드로 프로퍼티를 정의할때 프로퍼티 디스크립터 객체에서 일부의<br>프로퍼티를 생략하면 프로퍼티의 기본값이 적용된다.

  [[Value]] 의 기본값 : undefined<br>[[Writable]] 의 기본값 : false<br>[[Enumerable]] 의 기본값 : false<br>[[Configuarable]] 의 기본값 : false

----

#### 접근자 프로퍼티 정의

![캡쳐110](https://user-images.githubusercontent.com/62126380/82138079-9dc99800-9858-11ea-8802-d6ed4389caba.PNG) 

- Object.defineProperty 메소드로 프로퍼티를 정의할때 프로퍼티 디스크립터 객체에서 일부의<br>프로퍼티를 생략하면 프로퍼티의 기본값이 적용된다.

  [[Get]] 의 기본값 : undefined<br>[[Set]] 의 기본값 : undefined<br>[[Enumerable]] 의 기본값 : false<br>[[Configuarable]] 의 기본값 : false

  

## 객체 변경 방지

객체를 변경을 방지할수 있는 3가지 메소드가 있다.

1. 객체 확장 금지
2. 객체 밀봉
3. 객체 동결
   -  재할당이 안 이루어지는 상황에서 객체를 원시값처럼 쓰고자 할때에 객체동결(Object.freeze)를 통해서 객체를 얼려서 readOnly하게 만든다. 

==> ∴ 이런게 있다고만 알고 넘어갑시다. 왜냐면, 실무에서는 다 라이브러리를 쓰기 때문에 이것들이 있다고만 알고 넘어가자. *<- 라이브러리 사용하는게 훨씬 안전하다* 



