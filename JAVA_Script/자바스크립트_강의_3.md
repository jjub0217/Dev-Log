# 데이터 타입 

![캡쳐66](https://user-images.githubusercontent.com/62126380/80305488-ff698a00-87f7-11ea-8b20-25d1bcc97a06.PNG) 



## 데이터 타입의 필요성

- 모든 값은 데이터 타입을 갖고 있는데, 그 값이 메모리에 저장될때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 읽어들일때 읽어들일 메모리 공간의 크기를 결정하기 위해(값을 참조할때  선두 어드레스에 접근하여 계산한 메모리공간의 크기를 결정)
- 메모리에서 읽어들인 값의 2진수를 어떻게 해석할지(숫자타입인지, 문자열 타입인지 등) 결정하기 위해



#### 동적 타이핑( 타입을 만든다 )

## 동적 타입 언어와 정적 타입 언어

#### 정적 타입 언어 

- JS 언어가 아닌 다른 언어들에서 사용하는 언어

- 데이터 타입이 변하지 않는다. 

- 변수를 선언할때 데이터 타입을 명시적으로 선언 

  ``` javascript
  ex)
  char c; //정수타입의 값만 할당
  int num; // 4바이트 정수 타입의 값만 할당
  ```

- 타입 체크를 한다 : 선언한 데이터 타입에 맞는 값을 할당했는지 체크검사

#### 동적 타입 언어

- 데이터 타입(값의 타입)이 변한다. 

- 변수의 타입을 마구 바꿀수 있기 때문에 타입체크가 힘들다. 

- JS는 변수에 데이터 타입이 없지만, 값을 할당할때 데이터 타입이 정해진다. 

  - > **typeof**
    >
    > - 연산자
    >
    > - 선언한 변수의 타입을 문자열로 반환해준다.
    >
    > - 변수에 타입이라는 것이 존재하지 않지만, typeof  연산자를 통해서 변수의 데이터 타입을 알수 있다.
    >
    >   ![캡쳐69](https://user-images.githubusercontent.com/62126380/80363833-c4328e00-88bf-11ea-93bd-e1a0247b132f.PNG) 

 

**암묵적 타입변환** : JS는 데이터타입을 암묵적으로 변환시킨다. JS엔진은 암묵적으로 하는게 많기 때문에 우리가 이것을 머릿속에 담아두고 있지 않으면 실수할 가능성이 높다.  *<- 오히려 브랜든 씨는 우리에게 친절한 언어로 만들어줬지만 그게 우리에게 발목을 잡는다.* 

JS에서 변수 사용시 주의사항 

- 변수의 사용을 적극적으로 줄인다.
- 전역 변수는 사용하지 않는다. 
- 변수의 생명주기를 최대한 짧게 만든다(변수가 오래살면 리소스를 차지하게 된다. )
- 변수 이름은 변수의 존재 이유를 파악할수 있도록 명명한다. 

![image-20200424154421863](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200424154421863.png)

*<- 일주일전의 나와 대화를 하자... 심신을 차분히 가라앉히고... 후...*

# 연산자

<p style="color:red";> 들어가기에 앞서...</p>

> 부수효과란?
>
> 1. 변수의 값이 교체 (피연산자의 값을 변경하는 효과)
>
> 2. 피연산자의 값이 바뀌는 경우가 없이, 언제나 새로운 값을 만들 뿐이다. 
>
> % 기호 사용방법 
>
> ex)
>
> 3 % 2 = 1
>
> 4 % 2 = 0 **<u>( 2로 나눠서 0 이면 짝수, 1이면 홀수 )</u>**
>
> ---

연산자라는 것은, 연산을 하는 무엇인가를 연산자라고 한다. <br>이때 연산이 되는 대상이 표현식이라고 하는데, 그 표현식을 피연산자라고 한다. 

**피연산자가 값이라는 명사의 역할을 한다면 연산자는 동사의 역할을 한다.**<br>![캡쳐70](https://user-images.githubusercontent.com/62126380/80365219-34421380-88c2-11ea-89b8-e994232d954b.PNG)  

## 산술 연산자 

![캡쳐71](https://user-images.githubusercontent.com/62126380/80369197-d36a0980-88c8-11ea-9c9e-ddce62ddaf99.PNG) 

### 단항 산술 연산자

- 1개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다

- 1. 변수 앞에 위치 : 선증가 후할당 / 선감소 후할당

     ![캡쳐72](https://user-images.githubusercontent.com/62126380/80374908-5fccfa00-88d2-11ea-9ccd-bc77fb2edd5d.PNG)   

     ```javascript
     ① x 의 값이 먼저 증가되어 x의 값이 6이란 결과값 도출
     ② 증가,감소되어 부수효과로 인해 변경된 x의 값이 'result'라는 변수에도 할당되었다.
     ----------------------------------------------
     -> 결과값 6, 6 / 4 ,4
     ```

  2. 변수 뒤에 위치 : 선할당 후증가 / 선할당 후감소

     ![캡쳐73](https://user-images.githubusercontent.com/62126380/80375017-8b4fe480-88d2-11ea-99a2-8cc9cf4168f6.PNG)  

     ```javascript
     ① 'result'라는 변수에 먼저 x라는 값을 할당한다. 
     ②  var 로 선언한 변수 x 의 값이 증가,감소되어 부수효과로 인해 6이란 결과값 도출 
     ③ 'result'의 값은 재할당하지 않았기 때문에 변하지 않는다. 
     ----------------------------------------------
     -> 결과값 5, 6 / 5, 4
     ```

- 숫자 타입이 아닌 변수를 사용하면 해당 변수를 숫자타입으로 암묵적 타입변환으로 인해 바뀐다. 

```
+'10'; // 10   ---> 문자열을 숫자로 타입변환
+true; // 1    ---> 불리언 값을 숫자로 타입변환(true를 숫자로 변환하면 1 이다.)
+false;// 0    ---> 불리언 값을 숫자로 타입변환(false를 숫자로 변환하면 0 이다.)
+'Hello';// NaN --> 문자열은 숫자로 타입변환 할수 없다.  
```

---



## 문자열 연결 연산자

우항과 좌항 변수 둘중에 하나라도 문자열이면 문자열 연결 연산자로 동작한다. 

- null 이 타입변환되면 '0' 이 된다. 
- undefined 는 숫자로 타입변환되지 않는다.(undefined를 숫자로 변환하여 계산하면 NaN값 도출)

---



## 할당 연산자

- 할당문은 표현식이다. 
- 할당되어지는 값으로 평가되기 때문에 표현식이다. 

![캡쳐75](https://user-images.githubusercontent.com/62126380/80377164-d9b2b280-88d5-11ea-8544-924324e2a068.PNG) 

- 연쇄 할당문도 유의하자. 

  ![캡쳐76](https://user-images.githubusercontent.com/62126380/80377611-76755000-88d6-11ea-96f5-cf3c72f7b3b3.PNG) 

  

## 비교 연산자

### 동등 / 일치 비교 연산자

![캡쳐82](https://user-images.githubusercontent.com/62126380/80593928-0513d980-8a5d-11ea-9185-03d0e64d6630.PNG) 

-  좌항과 우항의 값이 같은지 다른지, 타입이 같은지 다른지 비교할때 사용

-  경우의 수가 2개일때 사용

-  동등비교 연산자 == (좌항과 우항은 값이 같음) 

  -  웬만하면 사용하지 말자 (암묵적 타입변환이 발생해서 값을 예측하기 힘들기 때문에 )
  
  ```javascript
  5 == '5'; // 5 와 '5'는 각자 순서대로 숫자타입과 문자열 타입으로 타입이 다르지만,
  			암묵적 타입변환으로 인해 5 가 문자열 타입으로 바뀌었다. 
              ===> 'true' 값 도출
  false == null;  // false 값과 null 값이 같으냐? 하고 물었다. 
  				   같지 않기 때문에 'false' 값 도출
  false == undefined;  // false 값과 undefined 값이 같으냐? 하고 물었다.
  						같지 않기 때문에 'false' 값 도출
  ```

- 부동등 비교 연산자 (좌항과 우항의 값이 다름)

  - 사용방법 : O != △  

    -  "O 과 △ 는 값이 **<u>다르냐</u>**?" -> 응. 달라.  = true 값 도출

      ​											  -> 아니, 같아. = false  값 도출 

    - 암묵적 타입변환이 발생한다. 

    ```javascript
    5 != 8;  // 5 와 8 의 값이 "다르냐?"고 물었다. 
    		 	5 와 8 은 숫자타입으로 같지만, 값이 다른게 맞기 때문에 
                ===> 'true' 값 도출
    5 != 5  // 5 와 5의 값이 "다르냐?"고 물었다. 
    		   5 와 5 는 숫자타입도 같고, 값도 같기때문에 다른게 아니다.
               ===> 'false' 값 도출
    5 != '5'  // 5 와 '5'의 값이 "다르냐?"고 물었다.
    			 5 와 '5' 는 각자 순서대로 숫자타입과 문자열 타입으로 데이터타입이 다르지만, 암묵적 타입변환으로 인해 5 가 문자열 타입으로 바뀌었다.
                 암묵적 타입변환으로 5 와 '5' 는 데이터 타입도 같고, 값도 같아졌으므로 다른게 아니다.
                 ===> 'false' 값 도출
    ```

- 일치 비교 연산자 (좌항과 우항은 값도, 타입도 같음)

  - 사용방법 : O === △ 

    -  "O 과 △ 는 값도, 타입도 같으냐?" -> 응. 같아.  = true 값 도출

      ​														   -> 아니, 안 같아. = false  값 도출 

  - 암묵적 타입변환이 발생하지 **<u>않는다.</u>**

    ```javascript
    5 === '5' // 5 와 '5'는 각자 순서대로 숫자타입과 문자열 타입으로 타입이 다르다. 
    			값도,타입도 같은지 묻는 === 일치비교 연산자를 사용하여 "같냐?"고 물었다.
                숫자로는 같을지라도, 데이터 타입으로는 다른게 맞기 때문에 
                ==> 'false' 값 도출
    NaN === NaN;  //  자신과 자신을 비교했을때 다르다고 나오는 유일한 값. <- 이런건 해괴망측한거야... 
    0 === -0;  // 양의 0 과 음의 0 은 동일한 값이기 때문에 'true' 값 도출
    ```

- 불일치 비교 연산자 (좌항과 우항은 값이나, 타입이 다름)

  - 사용방법 : O !== △ 

    -  "O 과 △ 는 값이나, 타입이 **<u>다르냐?</u>**" -> 응.  둘중에 하나가 달라.  = true 값 도출

      ​														       -> 아니, 둘다 같아. = false  값 도출 

  - 암묵적 타입변환이 발생하지 **않는다.**

    ```javascript
    5 !== 8;  // 5 와 8 의 "값이나, 타입이 다르냐?"고 물었다. 
    		 	5 와 8 은 숫자타입으로 같지만, 값이 달라서 둘중에 하나가 다르다.
                ===> 'true' 값 도출
    5 != 5  // 5 와 5의 "값이나 타입이 다르냐?"고 물었다. 
    		   5 와 5 는 숫자타입도 같고, 값도 같다.
               ===> 'false' 값 도출
    5 != '5'  // 5 와 '5'의 "값이나 타입이 다르냐?"고 물었다.
    			 5 와 '5' 는 각자 순서대로 숫자타입과 문자열 타입으로 데이터타입이 다르지만 값은 같아서, 둘중에 하나가 다르다.
                 ===> 'true' 값 도출
    ```

### 대소관계 비교 연산자

대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.

---



## 삼항 조건 연산자

- 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다. 

- 삼항 조건 연산자은 값처럼 다른 표현식의 일부가 될수 있다. 

- 먼저 if 문으로 만들어보고, 그 if문을 삼항 조건 연산자로 고치면 어케 될지 해본 후, 어떤게 가독성이 좋은지 보고 결정해라.

- 사용방법 

  - (조건식) ? (조건식이 true일때 반환할 값) : (조건식이 fasle 일때 반환할 값)

  ```javascript
  ex 1)
  var x = 2;
  var result = (x % 2) ? '홀수': '짝수'
  console.log(result); 
  // '홀수'
  --------------------------------------
  ---> ① (x % 2)는 값이 0 이 나오고, 0 은 암묵적타입변환으로 불리언값 false 값이 된다.
   	 ② false 값이 나왔으므로 false일때 반환하는 값인 '홀수' 값이 도출된다 
  
  ex 2) 조건이 3개일때 
  var num = 2;
  var kind = ①num ? ②(num > 0 ? '양수' : '음수') : '영'
  console.log(kind);
  // '양수'
  ----------------------------------------
  1. ①num 값을 먼저 읽어들이면 2 이란 값이 도출된다.
  2. ②의 true일때 반환되는 (num > 0 ? '양수' : '음수') 을 해석해본후 앞서 도출된 값이 2 이기때문에 true면 반환되는 값 '양수' 이 도출될것이다.
  3. 만약에, (num > 0 ? '양수' : '음수') 을 해석해봤는데 '양수'도 아니고 '음수'도 아니어서 var kind에 할당된 표현식 자체가 false 값이 나온다면 '영'값이 도출될것이다.
  ```

  

---

## 논리 연산자

![캡쳐83](https://user-images.githubusercontent.com/62126380/80601468-d1d74780-8a68-11ea-9c7a-fedbe417f834.PNG)  

- 논리합

```javascript
true or true = true
true or false = true
----------------------
어느 한쪽이라도 true 면 'true' 값 도출
```

- 논리곱

```javascript
true and true = true
true and false = false
----------------------
어느 한쪽이라도 false 면 'false' 값 도출
두쪽 다 true 여야지 'true' 값 도출
```

- 부정

```javascript
!true = false
!false = true
```



#### 단축평가

```javascript
ex 1)
'cat' && 'dog'
----------------
위 예시를 잘 봐바라.
좌항에 'cat' 이란 문자열 타입의 어떤것이 존재하니까 'true'. 
우항에 'dog' 란 문자열 타입의 어떤것이 존재하니까 'true'.  -> 'true' 값이 도출될 것 같지만
아니다.
'cat'이 true 이고, 'dog'가 false 로 되어있고 논리곱으로 연산되어있다. 
그러면 false 값이 도출될것이지 않은가?
즉, 단축평가에서는 뒤에 존재하는 것으로 저 단축평가식은 평가되어질 것이다. 
이말인즉슨, 단축평가는 우항으로 평가되어 결과값이 도출될 것이므로 
===> 결과값 'dog' 란 값 도출.
```

```javascript
ex 2)
!(x || y) 
----------
위 코드는 이렇게 생각하면 쉽다. 
2(1+2) 라는 수학 계산식을 생각해보면, (2*1) + (2*2) 로도 계산되어진다.
같은 방법으로 계산해보면, !x || !y 으로 계산되어지는 것을 알수 있다. 
즉, !(x || y) === (!x && !y) 이란 식이 성립된다.(** 주의! 연산자에서 !가 곱해진다.)
```

단축평가를 사용한다면 조건문 if 문과 if else 문을 대체 할수 있다. 

```javascript
ex 1)
var done = true;
var message = '';
--------------------------------
① if (done) message = '완료';
--------------------------------
② message = done && '완료';
--------------------------------
위 코드에서는 ①번으로도 나타낼수 있고, ②번으로도 나타낼수 있다. 
①번 : done이 true 면 message에 '완료' 라고 할당하겠다. 
②번 : message는 done 그리고 '완료'다 
==> 논리곱은 좌항과 우항 둘중에 하나라도 false면 false값이다. 그래서 좌항이 true여도 좌항이 false면 우항의 값으로 평가 된다. 즉, 논리곱 식은 우항의 값으로 평가되어 결과값이 도출된다. 
-------------------------------
console.log(message); // 완료

```

```javascript
var done = false;
var message = '';
-------------------------------
if (!done) message = '미완료';
-------------------------------
message = done || '미완료';
-------------------------------
위 코드에서는 ①번으로도 나타낼수 있고, ②번으로도 나타낼수 있다. 
①번 : done이 false 면 message에 '미완료' 라고 할당하겠다. 
②번 : message는 done 또는 '완료'다 
==> 논리합은 좌항과 우항 둘중에 하나라도 true면 true값이다. 그래서 좌항이 false면 우항의 값까지 보고 평가하여야 한다. 즉, 논리곱 식은 좌항이 fasle면 우항의 값까지 평가되어 결과값이 도출된다. done 이 현재 false 값이기 때문에 우항까지 보면 우항은 true 값이다. 
-> 우항의 값으로 결과값 도출된다.
---------------------------------    
console.log(message); // 미완료
```

## 쉼표 연산자

- 표현식인 문이다.
- 쓰지 마세요 <- 가독성이 안좋다. 

---



## 그룹 연산자

- 수학식과 똑같이 곱셈, 나눗셈 먼저 계산 
- 괄호로 묶인 식부터 계산



## 타입오브 연산자

- 값의 타입을 알아낼수 있는 연산자
- null 은 object 타입이다. 
- 선언되지 않은 식별자에 typeof 하면 에러가 날것 같지만  undefined 가 나온다. 

1. number

2. string

3. boolean

4. undefined

5. function

6. symbol

7. object 

   - null 

     - null의 typeof 는 object다. <- JS의 버그다. 

     - null 타입을 확인할때는 typeof 연산자 말고 === 를 사용해서 확인하자.

   - [ ]

   - { }



## 지수 연산자

2 ** 2; ==>  2<sup>2</sup> =4<br>math.pow(2, 2);  ==> 2<sup>2</sup> = 4

2 ** 2.5; ==> 2<sup>2.5</sup> = 5.65685424949238<br>math.pow(2, 2.5) ==> 2<sup>2.5</sup> = 5.65685424949238 

(-5)  ** 2; ==> -5 * -5 = 25 : 반드시 (-5)를 해야 에러가 안난다. (-5 ** 2 )하면 에러난다.

2 * 5 ** 2 ; ==> 2 * 25 = 50  : "** " 얘가 계산 우선순위 톱이다.



## 연산자의 부수 효과

- 부수 효과를 side effect라고 해석할때도 있고 부작용으로 해석할때도 있다.

- 변수의 값이 교체된다.
  - ++
  - --
  - delete