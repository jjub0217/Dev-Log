# 프로퍼티 어트리뷰트

- 내부 슬롯 
  - JS의 엔진을 구현하는 알고리즘을 설명하기 위해 ECMAScript에서 사용하는 의사 프로퍼티이다.
  - 감춰진 프로퍼티  라고 말할 수도 있다.
- 내부 메소드 : JS의 엔진을 구현하는 알고리즘을 설명하기 위해 ECMAScript에서 사용하는 의사 메소드이다. 

내부 슬롯과 내부 메소드는 [[ ]] 으로 감싸서 나타낸다.

----------

내부 슬롯과 내부 메소드는 원래 외부로 공개된 객체의 프로퍼티와 메소드가 아니다. 그래서 직접적으로 접근하거나 호출 할 수 있는 방법이 없지만, 간접적으로는 접근할 수 있다. 

1. [[prototype]] 이란 내부 슬롯에는 원래 직접적으로 접근하는것은 불가능하지만, _ _ prototype _ _이라는 것으로 간접적으로 접근이 가능하다.(모든 객체는 [[prototype]]) 이란 내부슬롯을 가지고있다)

   ```js
   const o ={};
   
   o. [[prototype]] // SyntaxError <- [[prototype]]이라는 내부 슬롯에 직접적으로 접근했더니 에러가 났다.
   o.__protot__ // object.prototype <- [[prototypr]] 이라는 내부 슬롯에 __proto__ 라는 것을 사용하여 
   간접적으로 점근한 상태이다. 에러가 안난걸 보니 정상적으로 동작하는것이다.
   ```

2. Object.getOwnPropertyDescript 라는 메소드를 사용하여 `프로퍼티 어트리뷰트` 라는 내부슬롯에 간접적으로 접근이 가능하며, 접근을 하면 프로퍼티 디스크립터 객체를 반환한다.

   - Object.getOwnPropertyDescript 라는 메소드를 호출하면, 첫번째 매개변수에는 객체의 참조를 전달하고, 두번째 매개변수에는 프로퍼티 키를 문자열로 전달한다.

   > __데이터 프로퍼티 어트리뷰트__(=내부 슬롯)
   >
   > 프로퍼티의 상태를 나타내는 것이다. 
   >
   > ① [[Value]] : 프로퍼티의 값을 나타낸다.
   >
   > - 프로퍼티 키를 통해 프로퍼티 값을 변경하면 [[Value]]에 값을 재할당한다.
   > - 프로퍼티가 없으면 프로퍼티를 동적 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다. 
   >
   > ② [[Writable]] : 값의 갱신이 가능한지, 프로퍼티 값의 변경이 가능한지 여부를 나타낸다.<br>     (Value 의 값을 쓸수 있느냐?)
   >
   > - [[Writable]] 값이 false인 경우에는 [[Value]] 의 값을 변경할수 없는 readOnly한 프로퍼티가 된다.
   > - 단, [[Writable]]이 true면 [[Value]] 의 변경과   [[Writable]]을 false로 변경이 가능하다.
   >
   > ③ [[Enumerable]] : 열거가 가능한지 여부를 나타낸다. 
   >
   > - for in 문으로 열거
   > - object 라는 객체의 keys로 열거 <br>(객체의 keys : 프로퍼티의 키들을 뽑아서 배열로 리턴해준다.)
   > - [[Enumerable]] 의 값이 false인 경우에는 for in문이나 Object.keys 메소드 등으로 열거할수 없다.
   >
   > ④ [[Configurable]] : 재정의가 가능한지 여부를 나타낸다.
   >
   > - [[Configurable]]값이 false인 경우에는, 해당 프로퍼티의 삭제, 값의 변경, 프로터피 재정의가 금지된다.
   >
   > > __프로퍼티 디스크립터 객체__
   > >
   > > 프로퍼티 어트리뷰트들을 모은 객체

   ```js
   const person = {
       name: 'Lee'
   };
   console.log(object.getOwnPropertyDescriptor(person,'name');
   // {value: "Lee", writable: true, enumerable: true, configurable: true}
   -----------------------------------------------------------------
   // value: "Lee" <- 프로퍼티의 값인 'Lee'를 문자열로 반환했다.
   // writable: true <- 객체 리터럴로 프로퍼티를 만들면 내부슬롯의 값은 기본적으로 true로 세팅이 된다. 
   //enumerable: true <- 객체 리터럴로 프로퍼티를 만들면 내부슬롯의 값은 기본적으로 true로 세팅이 된다. 
   //confiurable: true <- 객체 리터럴로 프로퍼티를 만들면 내부슬롯의 값은 기본적으로 true로 세팅이 된다.             
   ```

즉, 프로퍼티에는 프로퍼티 어트리뷰트라는 내부슬롯이 있고, 그렇기 때문에 프로퍼티 자체가 객체라는 뜻이다. <br>또한, 모든 객체는 [[Prototype] 이란 내부슬롯을 가지고있는 것이고, [[Value]], [[Writable]], [[Enumarable]]. [[Configuarable]], [[Prototype]] 각각의 내부슬롯을 __프로퍼티 키__라고 생각하면 된다. 



## 데이터 프로퍼티와 접근자 프로퍼티

### 데이터 프로퍼티

<u>" 키와 값으로 구성된 __일반적인 프로퍼티__ "</u>

- 프로퍼티가 생성될 때 [[Value]]의 값은 프로퍼티 값으로 초기화가 되며, [[writable]]과  [[Enumarable]], [[Configuarable]] 의 기본값인 true 로 초기화된다. <br>이는, 프로퍼티를 동적 추가하여도 마찬가지다.

### 접근자 프로퍼티(_ _ proto _ _)

<u>" [[Value]]을 가지고 있지 않고, 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 __접근자 함수로 구성된 프로퍼티__"</u>

__프로퍼티 처럼 생긴 함수__

① [[Get]] : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수

- 접근자 프로터피 키로 프로퍼티 값에 __접근하면__ `getter 함수`가 호출이 되고, 그 결과가 프로퍼티 값으로 반환된다. 

- 반드시 리턴을 해야 한다.

- 인수를 전달할 방법이 없기때문에 매개변수를 쓸 이유가 없다. 

  > __getter 함수__
  >
  > [[Get]] 이라고 하는 프로퍼티 어트리뷰트의 값인 함수 

```js
get fullname(){
    return `${this.firstName} ${this.lastName}`;
}
console.log(person.fullName);
```

② [[Set]] : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수

- 접근자 프로터피 키로 프로퍼티 값에 __저장하면__ setter 함수가 호출이 되고, 그 결과가 프로퍼티 값으로 반환된다. (프로퍼티 값을 할당하면 `setter 함수`가 호출이 된다.)

- 반드시 리턴이 없어야 한다.

- 반드시 인수를 받아야 하는데, 반드시 1개만 받아야 한다.

  >__setter 함수__
  >
  >[[Set]] 이라고 하는 프로퍼티 어트리뷰트의 값

```js
set fullName(name){
    [this.first, this.lastName] = name.split(' ');
}
person.fullName = 'Heegun Lee';
```

③ [[Enumerable]] : 열거가 가능한지 여부를 나타낸다. 

- for in 문으로 열거
- object 라는 객체의 keys로 열거 <br>(객체의 keys : 프로퍼티의 키들을 뽑아서 배열로 리턴해준다.)
- [[Enumerable]] 의 값이 false인 경우에는 for in문이나 Object.keys 메소드 등으로 열거할수 없다.

④ [[Configurable]] : 재정의가 가능한지 여부를 나타낸다.

- [[Configurable]]값이 false인 경우에는, 해당 프로퍼티의 삭제, 값의 변경이 금지된다.



예시 코드)

![캡쳐107](https://user-images.githubusercontent.com/62126380/82121912-652fad00-97cb-11ea-97a8-74dcf8e5ab73.PNG) 

![캡쳐108](https://user-images.githubusercontent.com/62126380/82121942-960fe200-97cb-11ea-9e0b-7cc98fc63023.PNG)   

 

** getOwnPropertyDecriptor 함수로 데이터 프로퍼티만 가져올수 있는게 아니라 <br>접근자 프로퍼티도 가져올수 있다.

```js
Object getOwnPropertyDecriptor(Object.prototype, '__proto__');
// {get: ƒ, set: ƒ, enumerable: true, configuarable: true}

Object.getOwnPropertyDecriptor(function(){}, 'prototype');
//  {value: {...}, writable: true, enumerable: true, configuarable: true}
```



## 프로퍼티 정의

### 프로퍼티 정의

- __새로운 프로퍼티를 추가__ 하면서 __프로퍼티 어트리뷰트를 명시적으로 정의__ 하거나,<br>기존 프로퍼티의 프로퍼티 어트리뷰트를 __재정의__ 하는 것을 말한다.
- __Object.defineProperty 메소드__를 사용하면 __프로퍼티의 어트리뷰트를 정의__ 할수 있다.
- Object.defineProperty 메소드는 한번에 하나의 프로퍼티만 정의할수 있지만,<br>Object.defineProperties 메소느는 여러개의 프로퍼티를 한번에 정의 할수 있다.

---

#### 데이터 프로퍼티 정의

![캡쳐109](https://user-images.githubusercontent.com/62126380/82138066-7e326f80-9858-11ea-8824-af081055a416.PNG)

- Object.defineProperty 메소드로 프로퍼티를 정의할때 프로퍼티 디스크립터 객체에서 일부의<br>프로퍼티를 생략하면 프로퍼티의 기본값이 적용된다.

  [[Value]] 의 기본값 : undefined<br>[[Writable]] 의 기본값 : false<br>[[Enumerable]] 의 기본값 : false<br>[[Configuarable]] 의 기본값 : false

----

#### 접근자 프로퍼티 정의

![캡쳐110](https://user-images.githubusercontent.com/62126380/82138079-9dc99800-9858-11ea-8802-d6ed4389caba.PNG) 

- Object.defineProperty 메소드로 프로퍼티를 정의할때 프로퍼티 디스크립터 객체에서 일부의<br>프로퍼티를 생략하면 프로퍼티의 기본값이 적용된다.

  [[Get]] 의 기본값 : undefined<br>[[Set]] 의 기본값 : undefined<br>[[Enumerable]] 의 기본값 : false<br>[[Configuarable]] 의 기본값 : false

  

## 객체 변경 방지

객체를 변경을 방지할수 있는 3가지 메소드가 있다.

1. 객체 확장 금지
2. 객체 밀봉
3. 객체 동결
   -  재할당이 안 이루어지는 상황에서 객체를 원시값처럼 쓰고자 할때에 객체동결(Object.freeze)를 통해서 객체를 얼려서 readOnly하게 만든다. 

==> ∴ 이런게 있다고만 알고 넘어갑시다. 왜냐면, 실무에서는 다 라이브러리를 쓰기 때문에 이것들이 있다고만 알고 넘어가자. *<- 라이브러리 사용하는게 훨씬 안전하다* 

---

---

---



# 생성자 함수에 의한 객체 생성

객체를 생성하는 방법은 다양하다.

1. 객체 리터럴을 사용하여 생성
2. Object 생성자 함수로 생성
3. 생성자 함수로 생성
4. Object.creat 라는 메소드로 생성

위 방법들 중 1번 객체 리터럴을 사용하여 생성하는 건 앞서 다룬 내용이므로, 이번엔 2번부터 시작하는 생성자 함수로 객체를 생성하는 방법을 알아보겠다. 

---



## Object 생성자 함수

__new연산자__ 와 함께 **Object 생성자 함수를 호출** 하면 **빈 객체를 생성**하여 반환한다.<br>이 이후에 **프로퍼티 또는 메소드를 추가**하여 빈 객체를 채워서, 내용을 채운 객체를 완성할 수 있다.

반드시 Object 생성자 함수를 사용해서 빈 객체를 생성해야 하는 것은 아니므로, 특별한 이유가 없다면<br>사용하지마라. 유용하지 않은 함수다.

---



## 생성자 함수 

- 생성자 함수 라고 함은, 객체를 만들어내는 목적을 가지고 있는 함수다

- new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수<br>즉, 생성자 함수에 의해 생성된 객체를 인스턴스라고 한다.

- 생성자 함수와 일반 함수가 생긴 것은 똑같이 생겼지만, 구분하기 위해서 생성자 함수의 함수 이름 첫글자를 대문자로 사용한다.( *<-소문자로 해도 Error는 나지 않지만, 구분을 해주자* )

- 생성자 함수에는 여러 빌트인 함수들이 있는데, 그 중에 우리가 만들수 있는 생성자 함수는<br>Object 생성자 함수 / String 생성자 함수 / Number 생성자 함수 / Boolean 생성자 함수 <br>/ Function 생성자 함수 / Array 생성자 함수/ Date 생성자 함수 / RegExp 생성자 함수 이다. 

  ```js
  1. String 생성자 함수를 사용하여 생성한 String 객체
  const strObj = new String('Lee');
  console.log(typeof strObj); // object (문자열 객체)
  console.log(strObj); // String {"Lee"}
  
  2. Number 생성자 함수를 사용하여 생성한 Number 객체
  const numObj = new Number(123); 
  console.log(typeof munObj); // object(number 객체)
  console.log(numObj); // Number {123}
  
  3. Boolean 생성자 함수를 사용하여 생성한 Boolean 객체
  const booObj = new Boolean(true);
  console.log(typeof booObj); // object(boolean 객체)
  console.log(booObj); // Boolean {true}
  
  4. Function 생성자 함수를 사용하여 생성한 Function 객체
  const func = new Function('x', 'return x * x');
  console.log(typeof func); // object(function 함수 객체)
  console.log(func); // ƒ anonymous(x)
  
  5. Array 생성자 함수를 사용하여 생성한 Array 객체
  const arr = new Array(1, 2, 3);
  consoel.log(typeof arr); // object(array 객체)
  console.log(arr); // [1, 2, 3]
  
  6. Date 생성자 함수를 사용하여 생성한 Date 객체
  const date = new Date();
  conosole.log(typeof date); // object(date 객체)
  console.log(date); // Sun May 17 2020 21:17:00 GMT+0900 
  
  7. RegExp 생성자 함수를 사용하여 생성한 RegExp 객체 
  ```

- 객체 리터럴에 의한 객체 생성은 단 하나의 객체만 생성하기 때문에 프로퍼티 구조가 똑같으면 매번 똑같은  객체를 만들어야 하므로 비효율 적이다 -> 프로퍼티 구조가 똑같은 객체라면, 생성자 함수로 <br>객체를 짧고 간결하게 만들 수 있다.  <br>(대부분 객체마다 프로퍼티 값이 다를수 있지만 메소드는 내용이 동일한 경우가 일반적이기 때문이다.)

  - 객체 리털

  

  ![캡쳐111](https://user-images.githubusercontent.com/62126380/82146669-e9933600-9886-11ea-8535-faedbc3b1eb4.PNG) 
  
  위 코드에서 볼수 있듯이,
  
1. 생성자 함수 내부에서의 this 
     - 생성자 함수가 미래에 생성할 인스턴스를 가리킨다.
     - this에는 우리가 필요로 하는 프로퍼티를 담는다.(그러므로, this 뒤에는 꼭 프로퍼티가 와야 한다)
     - 생성자 함수 내부에서의 this는 문맥에 따라서 가리키는 값이 달라진다. 
  
  2. news 연산자를 통해서 생성자 함수를 호출했다. 
     
     - new를 쓰지 않고 호출하면 undefined 가 나오고, new를 붙여야 값이 호출된다.
     
       (new 연산자와 함께 호출하면 해당 함수는 행성자 함수로 동작하지만,<br>new 연산자와 함께 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다.)
     
        

### 생성자 함수에 의한 객체 생성 방식의 장점

생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스다. <br>객체 리터럴 내부의 메소드 내부에서 사용한 this는 그 메소드를 호출한 객체다. 

그러면 일반함수에서 this를 쓸수 있을까? <br>쓸 수는 있지만, 그때의 this 는 전역객체를 가리킨다.  

![캡쳐112](https://user-images.githubusercontent.com/62126380/82152629-97114400-989d-11ea-9fbe-51373715b52d.PNG)  



### 생성자 함수의 인스턴스 생성 과정

1. 인스턴스(객체) 생성과 this 바인딩

   - 암묵적으로 빈 객체가 생성되고, 생성된 인스턴스, 즉 객체는 this에 `바인딩`된다.

   - 이 처리는 런타임 이전에 실행된다. 

     > __바인딩__
     >
     > 식별자와 값을 연결하는 과정

2. 인스턴스 초기화
   
   - this에 바인딩되어 있는 인스턴스를 초기화한다
3. 인스턴스 반환
   
   - 생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된, this가 암묵적으로 반환된다.

![캡쳐113](https://user-images.githubusercontent.com/62126380/82153560-22410880-98a3-11ea-8dad-b666ab5a5138.PNG) 

- 3번의 과정에서 명시적으로 다른 객체를 return  하면 반환해야 하는 this 가 반환되지 못하고, <br>개발자 본인이 명시작 객체가 반환된다.

- 3번 과정에서 명시적으로 원시값을 return 하면 원시값 반환은 무시되고 원래 반환해야 하는 this가 반환된다.

  ==> 따라서 생성자 함수 내부에서 return 문은 절대 명시적으로 쓰면 안된다.  

위에꺼 무조건 외워야 한다. 디스가 가리키는 값이 중요하다.

```js
function foo(){}

foo();
new foo();
```



### 내부  메소드 : [[Call]] 과 [[Construct]]

누차 얘기하지만 함수는 객체다. <br>

<img src = "https://user-images.githubusercontent.com/62126380/82228620-529cab80-9964-11ea-9848-b2460e4693df.PNG"> 

- 함수도 객체이므로, 호출이 가능하다는 함수의 특징을 갖고 있을뿐 아니라, <br>프로터리와 메소드를 갖고있다는 객체의 특징을 갖고있으므로 일반 객체와 동일하게 동작이 가능하다.  <br>__여기서 주의할점은, 일반 객체는 호출을 할수 없지만, 함수는 호출을 할수 있다는 점이다.__         
- [[Call]] 과 [[Construct]] 라는 내부 메소드를 갖고 있다.        



### new 연산자

일반함수와 생성자 함수에 특별한 차이는 없다.

<table>
        <tr align ="center" span style="color:pink">
        <th>[[Call]]</th>
            <th>[[Construct]]</th>
            <th>Non-Construct</th>
            </tr>
    <tr align = "center">
    <td>일반 함수로서 호출</td>
    <td>new 연산자와 함께 <br>생성자 함수로서 호출</td>
            <td rowspan="2">생성자 함수로서 <br>호출할수 없는 함수</td>
    </tr>
    <tr align = "center">
    <td>내부 메소드 <br>[[Call]]이 호출된다.</td>
    <td>내부 메소드 <br>[[Construct]]가 호출된다</td>
    </tr>
        <tr align = "center">
    <td>내부 메소드 [[Call]을 <br>갖는 함수 객체</td>
    <td>내부 메소드 [[Construct]]을<br> 갖는 함수 객체</td>
                <td>내부 메소드 [[Construct]]을<br> 갖지 않는 함수 객체</td>
    </tr>
        <tr align = "center">
    <td>callable 이라고 한다.</td>
    <td>constructor 이라고 한다.</td>
                <td>non-constructor 이라고 한다.</td>
    </tr>
    <tr align = "center">
    <td>모든 함수 객체는 내부 메소드<br> [[Call]]을 갖고 있으므로<br> 호출할수 있다. </td>
    <td>함수 선언문, 함수 표현식,<br> 클래스</td>
                <td>메소드(ES6 메소드 축약표현), 화살표 함수</td>
    </tr>
</table>

==> 모든 함수 객체는 호출할 수 있지만 모든 함수 객체를 생성자 함수로서 호출할 수 있는 것은 아니다.



### new.target

파스칼 케이스를 써서 생성자 함수를 썼다라는걸 알린다 해도 인간이란 늘 실수를 하기 마련이다.<br>이를 방지하기 위하여 ES6 에서는 `new.target` 이라는 방식을 지원한다.

>this 와 유사하게 constructor 인 모든 함수 내부에서 암묵적인 지열 변수와 같이 사용되며
>
>메타 프로퍼티라고도 부른다.

- this 처럼 함수 내부에서 암묵적으로 사용할수 있는 식별자 같은 역할을 한다. <br>즉, new 연산자와 함께 그 함수가 호출되었는지 안되었는지를 식별해낼 수 있는 기능이 있다는 것이다.
- new 연산자와 같이 생성자 함수로서 호출이 되면 함수 내부에서의 new.target은 함수 자신을 가리킨다.만약에 new와 함께 호출되지 않으면 new.target은 undefined 를 가리킨다.  
- 대부분의 빌트인 생성자 함수들은 new 연산자와 함께 호출되었는지 안되었는지 확인하고, <br>적절한 값을 반환하긴 한다. <br>하지만, <br>빌트인 생성자 함수들 중에 String, Number, Boolean 생성자 함수들이 new 연산자와 함께 호출되었다면 String 객체를 생성하고 반환하지만, new 연산자 없이 호출하면 문자열, 숫자, 불리언 값을 반환한다. (타입변환만 한다는 뜻이다.)

---

---

#### 1. 알아두기!!

```js
1번)

function Person(name) {
this.name = naeme;
}
const me = new Person();
```

```js
2번)

const me = new Person('Lee');
function Person(name) {
this.name = naeme;
}
```

1번 코드는 Person 생성자 함수로서 호출을 함수 선언문 아래에 한거고,<br>2번 코드는 Person 생성자 함수로서 호출을 함수 선언문 위에 한것이다.

함수 선언문은 런타임 이전에 실행되니까 둘다 동작은 똑같지만,  2번 코드처럼 코딩하면 안된다. 



#### 2. 알아두기!!

```js
function Person(name) {
this.name = name;
this.sayHi = function () {    
    console.log(`Hi! my name is ${this.name}.`);
    };
}
const me = new Person('Lee');
const you = new Person('Kim')
console.log(me.sayHi === you.sayHi); //false
```

도출되는 결과값이 false 로 나오는 이유는, <br>me 에 할당된 새로운 Person 생성자 함수의 메모리 주소와<br>you에 할당된 또 다른 새로운 Person 생성자 함수의 메모리 주소가 다르기 때문에 false 라는 결과값이 도출된것이다.



#### 3. 알아두기!!

```js
function Person(name) {
this.name = name;
this.sayHi = function () {    
    console.log(`Hi! my name is ${this.name}.`);
    };
}
const me = new Person('Lee');
const you = new Person('Kim')
```

위 코드는 문제점이 있는 코드이다. 

생성자 함수 객체를 새로 만들때마다 sayHi 부분이 쓸데없이 계속 중복으로 만들어 지는 중복의 문제점이 있는 코드인것이다.

-> 그래서 Person 생성자 함수 밖에서 프로토타입 메소드를 만들고, 거기에 sayHi를 넣어주면 된다.<br>아래 코드가 중복의 문제점을 해결한 코드이다. 

```js
function Person(name) {
this.name = name;
}
Person.prototype.sayHi = function () {    
    console.log(`Hi! my name is ${this.name}.`);
    };

const me = new Person('Lee');
const you = new Person('Kim')
```

