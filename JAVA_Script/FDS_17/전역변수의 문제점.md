# 전역변수의 문제점

들어가기에 앞서

><u>**전역변수의 무분별한 사용은 위험하다.**</u> **<u>그러니까 지역변수를 써야 한다.</u>**

---

## 전역변수의 문제가 뭐길래, 지역변수를 써야 하는 걸까?

① 전역변수의 <u>**생명 주기**</u>는 길기 때문이다. 

`변수는 선언에 의해 생성되고 할당을 통해 값을 갖고, 언젠가는 소멸된다. 변수에 생명 주기가 없다면 한번 선언된 변수는 프로그램을 종료해야(윈도우창을 닫아야) 소멸된다.`

- var 키워드로 선언한 전역변수는 전역객체(window 또는 global)의 프로퍼티가 되기 때문에, var 키워드로 선언한 전역변수의 생명주기는 전역객체의 생명주기와 똑같다. 그러므로, window 창을 닫아야만 전역변수는 소멸된다. 

- 변수가 소멸되지 않거나(윈도우 창을 닫지 않는다면), 생명주기가 길다면 메모리 공간을 계속 차지하게 된다.

①-① 지역변수의 **<u>생명 주기</u>**는 짧다.

- 지역 변수는 함수가 호출되어야 생성이 되고, 함수가 종료가 되면 그때 소멸이 된다. 즉, 지역 변수는 함수의 생명주기와 일치한다. 

  ![33d](https://user-images.githubusercontent.com/62126380/93667215-0a7ec880-fabf-11ea-9ce5-2ba7962779f1.JPG) 

- 지역변수는 함수가 호출된 바로 직후에, 런타임 이전에 지역변수의 선언이 실행된다. (변수 호이스팅이 지역 스코프 내에서 이루어진다.)

- 윈도우창을 닫지 않으면 계속 살아있는 전역 변수들보다 지역변수의 생명주기가 짧은 것이다. <br>-> 이는 메모리 소모도, 추적의 어려움도 적어진다. 따라서 지역변수는 금새 태어났다가 금새 죽는다. 

② 전역변수는 <u>**암묵적 결합**</u>을 허용하기 때문이다.

`전역 변수는 어디서든지 참조(사용)가 가능하고, 변경할수 있다는 의미이다.` 

- 전역변수는 어디서든지 참조(사용)이 가능하기 때문에, 변수의 상태를 변경할수 있는 사이 시간이 길다. <br>-> 이는, 오류가 발생할 확률이 높아진다는 것을 의미한다.

②-① 지역변수는 지역스코프에서만 참조(사용)가 가능하고, 변경할수 있다. 

- 지역변수는 지역에서만 참조할수 있기 때문에, 변경이 되는 가능성이 적다.<br>그래서 지역변수가 전역변수보다 훨씬 안전하다. 
  ![캡쳐97](https://user-images.githubusercontent.com/62126380/81494616-3b671980-92e5-11ea-9b2d-c2a6f4267eb6.PNG) 

③ 전역변수는 스코프 체인 상에서 <u>**제일 상위 스코프**</u>를 차지하는 종점에 존재하기 때문이다.

- 변수를 참조(사용)하는 코드가 런타임에 실행되면, JS엔진은 그 변수를 스코프 체인을 통해 찾게 되는데, 상위로 스코프 체인을 따라서 해당 변수를 검색하고 검색하는데, 전역변수는 제일 상위 스코프에 있기 때문에 가장 마지막에 검색된다. <br>-> 이는, 전역 변수의 검색 속도가 가장 느리다는 것이다.

④ <u>**네임스페이스**</u>가 오염되기 때문이다.

`식별자들이 기억되어지는 공간`

`하나의 네임스페이스에서는 하나의 이름이, 단 하나의 개체만 가리킨다.`

- 전역변수가 위치해있는 지점이 제일 상위 스코프인, 전역스코프인건데, 디렉토리가 분리되어있다고 해도 **제일 상위 스코프인 전역 스코프를 공유**하고 있기 때문에 식별자들이 중복될 가능성이 있다.  <br>-> 이는 예기치 못한 결과를 가져올수 있다.  

## 전역 변수 사용 억제 방법

전역 변수를 반드시 사용해야 하는 이유가 없다면 지역 변수를 사용해야 한다. <br>그러면 이렇게 전역 변수를 자제하고 다른 방법을 쓸수 있는 것들이 뭐가 있을까?

1. <u>즉시 실행 함수를 사용한다.</u>

   - 즉시 실행 함수는 함수 정의와 동시에 호출되면서, 단 한번만 호출이 된다. 즉, 모든 코드를 즉시 실행 함수로 만든다면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. 

   ```javascript
   (function(){
       var foo = 10; // <- foo 는 즉시 실행함수 내부에 있으므로, 지역 변수가 된다. 
   })();
   console.log(foo) // <- 이렇게 전역에서 foo 를 참조해도, foo 는 지역변수가 되었기 때문에 전역에서 참조할수 없다. 
   ```

2. <u>전역에 네임 스페이스 객체를 만든다.</u>

   - 네임 스페이스 객체를 생성하면 네임 스페이스의 오염을 막아서, 식별자 중복의 충돌 문제를 해결할수 있다.
     하지만, 네임 스페이스 객체 자체가 전역변수에 할당되는 것이므로 추천하지는 않는다. 

     ```javascript
     // 1. 전역변수처럼 사용하고 싶은 변수를, 프로퍼티로 만드는 방법
     
     var boyFriend = { }; // <- 네임스페이스 역할을 담당하는 객체 생성
     
     boyFriend.name = '준호'; // <- 전역변수 boyFriend가 객체의 프로퍼티 키가 된다.
     
     console.log(boyFriend) // {name: '준호'}
     console.log(typeof boyFriend) // object
     console.log(boyFriend.name) // '준호'
     
     // 2. 기존 네임스페이스 객체 안에, 다른 네임스페이스 객체를, 프로퍼티 키로 만드는 방법 (이렇게 하면 계층적 구조로 만들수 있다.)
     
     boyFriend.person = { // <- boyFriend 라는 객체에 person 이라는 프로퍼티 키가 생성된다. 
         address: '청담동',
         assigned: '2pm'
     } // <- person 이라는 프로퍼티 키의, 프로퍼티 값이 생성되었다.
     
     console.log(boyFriend) // { name: '준호', person: { address: '청담동', assigned: '2pm' } }
     console.log(typeof boyFriend) // object
     console.log(boyFriend.name) // '준호'
     console.log(boyFriend.person.address) // 청담동
     ```

3. <u>모듈 패턴을 만든다.</u>

   - 변수 & 함수나 메서드를 즉시 실행함수 몸체 내부 영역 안에서 선언하고 정의하는 방법

   - 전역 변수를 억제 시킬수 있다.

   - `캡슐화`를 구현할수 있다. 

     > - 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할수 있는 동작인 메서드를 하나로 묶는 방법
     > - 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하는 정보 은닉을 할 수 있다.

   - 원하지 않는 외부의 접근으로부터 내부를 보호하는 기능을 한다. 
   - 클로저를 기반으로 동작한다. 

   ![3d](https://user-images.githubusercontent.com/62126380/93707213-7452ad00-fb67-11ea-8dfc-cd0dcbdff68b.JPG) 

   

4. <u>ES6 모듈을 사용한다</u>

   - 파일 자체의 독자적인 모듈 스코프를 제공한다.
   - var 키워드로 변수를 선언해도 전역 변수가 아니게 되고, 전역객체인 window 의 프로퍼티도 아니게 된다.  
   - HTML 파일 안에 script 태그 를 쓰고, script 태그의 속성과 값으로 **<u>type = "module"</u>**이라고 하면 ES6 모듈이 생성된다. 
   - ES6 모듈의 파일 확장자는 mjs 를 권장한다.
   - 아직 현 단계에서는 불안해서 아직 현업에서 대중적으로 사용하고 있지는 않다.