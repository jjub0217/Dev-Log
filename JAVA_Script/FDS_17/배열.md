# 배열

<u>들어가기에 앞서...</u>

>- 배열 : 여러개의 값을 순차적으로 나열한 자료구조
>
>- Javascript 에서의 배열과 일반 컴퓨터 언어에서의 배열은 다르다. 
>
>  1. **일반 자료구조에서 말하는 일반적인 배열**
>
>     - 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 밀집하여 나열된 자료구조
>
>     - 하나의 데이터 타입으로 통일되어있다.
>
>       ![array](https://user-images.githubusercontent.com/62126380/98920081-01383800-2513-11eb-89b1-550a13947299.jpg)
>
>     - 장점
>
>       - 산술식 연산으로 한번에 요소에 빠르게 접근할수 있다.( 효율적으로 요소에 접근할수 있다)
>         - 인덱스가 0 인, 요소의 메모리 주소 : 1000 + 0 (인덱스) * 8(요소의 바이트) = 1000
>         - 인덱스가 1인, 요소의 메모리 주소 : 1000 + 1 (인덱스) * 8(요소의 바이트) = 1008
>         - 인덱스가 2인, 요소의 메모리 주소 : 1000 + 2 (인덱스) * 8(요소의 바이트) = 1016
>
>     - 단점 
>
>       - 특정한 요소를 검색하는 경우에는 특정 요소를 발견할때까지 처음부터 순차적으로 검색해야 하므로,<br>특정 요소를 검색할때는 검색 속도가 느리다.
>       - 배열에, 특정 요소를 삽입하거나 삭제하는 경우에는, 일반적인 배열은 요소가 연속적으로 나열되기 때문에, <br>연속성을 유지하기 위해 요소를 이동시켜야 한다.
>
>  2.  **Javascript에서 말하는 배열**
>
>     - 일반적인 배열의 동작을 흉내낸 특수한 **<u>객체</u>**다.
>
>     - 해시테이블로 구현된 객체라서, 인덱스로 요소에 접근하려면 일반적인 배열보다 검색속도가 느리다.
>
>     - 특정 요소를 검색하거나, 삽입하거나, 삭제하는 경우에, 일반적인 배열보다 성능이 빠르다.
>
>     - 배열 내부의 값으로 오는 요소들로 객체가 올수도 있는데, 그 객체의 프로퍼티는 동일한 형식의 배열이 대부분이다. 
>
>       ```javascript
>       [
>       	{ id: 1, content: HTML, completed: true}
>           { id: 2, content: CSS, completed: false}
>           { id: 3, content: JAVASCRIPT, completed: true}
>       ]
>       // <- 배열안의 객체들의 프로퍼티들은 동일한 형식으로 되어있는 배열들이 javascript 에서는 가능하다.
>       ```
>
>     - 각각의 메모리 공간은 동일한 크기를 갖지 않아도 된다. 
>
>     - 희소배열을 문법적으로 허용한다. 
>
>       >  <u>희소배열</u>
>       >
>       > - 배열의 요소들이 연속적으로 나열되어 있지 않아도 되는 배열
>       >
>       > - 희소배열은 만들지 않는 것이 좋으며, 같은 타입의 요소를 연속적으로 위치하는 것이 좋다. 
>       >
>       > - 희소배열의 length 값이 실제 요소의 개수보다 언제나 크다. 
>       >
>       >   ```javascript
>       >   // 1번째 예제
>       >   const arr = [ 21, 34, 67, 88];
>       >   console.log(arr.length) // 4
>       >   
>       >   arr.length = 6; /* <- arr의 length 프로퍼티 값에, 현재 length 프로퍼티 값인 4 보다 
>       >   					  큰숫자인 6을 임의로 명시적으로 할당 */
>       >   
>       >   console.log(arr) // [ 21, 34, 67, 88, <2 empty items> ] : 희소배열
>       >   console.log(arr[4]) /* undefined <- arr 이라는 배열에서 4번째 인덱스에 접근하였지만,
>       >   undefined 가 출력된다.
>       >   // └> 존재하지 않는, 배열의 요소에 접근하였기 때문에 undefined 가 출력된다.*/
>       >   
>       >   
>       >   // 2번째 예제
>       >   const arr = [1, , , , 3] // <- 요소는 존재하지만, 값을 할당하지 않은 배열인 arr
>       >   console.log(arr.length); // 5 
>       >   
>       >   console.log(arr[1]); /* undefined <- arr 이라는 배열에서 1번째 인덱스에 접근하였지만,
>       >   undefined 가 출력된다. 
>       >   // └> 값이 없는 요소의 인덱스에 접근하였기 때문에 undefined 가 출력된다. */
>       >   ```

---

## Javascript에서의 배열

<u>들어가기에 앞서...</u>

> - 요소 
>   - 배열이 가지고 있는 값
>   - 값으로 인정하는 모든 것은 배열의 요소값이 될수 있다. 
> - 인덱스 
>   - 배열에서, 요소들이 자신의 위치를 나타낼수 있는, 0 이상의 정수를 인덱스라고 한다. 
>   - 요소에 접근할때는 인덱스와 대괄효 표기법을 사용하여 접근한다. 

---

### 배열 생성 방법

---

#### 1.배열 리터럴

- 가장 일반적이고 간편한 배열 생성 방식
- 0개 이상의 요소를, 쉼표로 구분해서 대괄호 [ ] 로 묶는다. 
- 프로퍼티 키가 없고, 값인 요소들만 존재한다. 
- 배열리터럴 안의 요소를 생략하면 희소배열이 만들어진다. 

#### 2.Array 생성자 함수 ( .of( ) / .from( ) 의 정적메서드 포함)

- 전달된 인수의 개수에 따라, 다르게 동작한다. 

- Array.of( ) 메서드 와 Array.from( ) 메서드를, 정적메서드로 갖고 있다. 

  - Array.of( ) 메서드 :  전달된 인수를, 배열의 요소로 하는 배열을 생성한다.

  - Array.from( ) 메서드 : 전달된 인수(유사배열 객체 나 문자열로 이루어진 이터러블 객체)를 배열의 요소로 하는<br>배열로 변환하여, 배열을 생성한다.<br>- 값을 만들면서 배열을 만들때 주로 사용한다.

    >  <u>유사배열 객체</u>
    >
    >  인덱스를 프로퍼티 키로 하고, 해당 프로퍼티 키에 값을 할당하면 인덱스를 생성한. 그리고 , 
    >
    >  length 프로퍼티 키를 명시적으로 할당하면, 배열의 길이를 가지게 되어 순회할수 있는 "유사배열객체"가 만들어진다. 
    >
    >  
    >
    >  <u>이터러블 객체</u>
    >
    >  반복문으로 순회할수 있으며 스프레드 문법과 디스트럭처링 할당을 할수 있게 되는 객체이다.
    
    
    
    >유사배열 객체 와 이터러블 객체를 배열로 반환하는 방법
    >
    >1. slice( ) 메서드
    >2. Array.from( ) 메서드
    >3. 스프레드 문법
    >
    >```javascript
    >// 1번째 예시
    >const arr1 = [{length: 2, 0: 'string1', 1: 'string2'}]
    >
    >// const result1 = Array.prototype.slice.call(arr1); 
    >// └> [ { '0': 'string1', '1': 'string2', length: 2 } ] <--------┐
    >// const result1 = Array.from(arr1) 						     │
    >// [ { '0': 'string1', '1': 'string2', length: 2 } ] <-----------┤ 같은 코드이다.
    >const result1 = [...arr1]; // 									 │ 	
    >// [ { '0': 'string1', '1': 'string2', length: 2 } ] // <--------┘
    >
    >console.log(result1);
    >
    >// -------------------------------------------------------------------------------
    >
    >// 2번째 예시
    >const arr2 = '강주현';
    >
    >// const result2 = Array.prototype.slice.call(arr2); // [ '강', '주', '현' ] <----┐
    >// const result2 = Array.from(arr2) // [ '강', '주', '현' ] <---------------------┤ 같은 코드이다.
    >const result2 = [...arr2]; // [ '강', '주', '현' ] // <---------------------------┘
    >
    >console.log(result2);
    >```

- 전달된 인수가 1개 이며, 숫자일때 : **<u>해당 인수가 length 프로퍼티 값이 되는 희소배열을 생성한다</u>**. 

  ```javascript
  const arr = new Array(10);
  console.log(arr.length); // 10
  
  console.log(arr); // [ <10 empty items> ] : length 프로퍼티키의 값이, 전달된 인수가 된 희소배열 
  ```

- 전달된 인수가 없을 때 : 빈 배열을 생성한다.

  ```javascript
  // Array 생성자 함수로 배열을 생성하는 경우
  const arr = new Array();
  console.log(arr.length); // 0
  
  console.log(arr); // [ ] : 빈 배열을 생성
  
  // Array.of( ) 메서드로 배열을 생성하는 경우
  const arr2 = Array.of();
  console.log(arr2.length); // 0
  
  console.log(arr2); // [ ] : 빈 배열을 생성
  ```

- 전달된 인수가 2개 이상일 때 :  전달된 인수를 요소의 값으로 갖는 배열을 생성한다.

  ```javascript
  // Array 생성자 함수로 배열을 생성하는 경우
  const arr = new Array(10, 33);
  console.log(arr.length); // 2
  
  console.log(arr); // [ 10, 33 ]
  
  // Array.of( ) 메서드로 배열을 생성하는 경우
  const arr = Array.of(33, 45);
  console.log(arr.length); // 2
  
  console.log(arr); // [ 33, 45 ]
  ```

- 전달된 인수가 숫자가 아닐 때 : 전달된 인수를 요소의 값으로 갖는 배열을 생성한다. 

  ```javascript
  // Array 생성자 함수로 배열을 생성하는 경우
  const arr = new Array('james');
  console.log(arr.length); //  1 
  
  console.log(arr); // [ 'james' ]
  
  // Array.of( ) 메서드로 배열을 생성하는 경우
  const arr = Array.of('string')
  console.log(arr.length); // 1
  
  console.log(arr); // [ 'string' ]
  
  // Array.from( ) 메서드로 배열을 생성하는 경우
  // 1번째 
  const arr = Array.from({length: 2, 0: 'string1', 1: 'string2'})
  console.log(arr.length); // 2
  
  console.log(arr); // [ 'string1', 'string2' ]
  
  // 2번째 
  const arr = Array.from('string')
  console.log(arr.length); // 6
  
  console.log(arr); // [ 's', 't', 'r', 'i', 'n', 'g' ]
  ```

- new 연산자 사용하지 않고 호출해도 배열을 생성하는 생성자 함수로 동작한다. 

  ```javascript
  const arr = Array(33, 55, 6);
  console.log(arr); // [ 33, 55, 6 ]
  console.log(arr.length); // 3
  ```

### 프로퍼티

---

- javscript 의 배열은, 인덱스를 나타내는 문자열을 프로퍼티 키로 가지며, <br>배열의 요소를  프로퍼티 값으로 가진다.

  - 객체에서는 인덱스와 요소로 이루어져있지 않고, 프로퍼티 키와 프로퍼티 값으로 이루어져있다. 

  - 객체는 프로퍼티 값이 순서를 가지고 있지 않고, length 프로퍼티를 가지고 있지 않다. 

    > 원래 객체는 length 프로퍼티를 가지고 있지 않은것이 일반적이지만, length 프로퍼티를 가지고 있는 객체가 있긴하다<bR>: 유사배열 객체

- length 라는 프로퍼티 키를 가지고 있다. 

#### length 프로퍼티

---

- length 라는 프로퍼티 키를 갖고 있는 객체는 반복문을 통해 순회하며 접근할수 있다(순서대로, 순차적으로 요소에 접근할수 있다.) 

- length 라는 프로퍼티 키의 값은, 배열의 길이를 나타내며,  0 이상의 정수이다. 

- length 프로퍼티 키는, 배열에 요소를 새로 추가하거나 삭제하면 바뀐다.

  - 현재의 length 프로퍼티 키의 값에,  현재의 length <u>프로퍼티 키의 값보다 **작은 숫자를 임의로 명시적으로 할당**</u>하면,<br>배열의 길이(length 프로퍼티 키의 값) 가 줄어든다.<br>또한, 할당하면 숫자만큼의 인덱스의 요소들만 남게 된다. 

  - 현재의 length 프로퍼터 키의 값에, 현재의 length <u>프로퍼티 키의 값보다 **큰 숫자를 임의로 명시적으로 할당**</u>하면, <br>값이 변경되기는 하지만, 실제로 길이가 늘어나지 않는다. 

    ```javascript
    const arr = [ 21, 34, 67, 88];
    console.log(arr) // 4
    
    arr.length = 6; // <- arr의 length 프로퍼티 값에, 현재 length 프로퍼티 값보다 큰숫자를 임의로 명시적으로 할당
    
    console.log(arr) // [ 21, 34, 67, 88, <2 empty items> ] : 희소배열
    console.log(arr[4]) // undefined <- arr 이라는 배열에서 4번째 인덱스에 접근하였지만, undefined 가 출력된다.
    // └> 존재하지 않는, 배열의 요소에 접근하였기 때문에 undefined 가 출력된다.
    
    // 현재의 length 프로퍼티의 값보다 큰 숫자를, 현재의 length 프로퍼티 키에 값으로 할당하면 
    // 그 차이의 숫자만큼 empty 요소가 배열에 들어가게 되어, 실제로 배열의 길이가 늘어나지 않게 된다. 
    // 이때 희소배열이 만들어진다. 
    ```

### 배열의 요소

---

앞서 말했다시피,

배열의 요소는 <br>① 배열이 가지고 있는 값<br>② 값으로 인정하는 모든 것은 배열의 요소값이 될수 있다.

라고 했고,

배열의 인덱스는<br>① 배열에서, 요소들이 자신의 위치를 나타낼수 있는, 0 이상의 정수<br>② 요소에 접근할때는 인덱스와 대괄호 [ ] 표기법을 사용하여 접근한다. 

라고 했다. 

#### 참조

---

- 인덱스로 요소를 참조할수 있다. <br>즉, 인덱스는 요소(값)을 참조할수 있다는 의미에서, 객체의 프로퍼티 키와 같은 역할을 한다. 

- 존재하지 않는 요소에 접근하면 undefined 가 반환되며, <br>희소배열의 존재하지 않는 요소를 참조해도 unedfined 가 반환된다.

  ```javascript
  const boyFriend = ['오세진', '이준호', , '양요섭']
  
  console.log(boyFriend[1]); // 이준호 <- 1번째 인덱스에 위치하고 있는 요소 참조
  console.log(boyFriend[2]); /* undefined 
   <- 2번째 인덱스에 위치하고 있는 요소 참조 : 존재하지 않는 요소에 참조하였기 때문에 undefined 반환*/
  ```

#### 추가 

---

- 객체가 프로퍼티 키를 동적으로 추가할수 있는 것처럼, 배열도 요소를 동적으로 추가할수 있다. 

- 존재하지 않는 인덱스를 사용해서, 해당 인덱스에 새로운 값을 할당하면 새로운 요소가 추가되며, 동시에 기존 length 프로퍼티값도 바뀐다.

  ```javascript
  const boyFriend = ['오세진', '이준호', '양요섭']
  console.log(boyFriend.length); // 3
  
  boyFriend[3] = '장우영' // <- 존재하지 않는 인덱스를 사용하여, 해당 인덱스에 새로운 값을 할당
  
  console.log(boyFriend); // [ '오세진', '이준호', '양요섭', '장우영' ]
  console.log(boyFriend.length); // 4 <- length 프로퍼티 값이 바뀌었다. 
  ```

- **0 이상의 정수가 아닌 값을 인덱스처럼 사용**하면 요소가 새로 추가 되는 것이 아니라, **<u>프로퍼티 키가 새로 추가</u>**된다.  

  ```javascript
  const myIdols = ['이준호', '양요섭']
  
  myIdols['age'] = 30;
  myIdols.address = '청담동';
  myIdols[2.5] = '세대';
  myIdols[-2] = '현재 군대간 멤버';
  
  
  console.log(myIdols);
  /*
  [
   '이준호',
    '양요섭',
    age: 30,
    address: '청담동',
    '2.5': '세대',
    '-2': '현재 군대간 멤버'
  ]
  */ 
  console.log(myIdols.length); // 2 <- length 프로퍼티 값에는 영향을 주지 않는다.
  ```

#### 삭제

---

- delete 연산자를 사용하면 요소를 삭제할수 있다. 하지만, delete 연산자를 사용하여 요소를 삭제하게 되면, 해당 배열은 <br>희소배열이 된다. 

  ```javascript
  const myIdols = ['이준호', '양요섭']
  console.log(myIdols.length); // 2 <------------------------------------------------------┐
  //																						 │
  console.log(myIdols[1]); // 양요섭														   │
  delete myIdols[1]; // <- 1번째 인덱스에 위치하고 있는 요소를 삭제						     │
  console.log(myIdols); // [ '이준호', <1 empty item> ] : 희소배열이 되었다.                  │
  //																						 │
  console.log(myIdols.length); // 2 <- 요소를 삭제하여도 배열의 길이는 바뀌지 않는다. <---------┘
  ```

### 배열의 메서드

---

① 정적 메서드

② 뮤테이터(mutator) : 원본 배열을 바꾸는 메서드

③ 억세서(accessor) : 원본 배열 안바꾸고 새로운 배열을 생성하여 반환하는 메서드

④ 그냥 메서드

![method](https://user-images.githubusercontent.com/62126380/100091779-6e938380-2e98-11eb-80f9-b7c438afd9e3.jpg)     

---

#### 정적 메서드 ( isArray( ) )

---

- 배열인지 아닌지 검사하는 메서드
- 전달된 인수가 배열이면 true / 배열이 아니면 false 를 반환한다. 

```javascript
const string = 'string';
const myIdols = ['이준호', '장우영']

const result1 = Array.isArray(string);
const result2 = Array.isArray(myIdols);

console.log(result1, result2 ); // false true 
// └> result1 = false : 배열이 아니다 
// └> result2 = true : 배열이다 
```

#### 그냥 메서드

---

##### ① indexOf( ) : 특정요소의 인덱스 검색

- 원본 배열안에 특정요소가 존재하는지 확인할때 유용하게 사용된다. : inclueds( ) 메서드 사용하는것이 더 좋다.  

- 검색하려는 요소의 인덱스를 반환한다. 
  - 전달되는 인수를 요소로 해석하여, 해당 요소가 원본 배열에 있는지 확인하여, 해당 요소의 인덱스를 반환한다. 
  - 중복되는 요소가 있다면, 중복되는 요소들중에 가장 앞에 있는 요소의 인덱스를 반환한다. 
  - 존재하는지 확인하려는 요소가 원본 배열에 없는 요소라면 -1 을 반환한다.

  ```javascript
  // indexOf( ) 메서드를 사용하는 경우
  const myIdols = ['이준호', '장우영', '장우영'];
  
  const result1 = myIdols.indexOf('이준호');// <- myIdols 라는 배열에서, '이준호'라는 요소의 인덱스는?
  console.log(result1); // 0 
  
  const result2 = myIdols.indexOf('장우영');// <- myIdols 라는 배열에서, '장우영'이라는 요소의 인덱스는?
  console.log(result2); /* 1
  <- 현재 원본 배열에서 '장우영' 이라는 요소가 중복되고 있으므로, 중복되는 요소들 중에 가장 앞에 있는 요소의 인덱스로 
  1을 반환하였다.*/ 
  
  const result3 = myIdols.indexOf('양요섭');// <- myIdols 라는 배열에서, '양요섭'이라는 요소의 인덱스는?
  console.log(result3); // -1 <- 현재 원본 배열에서 '양요섭' 이라는 요소가 존재하지 않으므로, -1 을 반환하였다.
  
  
  // inclueds( ) 메서드를 사용하는 경우
  ```

---

##### ② join( ) : 구분자로 연결한 문자열을 반환

- 인수로 전달받은 '구분자'로 연결하여, 원본 배열의 모든 요소를 문자열로 변환한 문자열을 반환한다.

  - 구분자는 생략이 가능하며, 기본 구분자는 `,(콤마)` 이다.

- 문자열( string )을 반환하기 때문에  string 메서드를 사용할수 있다.

  ```javascript
  const phoneNumber = [ '010', '9274', '2066'];
  
  const result = phoneNumber.join('-');
  
  console.log(result); // 010-9274-2066
  console.log(phoneNumber); // [ '010', '9274', '2066' ] : join 은 그냥 메서드이면서 억세서이다.
  
  
  
  // join 메서드를 사용하여 반환한 값은 문자열이기 때문에 string 메서드를 사용할수 있다.
  const phoneNumber = [ '010', '9274', '2066'];
  const result1 = phoneNumber.join('-'); 
  
  console.log(typeof result1); // string
  console.log(result1); // // 010-9274-2066
  
  const result2 = result1.split('-');
  console.log(result2); // [ '010', '9274', '2066' ]
  ```

---

##### ③ inculeds( )  : 배열 내의 특정 요소 존재확인

- inculeds( ) 메서드를 쓰는게 가독성이 더 좋다. 

-  배열 내에 특정 요소가 포함되어있는지(존재하는지) 검사하여, 있으면 true / 없으면 false 를 반환한다.

- 두개의 인수를 전달할수도 있는데, <br>이때 첫번째 인수에는 검색할 요소를 넣고, <br>두번째 인수에는 검색을 시작할 특정 인덱스를 넣을수 있다.  

  ```javascript
  const myIdols = ['이준호', '장우영', '장우영'];
  
  const result1 = myIdols.includes('양요섭')
  console.log(result1); // false <- 원본배열인 myIdols 라는 배열안에, '양요섭' 이라는 요소는 존재하지 않는다.
  
  const result2 = myIdols.includes('이준호', 2)
  // └> myIdols 라는 배열안에, '이준호'라는 요소를 2번째 인덱스부터 검색해라. 
  console.log(result2);// false <- myIdols 라는 배열에, '이준호'라는 요소가 2번째 인덱스부터는 존재하지 않는다.
  
  const result3 = myIdols.includes('이준호', 0)
  // └> myIdols 라는 배열안에, '이준호'라는 요소를 0번째 인덱스부터 검색해라. 
  console.log(result3); // true  <- myIdols 라는 배열에, '이준호'라는 요소가 0번째 인덱스부터는 존재한다.
  
  
  
  if(!myIdols.includes('양요섭')) { // <-원본배열인 myIdols라는 배열안에, '양요섭' 이라는 요소가 존재하지 않는게 true라면,
      myIdols.push('양요섭') // <- 원본배열인 myIdols 이라는 배열에 '양요섭' 이라는 요소를, 원본 배열의 맨 끝의 인덱스에 추가하여라.
  }
  console.log(myIdols); // [ '이준호', '장우영', '장우영', '양요섭' ]
  ```

---

##### ④ flat( ) : 배열 평탄화

- 중첩 대괄호를 벗겨서 평탄화를 시키는 메서드이다. 

- 인수로 전달한 숫자만큼 대괄호를 벗긴다.
  - 인수를 생략할경우에 기본값은 1 이다. 
  - 인수로 infinity 를 전달하면 모든 중첩 대괄호를 벗긴다.  
  
  ```javascript
  const flatArray = [ 34, 6, 89, 454, [34, 64, [23, 11]]]; // <- 총 2개의 대괄호가 중첩되어있다.
  
  const result = flatArray.flat(1);
  console.log(result); // [ 34, 6, 89, 454, 34, 64, [ 23, 11 ] ]
  // └> 1개의 중첩 대괄호를 벗긴 결과로 총 1개의 대괄호만 중첩되어있다. 
  ```

---

#### 뮤테이터 (원본배열이 바뀌는 메서드)

---

##### ⑤ push( ) : 맨 끝에 요소 삽입

- 후입선출

- '스택' 이라는 자료구조에서 구현할수 있는 메서드이다.

  ![stack](https://user-images.githubusercontent.com/62126380/99182750-3a261600-277a-11eb-90dc-c294db7751b6.jpg)  

- 인수로 전달받은 값이, 원본 배열의 맨 끝에 삽입되어, 원본 배열이 변경된다.  

- 변경된 원본 배열의 길이(변경된 length 프로퍼티의 값)가 반환된다.

  ```javascript
  const pm2 = ['이준호', '장우영']
  
  pm2.push('옥택연', '헐베지쿨', '황찬성') // <- push 메서드를 사용해서 인수로 전달하는 요소를 원본 배열의 맨 끝에 추가삽입
  console.log(pm2); // [ '이준호', '장우영', '옥택연', '헐베지쿨', '황찬성']
  
  
  pm2[pm2.length] = '밍';// <- length 프로퍼티의 값을 사용하여 요소 1개만을 원본 배열의 맨 끝에 추가삽입
  console.log(pm2); // [ '이준호', '장우영', '옥택연', '헐베지쿨', '황찬성', '밍' ]
  ```

- push( ) 메서드보다 추천 방법

  - 추가삽입할 요소가 1개라면 push( ) 메서드보다, **<u>length 프로퍼티의 값을 사용</u>**하여, 원본 배열의 맨 끝에 삽입하는 쪽이 더 좋다.

    ```javascript
    const pm2 = [ '이준호', '장우영', '옥택연', '헐베지쿨', '황찬성']
    
    pm2[pm2.length] = '밍';// <- length 프로퍼티의 값을 사용하여 요소 1개만을 원본 배열의 맨 끝에 추가삽입
    console.log(pm2); // [ '이준호', '장우영', '옥택연', '헐베지쿨', '황찬성', '밍' ]
    ```

  - push( ) 메서드와 같은 동작을 하지만, 원본 배열을 변경하지 않게끔 하려면 **<u>스프레드 문법</u>**을 사용하는 쪽이 더 좋다. 
  
    ```javascript
    const myIdols  = [ '데니안', '양요섭'];
    const  newMyIdol= [...myIdols, '이준호'];
    
    console.log(newMyIdol); // [ '데니안', '양요섭', '이준호' ] 
    console.log(myIdols); // [ '데니안', '양요섭' ]
    ```

---

##### ⑥ pop(  ) : 맨 끝 요소 제거

- 후입선출

- '스택' 이라는 자료구조에서 구현할수 있는 메서드이다.

  ![stack](https://user-images.githubusercontent.com/62126380/99182750-3a261600-277a-11eb-90dc-c294db7751b6.jpg) 

- 원래 전달받는 인수가 없는 메서드이다. 

- 원본 배열에서, 맨 끝에 있는 요소가 제거되어, 원본 배열이 변경된다. 

- 원본 배열에서, 제거된 요소의 값이  반환되며, 원본 배열이 빈 배열이면 undefined 가 반환된다.

---

##### ⑦ unshift( ) : 맨 앞에 요소 삽입

- 선입선출

- '큐' 이라는 자료구조에서 구현할수 있는 메서드이다.

  ![queue](https://user-images.githubusercontent.com/62126380/99183447-2a5d0080-277f-11eb-8e88-1238874d9ab5.JPG)  

- 인수로 전달받은 값이, 원본 배열의 맨 앞에 삽입되어, 원본 배열이 변경된다.  

- 변경된 원본 배열의 길이(변경된 length 프로퍼티의 값)가 반환된다.

  ```javascript
  const myIdols  = [ '양요섭', '데니안'];
  console.log(myIdols.length); // 3
  
  const newMyIdol =  myIdols.unshift('이준호');
  console.log(myIdols); // [ '이준호', '데니안', '양요섭' ]
  
  console.log(newMyIdol); // 3
  ```

- unshift( ) 메서드보다 추천 방법

  - unshift( ) 메서드와 같은 동작을 하지만, 원본 배열을 변경하지 않게끔 하려면 **<u>스프레드 문법</u>**을 사용하는 쪽이 더 좋다. 

    ```javascript
    const myIdols  = [ '양요섭', '데니안'];
    console.log(myIdols.length); // 3
    
    const newMyIdol = ['이준호', ...myIdols]
    //  myIdols.unshift('이준호');
    console.log(myIdols); // [ '양요섭', '데니안']
    console.log(newMyIdol); // [ '이준호', '양요섭', '데니안' ]
    console.log(newMyIdol.length); // 3
    ```

---

##### ⑧ shift( ) : 맨 앞 요소 제거

- 선입선출

- '큐' 이라는 자료구조에서 구현할수 있는 메서드이다.

   ![queue](https://user-images.githubusercontent.com/62126380/99183447-2a5d0080-277f-11eb-8e88-1238874d9ab5.JPG)   

- 원본 배열에서, 맨 앞에 있는 요소가 제거되어, 원본 배열이 변경된다. 

- 원본 배열에서, 제거된 요소의 값이  반환되며, 원본 배열이 빈 배열이면 undefined 가 반환된다.

---

##### ⑨ splice( ) : 특정 요소 추가 및 제거

- 원본 배열의 중간에 요소를 추가,제거할때 사용하는 메서드이다. 

- 매개변수가 3개가 있는 메서드이다. 

  1. 원본 배열의 요소를 제거하기 시작하는 인덱스

  2. 제거를 시작하는, 인덱스부터 제거하는, 요소의 개수
  3. 옵션: 요소를 제거하기 시작하는 인덱스의 위치에 삽입할 값. 즉, 위 내용으로 말하자면, "인덱스부터 제거하는" 과 "요소의 개수" 부분이 옵션이다.

- 제거한 요소가 반환된다.

  ```javascript
    const members = ['가', '나', '다', '라','마']
    const result = members.splice(4)
   // └> 원본 배열 요소 중 인덱스4 의 요소 제거

    console.log(result) // ['마'] <- 제거된 요소가 반환된다.
    console.log(members) // ['가', '나', '다', '라'] : splice 는 뮤테이터 이기 때문에 원본 배열이 바뀐다.
  ```

  ```javascript
  const numArray = [ 30, 23, 22 ];
  const result = numArray.splice(1,1,2);
  // └> 원본 배열 요소를 인덱스1 부터 제거 / 인덱스1부터 1개의 요소를 제거 / 2인덱스에 2 라는 요소 삽입
  
  console.log(numArray); // [ 30, 2, 22] : splice 는 뮤테이터 이기 때문에 원본 배열이 바뀐다.
  console.log(result) // [ 23 ] <- 제거된 요소가 반환된다.
  ```

  ![concat](https://user-images.githubusercontent.com/62126380/100082830-15255780-2e8c-11eb-97a8-362f9937f5bb.jpg) 

  ```javascript
  const numArray = [ 30, 23, 22 ];
  const result = numArray.splice(1,1);
  // └> 원본 배열 요소를 인덱스1 부터 제거 / 인덱스1부터 1개의 요소를 제거
  
  console.log(result); // [ 23 ]
  console.log(numArray); // [ 30, 22 ]
  ```

  ![splice](https://user-images.githubusercontent.com/62126380/100085619-98947800-2e8f-11eb-8f53-a0822d3fc938.JPG) 

  ```javascript
  // 만약에, 내가 제거할 요소의 인덱스가 뭔지 모른다면? 
  // └>> 내가 제거할 요소의 인덱스를 검색한 후 -> splice 메서드를 사용해야 한다. 
  
  
  // 데니안 이라는 요소를 제거해라.(데니안이라는 요소의 값의 인덱스를 모른다는 전제하에)
  const stars  = [ '양요섭', '데니안', '이준호', '장우영', '이규형'];
  
  const removeIndex = stars.indexOf('데니안');
  console.log(removeIndex); // 1
  
  const realStars = stars.splice(1,1);
  console.log(stars); // [ '양요섭', '이준호', '장우영', '이규형' ]
  ```

- splice( ) 메서드의 대체 메서드 : 억세서 고차함수 filter( ) 

  ```javascript
  // 데니안 이라는 요소를 제거해라.(데니안이라는 요소의 값의 인덱스를 모른다는 전제하에)
  // └> 데니안 이라는 요소가 아닌 것들만 추출해서(뽑아내서) 반환해라.
  
  const stars  = [ '양요섭', '데니안', '이준호', '장우영', '이규형'];
  
  const realStars = stars.filter(star => star !== '데니안'); 
  console.log(realStars); // [ '양요섭', '이준호', '장우영', '이규형' ]
  console.log(stars); // [ '양요섭', '데니안', '이준호', '장우영', '이규형']
  // 						└>  filter 메서드는 억세서 이기 때문에 원본 배열이 바뀌지 않는다.
  ```

---

##### ⑩ reverse( ) : 배열의 순서를 역순으로

- 원본 배열의 순서를 거꾸로 뒤집은 새로운 배열을 반환한다.

  ```javascript
  const phoneNumber = [ '010', '9274', '2066'];
  
  const result = phoneNumber.reverse();
  console.log(result); // [ '2066', '9274', '010' ]
  ```

---

##### ⑪ fill( ) : 인수로 배열을 채움

- 인수로 전달받은 요소로 배열의 처음부터 끝가지 채운 새로운 배열을 반환한다.

- 매개변수가 3개가 있는 메서드이다. 

  1. 배열의 처음부터 끝까지 채울 요소

  2. 배열의 처음부터 끝까지 요소를 채울 시작 인덱스(해당 인덱스의 요소값은 지워진다.)
  3. 배열의 처음부터 끝까지 요소를 채우는걸 멈출 인덱스

  ```javascript
  const nickNamae  = [ '이준호', '이주너', '이즈너'];
  
  const result = nickNamae.fill('잊',1,2);
  
  console.log(result); // [ '이준호', '잊', '이즈너' ]
  console.log(nickNamae); // [ '이준호', '잊', '이즈너' ]
  ```

- 배열을 생성하면서 특정 요소값으로 배열을 채울수 있다. 

- 모든 요소를 하나의 값만으로만 채운다는 것이 단점이다.

  ```javascript
  // const nickNamae  = [ '이준호', '이주너', '이즈너'];
  const nickNamae  = new Array(3);
  console.log(nickNamae); // [ <3 empty items> ]
  
  
  const result = nickNamae.fill('잊');
  console.log(result); // [ '잊', '잊', '잊' ]
  
  console.log(nickNamae); // [ '잊', '잊', '잊' ]
  ```

---

#### 억세서( 원본배열이 안 바뀌는 메서드)

---

##### ⑫ slice( ) : 배열의 일부분을 복사( 얕은 복사 )

- 배열의 일부분을 고대로 들어낸걸 복사하는 메서드

- 복사를 시작하고 종료할, 인덱스가 인수로 전달되어, 복사된 배열을 반환한다.

- 인수부분을 비운채로 slice 메서드를 사용하면 얕은복사가 된다. 

  ```javascript
  const boyFriend = ['오세진', 33, '구산동', '뚝섬']
  
  const boyFriendCopy = boyFriend.slice();
  console.log(boyFriendCopy); // ['오세진', 33, '구산동', '뚝섬']
  ```

- 원본 배열이 변경되지 않는 억세서이다.

- 매개변수가 2개가 있는 메서드이다. 

  1. 배열의 일부분의, 복사를 시작할 인덱스 
     - 음수일 경우에는, 배열의 끝에서부터 시작한다. <br>(ex. '-2' 일 경우에는 배열의 끝에서부터 2개의 요소를 복사한다.)

  2. 옵션: 해당 인덱스 앞까지 복사를 하겠다
     - 생략할 경우 기본값은 length 프로퍼티 값이다.

  ```javascript
  const boyFriend = ['오세진', 33, '구산동', '뚝섬']
  
  const boyFriendName = boyFriend.slice(0, 1);
  console.log(boyFriendName); // ['오세진']
  
  
  const boyFriendAge = boyFriend.slice(1, 2);
  console.log(boyFriendAge); // [ 33 ]
  
  const boyFriendAddr = boyFriend.slice(2, 3);
  console.log(boyFriendAddr); // ['구산동' ]
  
  const boyFriendCompany = boyFriend.slice(3, 4); // <-----┐
  // const boyFriendCompany = boyFriend.slice(-1); // <----┘ 같은 코드이다.
  console.log(boyFriendCompany); // [ '뚝섬' ]
  
  const info = boyFriend.slice(0, -1); 
  // └> 인덱스 1 부터 배열의 맨 끝의 앞까지 고대로 들어서 복하
  console.log(info); // [ '오세진', 33, '구산동' ]
  
  console.log(boyFriend); // [ '오세진', 33, '구산동', '뚝섬' ]
  ```

---

##### ⑬ concat( ) : 배열과 배열을 이어붙힘

- 배열과 배열을 이어 붙히는 메서드

- 반드시 반환값을 변수에 할당하여 반환시켜야 한다.

- 인수로 전달된 값을 원본 배열의 맨 끝에 이어 붙히는 메서드이다.

  - 인수로 전달된 값이 배열일 경우, 해당 배열을 풀어헤친다음에, 원본 배열내에서 마지막 요소의 뒤에 이어 붙힌다.

  ![concat1](https://user-images.githubusercontent.com/62126380/100101907-33984c80-2ea6-11eb-9eed-c721bc39d938.jpg)   

- concat( ) 메서드보다 추천 방법
  - **<u>스프레드 문법</u>**을 사용하는 쪽이 더 좋다. 

  ```javascript
  // 1번째 예시
  const nickName  = [ '이즈너', '이주너'];
  const newNickName = ['잊', '궁둥리'];
  
  const result1 = [ ...nickName, ...newNickName ]; // [ '이즈너', '이주너', '잊', '궁둥리' ]
  console.log(result1);
  
  // --------------------------------------------------------------------------
  
  // 2번째 예시
  
  const result2 = [ ...[13, 55], ...[45,88]];
  console.log(result2); // [ 13, 55, 45, 88 ]
  ```

  ```javascript
  let todos = [
    { id: 3, content: 'HTML', completed: false },
    { id: 2, content: 'CSS', completed: true },
    { id: 1, content: 'Javascript', completed: false }
  ];
  
  function addTodo(newTodo) { 
    return [newTodo, ...todos];   
  }                                                                       
  console.log(addTodo({ id: 4, content: 'Test', completed: false }));
  /*
  [
    { id: 4, content: 'Test', completed: false },
    { id: 3, content: 'HTML', completed: false },
    { id: 2, content: 'CSS', completed: true },
    { id: 1, content: 'Javascript', completed: false }
  ]
  */
  ```

### 배열의 고차함수

---

- **<u>인수로 함수를 전달받거나, 함수를 반환하는 함수</u>** ( JS는 일급객체이므로, 인수로 값처럼 함수를 전달할수 있다. )

- 외부 상태의 변경이나, 가변 데이터를 피하고, 불변성을 지향하는 함수형 프로그래밍에 기반을 두고 있다.

  > <u>함수형 프로그래밍</u>
  >
  > - 조건문과 반복문을 안 써서 복잡하지 않게 하고, 변수의 사용을 덜 사용하게 하여 상태의 변경을 피하려는 패러다임
  > - 순수함수를 통해 부수효과를 최대한 억제하여 오류를 피하고, 프로그램의 안정성을 높이려는 노력의 일환

#### 그냥 고차함수

---

##### ① some( ) : 조건만족 요소가 1개 이상인지 확인

- 콜백함수를 통해 정의한 **<u>조건이 만족하는 요소가 1개 이상 존재하는지 확인</u>**하는 메서드

- 콜백함수의 반환값(배열의 요소를 순회할때 조건을 만족하는지)이 **한번이라도 true 면 true** 를 , <br>콜백함수의 반환값(배열의 요소를 순회할때 조건을 만족하는지)이 **모두 false 면 false**를 반환한다.

- some( ) 메서드를 호출한 배열이 **<u>빈 배열이면 false 를 반환</u>**한다.

- 매개변수가 3개가 있는 메서드이다. 

  1. some 메서드를 사용하려는 배열의 **요소값들**
  2. some 메서드를 사용하려는 배열의 요소들의 **인덱스**
  3. some 메서드를 사용하려는 **배열 자체**

  ```javascript
  const numArray = [ 11, 56, 1, 33, 20];
  
  const result1 = numArray.some(num => num > 30)
  console.log(result1); // true 
  // └> numArray 이란 배열의, 요소값들중에 30 보다 
  //    큰 요소가 1개 이상 존재한다.
  
  const result2 = numArray.some(num => num > 60)
  console.log(result2); // flase
  // └> numArray 이란 배열의 , 요소값들 중에 60 보다
  //    큰 요소가 1개 이상 존재하지 않는다.
  
  const result3 = [].some(num => num > 3)
  console.log(result3); // false
  // └> some 메서드를 호출한 배열이 빈 배열이면 항상 false를 반환한다.
  ```

---

##### ② every( ) : 조건만족 요소가 모두 존재하는지 확인

- 콜백함수를 통해 정의한 **<u>조건이 만족하는 요소가 모두 존재하는지 확인</u>**하는 메서드

- 콜백함수의 반환값(배열의 요소를 순회할때 조건을 만족하는지)이 **<u>모두 true 면 true</u>** 를 , <br>콜백함수의 반환값(배열의 요소를 순회할때 조건을 만족하는지)이 **<u>한번이라도 false 면 false</u>**를 반환한다.

- every( ) 메서드를 호출한 배열이 **<u>빈 배열이면 true 를 반환</u>**한다.

- 매개변수가 3개가 있는 메서드이다. 

  1. every 메서드를 사용하려는 배열의 **요소값들**
  2. every 메서드를 사용하려는 배열의 요소들의 **인덱스**
  3. every 메서드를 사용하려는 **배열 자체**

  ```javascript
  const numArray = [ 11, 56, 1, 33, 20];
  
  const result1 = numArray.every(num => num > 0)
  console.log(result1); // true 
  // └> numArray 이란 배열의, 요소값들 모두 
  //    0 보다 큰 요소들이다.
  
  const result2 = numArray.every(num => num > 20)
  console.log(result2); // flase
  // └> numArray 이란 배열의 , 요소값들 모두가 20 보다 큰 요소가 아니다.
  
  const result3 = [].every(num => num > 3)
  console.log(result3); // true
  // └> every 메서드를 호출한 배열이 빈 배열이면 항상 true를 반환한다.
  ```

---

##### ③ find( ) : 조건만족 요소가 존재하는지 확인(조건만족 요소를 반환)

- 콜백함수를 통해 정의한 **<u>조건이 만족하는 요소를 검색</u>**하는 메서드

- 콜백함수의 반환값(배열의 요소를 순회할때 조건을 만족하는지)이 **<u>true 인 첫번째 요소</u>**를 , <br>콜백함수의 반환값(배열의 요소를 순회할때 조건을 만족하는지)이 **<u>fasle 면 undefined</u>**를 반환한다.<br>여기서 주의할점은, 요소가 중복되어있다면, **중복된 요소들 중에 첫번째 true 인 요소를 반환한다.**

- 매개변수가 3개가 있는 메서드이다. 

  1. find 메서드를 사용하려는 배열의 **요소값들**
  2. find 메서드를 사용하려는 배열의 요소들의 **인덱스**
  3. find 메서드를 사용하려는 **배열 자체**

  ```javascript
  const myIdols = [
      {
          name: '이준호',
          age: 31,
          company: 'jype',
          group: '2pm'
      },
      {
          name: '양요섭',
          age: 31,
          company: 'around us',
          group: 'highlight'
      },
      {
          name: '장우영',
          age: 31,
          company: 'jype',
          group: '2pm'
      }
  ]
  
  
  const result1 = myIdols.find(idol => idol.company === 'jype')
  console.log(result1);
  /* { name: '이준호', 
       age: 31, 
       address: '청담', 
       company: 'jype', 
       group: '2pm' } 
  */ // <- 조건을 만족하는 요소가 중복하지만, 그 중 첫번째 요소를 반환
  
  const result2 = myIdols.find(idol => idol.group === 'highlight')
  console.log(result2);
  /* { name: '양요섭',
    age: 31,
    address: '청담',
    company: 'around us',
    group: 'highlight' }
  */ // <- 조건을 만족하는 요소를 반환
  
  const result3 = myIdols.find(idol => idol.age >= 33)
  console.log(result3); // undefined
  // └> 조건을 만족하는 요소가 존재하지 않기 때문에 undefined를 반환
  ```

---

##### ④ findIndex( ) : 조건만족 요소가 존재하는지 확인(조건만족 요소의 인덱스를 반환)

- 콜백함수를 통해 정의한 **<u>조건이 만족하는 요소를 검색</u>**하는 메서드

- 콜백함수의 반환값(배열의 요소를 순회할때 조건을 만족하는지)이 **<u>true 인 첫번째 요소의 인덱스</u>**를 , <br>콜백함수의 반환값(배열의 요소를 순회할때 조건을 만족하는지)이  **<u>fasle 면 -1</u>**를 반환한다..<br>여기서 주의할점은, 요소가 중복되어있다면, **중복된 요소들 중에 첫번째 true 인 요소의 인덱스를 반환한다.**

- 매개변수가 3개가 있는 메서드이다. 

  1. findIndex 메서드를 사용하려는 배열의 **요소값들**
  2. findIndex 메서드를 사용하려는 배열의 요소들의 **인덱스**
  3. findIndex 메서드를 사용하려는 **배열 자체**

  ```javascript
  const myIdols = [
      {
          name: '이준호',
          age: 31,
          company: 'jype',
          group: '2pm'
      },
      {
          name: '양요섭',
          age: 31,
          company: 'around us',
          group: 'highlight'
      },
      {
          name: '장우영',
          age: 31,
          company: 'jype',
          group: '2pm'
      }
  ]
  
  // 1번째 예시 
  
  const result1 = myIdols.findIndex(idol => idol.company === 'jype')
  console.log(result1); // 0
  // <- 조건을 만족하는 요소가 중복하지만, 그 중 첫번째 요소의 인덱스를 반환
  
  
  // 2번째 예시
  const result2 = myIdols.findIndex(idol => idol.group === 'highlight')
  console.log(result2); // 1
  // <- 조건을 만족하는 요소의 인덱스를 반환
  
  
  // 3번째 예시
  function myBestIdol(key, value) {
      return (idol => idol[key] === value)
  }
  
  const result = myIdols.findIndex(myBestIdol('name', '이준호')) <-------------┐
  // const result = myIdols.findIndex(idol => idol['name'] === '이준호')) <----┘같은 코드이다.
  console.log(result); // 0
  
  
  // 4번째 예시
  const result3 = myIdols.findIndex(idol => idol.age >= 33)
  console.log(result3); // -1
  // └> 조건을 만족하는 요소가 존재하지 않기 때문에 -1 를 반환
  ```

---

##### ⑤ flatMap( ) : 배열 평탄화

- map 메서드 + flat 메서드 두개의 메서드가 동작하는 메서드

- map 메서드를 한 결과값인 배열을 평탄화 시킨다.<br>여기서 주의할점은, flat( ) 메서드 처럼 평탄화 시키는 단계를 지정할수 없고, 1단계만 평탄화 시킬수 있다. 

  ```javascript
  const myIdols = [ '이준호', '장우영' ];
  
  
  
  // map 메서드와 flat 메서드를 따로 썼을 경우
  const result1 = myIdols.map(idol => idol.split(''))
  console.log(result1); // [ [ '이', '준', '호' ], [ '장', '우', '영' ] ]
  
  const result2 = result1.flat();
  console.log(result2); // [ '이', '준', '호', '장', '우', '영' ]
  
  
  // flatMao 메서드를 썼을 경우
  const result3 = myIdols.flatMap(idol => idol.split(''))
  console.log(result3); // [ [ '이', '준', '호' ], [ '장', '우', '영' ] ]
  ```

---

#### 뮤테이터 ( 원본 배열이 바뀌는 메서드 )

---

##### ⑥ sort( ) : 배열의 요소를 정렬

- 기본적으로 오름차순으로 정렬된다.

- sort 메서드를 호출하는 배열의 요소로 문자열이 올수도 있고 문자열이 아닌 값이 올수도 있다. 

  1. sort 메서드를 호출하는 배열의 요소가 **<u>문자열일 경우</u>**

     >1-1. 오름차순 
     >
     >```javascript
     >const myIdols = [ '이준호', '장우영', '양요섭', '이규형' ];
     >const furits = [ 'apple', 'strawberry', 'banana'];
     >
     >
     >// 오름차순
     >const myIdolsOreum = myIdols.sort();
     >console.log(myIdolsOreum); // [ '양요섭', '이규형', '이준호', '장우영' ]
     >
     >const furitsOreum = furits.sort();
     >console.log(furitsOreum); // [ 'apple', 'banana', 'strawberry' ]
     >```
     >
     >1-2. 내림차순 
     >
     >```javascript
     >const myIdols = [ '이준호', '장우영', '양요섭', '이규형' ];
     >const furits = [ 'apple', 'strawberry', 'banana'];
     >
     >const myIdolsNerim1 = myIdols.reverse(); // <---------------------------------┐
     >console.log(myIdolsNerim1); // [ '이규형', '양요섭', '장우영', '이준호' ]        │
     >	   																        //├--------┐
     >const furitsOreumNerim1 = furits.reverse();//						          │        │
     >console.log(furitsOreumNerim1); // [ 'banana', 'strawberry', 'apple' ]  <-----┘        │
     >																					 //│
     >// └> 현재 원본 배열에 쓰인 요소들의 순서위치만 거꾸로 타는 것일뿐이다.------┐ 				   │
     >//    진짜 내림차순하려면, sort 한 후에 reserver 해야 한다.  -------------┘ <---------------┘
     >
     >// 진짜 내림차순
     >const myIdolsNerim2 = myIdols.sort().reverse();
     >console.log(myIdolsNerim2); // [ '장우영', '이준호', '이규형', '양요섭' ]
     >
     >const furitsOreumNerim2 = furits.sort().reverse();
     >console.log(furitsOreumNerim2); // [ 'strawberry', 'banana', 'apple' ]
     >```

  2. sort 메서드를 호출하는 배열의 요소가 **<u>문자열이 아닐 경우</u>** 

     -  **<u>비교함수를 인수로 전달해야 한다.</u>** 

     - 문자열이 아닌 배열은 의도한 대로 정렬되지 않는다. -> 비교함수를 써야 한다. 

       > 2-1. 오름차순
       >
       > ```javascript
       > const numArray = [10, 1, 54, 100, 34, 62]
       > 
       > const numArrayOreum1 = numArray.sort();
       > console.log(numArrayOreum1); // [ 1, 10, 100, 34, 54, 62 ]
       > // └> 문자열이 아닌 배열은 의도한 대로 정렬되지 않는다. -> 비교함수를 써야 한다. 
       > 
       > // 진짜 오름차순
       > const numArrayOreum = numArray.sort((num1, num2) => num1 > num2 ? 1 : (num1 < num2 ? -1 : 0))
       > console.log(numArrayOreum); // [ 1, 10, 34, 54, 62, 100 ]
       > ```
       >
       > 2-2. 내림차순
       >
       > ```javascript
       > const numArray = [10, 1, 54, 100, 34, 62]
       > 
       > const numArrayNerim1 = numArray.reverse();
       > console.log(numArrayNerim1); // [ 62, 34, 100, 54, 1, 10 ]
       > // └> 현재 원본 배열에 쓰인 요소들의 순서위치만 거꾸로 타는 것일뿐이다. 
       > //    진짜 내림차순하려면, sort 한 후에 reserver 해야 한다. 
       > 
       > const numArrayOreum = numArray.sort((num1, num2) => num1 > num2 ? 1 : (num1 < num2 ? -1 : 0))
       > // └> 뭐가 올지 모르겠지만,
       > // num1 에 온 값이랑 num2 에 온 값이랑 비교해서,
       > // num1 가 크면 1 이란 숫자를 반환, 그게 아니면 (num1 < num2 ? -1 : 0) 을 반환해라
       > //  (num1 < num2 ? -1 : 0) : num1 가 num2 보다 작으면 -1 이란 숫자를 반환, 그게 아니면 0 을 반환해라
       > console.log(numArrayOreum); // [ 1, 10, 34, 54, 62, 100 ]
       > 
       > 
       > const numArrayNerim2 = numArrayOreum2.reverse();
       > console.log(numArrayNerim2); // [ 100, 62, 54, 34, 10, 1 ]
       > ```

  3. sort 메서드를 호출하는 배열의 요소가 **<u>문자열이 아닌 객체일 경우</u>**

     - **<u>비교함수를 인수로 전달해야 한다.</u>** 

     - 객체의 프로퍼티 값이 문자열일 수도, 문자열이 아닌 숫자일수도 있기 때문에 비교함수를 써야 한다. 

       >3-1. 오름차순
       >
       >```javascript
       >const myIdols = [
       >    { name: '이준호', age: 31, company: 'jype', group: '2pm' },
       >    { name: '양요섭', age: 31, company: 'around us', group: 'highlight' },
       >    { name: '장우영', age: 32, company: 'jype', group: '2pm' }
       >]
       >
       >// 오름차순 비교함수
       >function compare(key){
       >    return ( (a, b )=> a[key] > b[key] ? 1 : (a[key] < b[key] ? -1 : 0))
       >}
       >
       >const oreum1 = myIdols.sort(compare('age'));
       >console.log(oreum1);
       >/*
       >[
       >  { name: '이준호', age: 31, company: 'jype', group: '2pm' },
       >  { name: '양요섭', age: 31, company: 'around us', group: 'highlight' },
       >  { name: '장우영', age: 32, company: 'jype', group: '2pm' }
       >]
       >*/ 
       >const oreum2 = myIdols.sort(compare('company'));
       >console.log(oreum2);
       >/*
       >[
       >  { name: '양요섭', age: 31, company: 'around us', group: 'highlight' },
       >  { name: '이준호', age: 31, company: 'jype', group: '2pm' },
       >  { name: '장우영', age: 32, company: 'jype', group: '2pm' }
       >]
       >*/
       >```
       >
       >3-2. 내림차순
       >
       >```javascript
       >const myIdols = [
       >    { name: '이준호', age: 31, company: 'jype', group: '2pm' },
       >    { name: '양요섭', age: 31, company: 'around us', group: 'highlight' },
       >    { name: '장우영', age: 32, company: 'jype', group: '2pm' }
       >]
       >
       >// 내림차순
       >function compare(key){
       >
       >    return ( (a, b )=> a[key] > b[key] ? 1 : (a[key] < b[key] ? -1 : 0))
       >}
       >const oreum1 = myIdols.sort(compare('age'));
       >const nerim1 = oreum1.reverse(compare('age'));
       >console.log(nerim1);
       >/*
       >[
       >  { name: '장우영', age: 32, company: 'jype', group: '2pm' },
       >  { name: '양요섭', age: 31, company: 'around us', group: 'highlight' },
       >  { name: '이준호', age: 31, company: 'jype', group: '2pm' }
       >]
       >*/
       >
       >const oreum2 = myIdols.sort(compare('company'));
       >const nerim2 = oreum2.reverse(compare('company'));
       >console.log(nerim2);
       >/*
       >[
       >  { name: '장우영', age: 32, company: 'jype', group: '2pm' },
       >  { name: '이준호', age: 31, company: 'jype', group: '2pm' },
       >  { name: '양요섭', age: 31, company: 'around us', group: 'highlight' }
       >]
       >*/
       >```

---

#### 억세서 ( 원본 배열이 안 바뀌는 메서드 )

---

##### ⑦ forEach( ) : 순회하는 동작을 하는 메서드                                 

- 로직의 흐름을 이해하기 어렵게 만드는, 조건문과 반복문을 대체하기 위한 고차함수

- forEach 내부에서 반복문을 실행하는 메서드 이다. 즉, 반복하는 동작을 하는 것 뿐인 메서드인것이다.

- forEach( ) 가 반복문을 실행하는 메서드라고는 하지만, 일반 반복문처럼 break 문이나, continue 문을 사용할수 없다.<br>즉, 배열 내부의 요소들을 모두 순회하는것이고, 순회를 중단할수 없다는 것이다. 

- forEach 메서드는 for 문에 비해 가독성이 좋지만 성능이 좋지 않으므로, 복잡한 코드나 높은 성능이 필요할때는<br>for문 을 쓰는 편이 좋다.

- **<u>forEach 메서드의 반환값은 언제나 undefined 이다.</u>**

- `.forEach` 앞에 있는 배열( =  forEach 고차함수를 호출한 배열)을 순회하면서, <br>동작 처리해야 하는 코드( 동작 처리해야 하는 코드 = 콜백함수)들을 `=>` 뒤에 기입해서 forEach 고차함수에게 전달한다.

- 매개변수가 3개가 있는 메서드이다. 

  1. forEach 메서드를 사용하려는 배열의 **요소값들**
  2. forEach 메서드를 사용하려는 배열의 요소들의 **인덱스**
  3. forEach 메서드를 사용하려는 **배열 자체**

  ```javascript
  const myIdols = [ '이준호', '장우영']
  
  myIdols.forEach((idol, idolIndex, myIdols) => {
      // 첫번째 매개변수 : idol
      // 두번째 매개변수 : idolIndex
      // 세번째 매개변수 : myIdols
      console.log( 
      `${idol} : forEach 메서드를 사용하려는 배열의 첫번째 요소값 , 
      ${idolIndex} : '${idol}'의 인덱스,
      ${myIdols} : forEach 메서드를 사용하려는 배열 자체`)
      }
  )
  
  /* 이준호 : forEach 메서드를 사용하려는 배열의 첫번째 요소값 , 
     0 : '이준호'의 인덱스,
     [이준호,장우영]: forEach 메서드를 사용하려는 배열 자체
     장우영 : forEach 메서드를 사용하려는 배열의 첫번째 요소값 , 
     1 : '장우영'의 인덱스,
     [이준호,장우영]: forEach 메서드를 사용하려는 배열 자체
  */
  ```

- forEach 내부에서 반복문을 실행하는 메서드 이다. 즉, 반복하는 동작을 하는 것 뿐인 메서드인것이다.

  ![forEach](https://user-images.githubusercontent.com/62126380/100225204-2f7d3500-2f61-11eb-93c3-b4f53bc67a91.jpg) 

- 원본배열을 변경하지 않는 억세서이지만, 콜백함수로 원본 배열을 바꿀수 있다.

  ```javascript
  const myIdols = [ '이준호', '장우영' ];
  
  myIdols.forEach((idol, index, myIdols) => myIdols[index] = `${idol} 씨`);
  
  console.log(myIdols); // [ '이준호 씨', '장우영 씨' ]
  ```

- 원본 배열이 희소배열인 경우에는, 희소배열 내부에 존재하지 않는 요소는 건너뛰어서 순회대상에서 제외된다.

  ```javascript
  const numArray = [ 1, , 3 ];
  
  numArray.forEach(num => console.log(num))// 1 3
  ```

---

##### ⑧ map( ) : 순회하여 새로운 배열을 반환

- 콜백함수의 반환값들로 구성된 **<u>새로운 배열을 반환한다.</u>**
- 원본 배열의 요소값을 **<u>다른 값으로 1 : 1 매핑한 새로운 배열을 생성</u>**하기 위한 고차함수이다. <br> 그렇기 때문에 새로운 배열의 length 값과 원본 배열의 length 값은 반드시 일치한다. 

- 매개변수가 3개가 있는 메서드이다. 

  1. map 메서드를 사용하려는 배열의 **요소값들**
  2. map 메서드를 사용하려는 배열의 요소들의 **인덱스**
  3. map 메서드를 사용하려는 **배열 자체**

  ```javascript
  const myIdols = [
      { name: '이준호', age: 31, company: 'jype', group: '2pm' },
      { name: '양요섭', age: 31, company: 'around us', group: 'highlight' },
      { name: '장우영', age: 32, company: 'jype', group: '2pm' }
  ]
  
  const centence = myIdols.map(idol => `${idol.name} 는(은) 내 최애다.`)
  console.log(centence); // [ '이준호 는(은) 내 최애다.', '양요섭 는(은) 내 최애다.', '장우영 는(은) 내 최애다.' ]
  ```

  ```javascript
  const todos = [
    { id: 3, content: 'HTML', completed: false },
    { id: 2, content: 'CSS', completed: true },
    { id: 1, content: 'Javascript', completed: false }
  ];
  
  // function getValues(key) { // <-----------┐
  //   return todos.map(todo => todo[key])    ├-------------------┐
  // } // <-----------------------------------┘                   │
  //                                                              │ 동일한 코드이다.
  const getValues = (key) => todos.map(todo => todo[key]) // <----┘
  
  
  console.log(getValues('id')); // [3, 2, 1]
  console.log(getValues('content')); // ['HTML', 'CSS', 'Javascript']
  console.log(getValues('completed')); // [false, true, false]
  ```

  ```javascript
  let todos = [
    { id: 3, content: 'HTML', completed: false },
    { id: 2, content: 'CSS', completed: true },
    { id: 1, content: 'Javascript', completed: false }
  ];
  
  function getMaxId() {
  return Math.max(...todos.map(todo => todo.id )) // <---------------------┐
  // return todos.length ? Math.max(...todos.map(todo => todo.id )): 0 <---┘ 동일한 코드이다.
  }
  
  console.log(getMaxId()); // 3 
  ```

---

##### ⑨ filter( ) : ( 특정요소 제거)조건이 true 인 요소들로만 구성된 새로운 배열을 반환

- 콜백함수의 반환값이 true 인 요소들로만 구성된 **<u>새로운 배열을 반환한다.</u>**
- 특정요소를 제거하기 위해 사용하기도 한다. 
- 원본 배열의 요소값을 **<u>다른 값으로 1 : 1 매핑한 새로운 배열을 생성</u>**하기 위한 고차함수이다. <br> 그렇기 때문에 새로운 배열의 length 값이 원본 배열의 length 값보다 같거나 작다. 

- 매개변수가 3개가 있는 메서드이다. 

  1. filter 메서드를 사용하려는 배열의 **요소값들**
  2. filter 메서드를 사용하려는 배열의 요소들의 **인덱스**
  3. filter 메서드를 사용하려는 **배열 자체**

  ```javascript
  const myIdols = [
      { name: '이준호', age: 31, company: 'jype', group: '2pm' },
      { name: '양요섭', age: 31, company: 'around us', group: 'highlight' },
      { name: '장우영', age: 32, company: 'jype', group: '2pm' }
  ]
  
  const jype1 = myIdols.filter(idol => idol.company === 'jype');
  console.log(jype1);
  /*
  [
    { name: '이준호', age: 31, company: 'jype', group: '2pm' },
    { name: '장우영', age: 32, company: 'jype', group: '2pm' }
  ]
  */
  
  // 특정 요소를 제거할때 사용하기도 한다. 
  const jype2 = myIdols.filter(idol => idol.company !== 'around us')
  console.log(jype2);
  // └> company 가 aruound us 인 요소를 제거하고 남은 것들만 추출
  /*
  [
    { name: '이준호', age: 31, company: 'jype', group: '2pm' },
    { name: '장우영', age: 32, company: 'jype', group: '2pm' }
  ]
  */
  ```

##### ⑩ reduce( ) : 초기값과 누적값을 활용

- 원본 배열을 순회하면서, 콜백함수의 반환값을, 다음번 순회할 때 첫번째 인수로 전달 하면서 하나의 결과값을 반환한다.

-  매개변수가 2개와,  인수 4개가 있는 메서드이다.

  - 매개변수 2개
    1.  **<u>콜백함수</u>**
    2. 옵션: **<u>초기값</u>**  ----------------------------------------------------------------┐
  - 콜백함수(인수 4개)                                                                              │
    1. **<u>초기값</u>** (또는 콜백함수의 이전 반환값)  ------------------------------┘<br>(reduce 메서드를 호출할때는 언제나 초기값을 전달하는 것이 안전하다. )
    2. reduce 메서드를 사용하려는 배열의 **<u>요소값들</u>**
    3. reduce 메서드를 사용하려는 배열의 요소들의 **인덱스**
    4. reduce 메서드를 사용하려는 **배열 자체**

  ![reduce](https://user-images.githubusercontent.com/62126380/100473787-79f9df80-3122-11eb-9202-5d337c35760f.jpg)

-  reduce 메서드를 활용할수 있는 여러가지 활용법들

  1. 총합 구하기

     ```javascript
     const numArray = [ 23, 45, 66, 37, 12, 73, 84, 1, 13, 3 ]
     
     const sum = numArray.reduce((chogi, value) => chogi + value , 0 );
     console.log(sum); // 357
     ```

  2. 평균 구하기

     ```javascript
     const numArray = [ 23, 45, 66, 37, 12, 73, 84, 1, 13, 3 ]
     
     // 방법 1
     const avg1 = numArray.reduce((chogi, value) => chogi + value / numArray.length , 0)
     console.log(avg1); // 35.6999
     
     // 방법 2
     const sum = numArray.reduce((chogi, value) => chogi + value , 0 );
     const avg2 = sum / numArray.length;
     
     console.log(avg2); // 35.7
     ```

  3. 최대값 구하기

     ```javascript
     const numArray = [ 23, 45, 66, 37, 12, 73, 84, 1, 13, 3 ]
     
     // 방법 1
     const max1 = numArray.reduce((chogi, value) => (chogi > value ? chogi : value), 0 ) 
     console.log(max1); // 84
     
     // 방법 2
     const max2 = Math.max(...numArray); 
     console.log(max2);
     ```

  4. 배열의, 중복 요소 갯수 구하기

     ```javascript
     const fruits = [ 'banana', 'apple', 'orange', 'orange', 'orange'];
     
     const count = fruits.reduce((acc, cur) => {
         // console.log(acc[cur]); 
         
         acc[cur] = (acc[cur] || 0)  +1; 
         return acc;
         // 1번째 순회 : { banana: 1}
         // 2번째 순회 : { banana : 1, apple: } -> { banana: 1 , apple: 1}
         // 3번째 순회 : { banana : 1, apple: 1, orange: } -> { banana: 1 , apple: 1, orange: 1}
         // 4번째 순회 : { banana : 1, apple: 1, orange: 1} -> { banana: 1 , apple: 1, orange: 2}
         // 5번째 순회 : { banana : 1, apple: 1, orange: 2} -> { banana: 1 , apple: 1, orange: 3}
     
     }
     , {})
     console.log(count); // { banana: 1, apple 1, orange: 3 }
     ```
