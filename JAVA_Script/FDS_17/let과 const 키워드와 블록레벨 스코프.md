# let, const 와 블록 레벨 스코프

<u>들어가기에 앞서</u>

>결론:
>
>- var 키워드 쓰지마라
>- let 키워드와 const 키워드를 써라

---

## 왜 var 키워드를 쓰지 말고, let 키워드와 const 키워드를 써야 할까?

### var 키워드에는 문제점이 있다. 

---

1. <u>변수의 중복 **선언**을 허용한다</u>
   
- 결국, 현업에서 업무를 하다보면 한 코드를 한사람만 작업하지 않는다. <br>여러 사람이 한 파일에 코딩을 하는데, 그러다보면, 변수가 이미 선언되어잇는 것을 모르고 변수를 중복선언하면서 값까지 할당했다면 의도치 않는 부작용이 발생할 것이다. 
   
2. <u>함수 레벨 스코프만 지역스코프로 인식한다</u>

   - var 키워드로, 전역에 선언한 변수는, 함수 몸체 내부 영역만 지역 스코프로 인식한다.<br>즉, **<u>함수 몸체 내부 이외의 스코프는 모두 전역스코프로 인식</u>**한다는 것이다.

     ```javascript
     // 함수 몸체 내부 이외의 영역인, if 문 코드 블럭안에서 선언한 변수와, if 문 코드 블럭 밖인 전역에서 선언한 변수가 동일하면모두 전역변수가 된다.
     
     var x = 1; // <- 전역에서 선언한 변수 'x'
     
     if (true){
         var x = 10; // <- if문 코드블럭 안에서 선언한 변수 'x'
     }
     
     console.log(x); // 10 <- 전역에서 선언한 변수 === if문 코드블럭 안에서 선언한 변수 = 모두 전역변수가 된다.
     ```

     ```javascript
     // 함수 몸체 내부 이외의 영역인, for문 코드 블럭안에서 선언한 변수와, for문 코드블럭 밖인 전역에서 선언한 변수가 동일하면모두 전역변수가 된다.
     
     var i = 10; // <- 전역에서 선언한 변수 'i'
     
     for (var i = 0; i < 5; i++) { // <- for문 코드블럭 안에서 선언한 변수 'i'
         console.log(i) ;
     }
     console.log(x); // 5 <- 전역에서 선언한 변수 === for문 코드블럭 안에서 선언한 변수 = 모두 전역변수가 된다. 
     ```

3. 변수 호이스팅이 발생한다. 
   - var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있게 된다. ( 단, 할당문 이전에 변수를 참조하면 언제나 undefined 가 반환된다. )
   -  에러를 발생시키지는 않지만 프로그램의 흐름 상 맞지 않을 뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.

### let 키워드 ( var 키워드 대신 사용해야 할 키워드1)

---

1. <u>변수의 중복 **선언**을 **금지**한다.</u>

   - let 키워드로 같은 스코프영역 안에서  변수를 중복 선언하면 Syntax Error가 난다. 

     ```javascript
     let boyFriend = '준호';
     let boyFriend = '우영';
     
     console.log(boyFriend); // Syntax Error : Identifier 'boyFriend' has already been declared ( boyFriend 라는 변수는 이미 선언되어있다. )
     ```

2. <u>모든 코드블럭 내부 영역을 지역스코프로 인식한다. : **블록 레벨 스코프**로 인식한다.</u>  

   - 모든 코드블럭문 영역을 지역스코프로 인식하기 때문에, 다른 스코프라면 동일한 이름의 변수 사용이 가능하다.

     ![de](https://user-images.githubusercontent.com/62126380/93767964-a2152000-fc53-11ea-9af1-5986b27898d5.JPG) 

3. <u>변수 호이스팅이 발생하지 않는것처럼 동작한다.</u>

   - 사실은, let 키워드로 변수를 선언해도 변수 호이스팅이 발생하지만, 발생안하는 것처럼 동작한다. <br>-> 이는 프로그램 흐름의 가독성을 해치지 않고, 오류 발생률을 떨어뜨린다. 

     - let 키워드로 선언한 변수는 **선언단계**와 **초기화 단계**가 <u>**분리되어 진행**</u>된다.

       ![220043841](https://user-images.githubusercontent.com/62126380/93770319-ff5ea080-fc56-11ea-8a1f-24f95a30e337.jpg)

       ```javascript
       /*<------------------------------------┐
       									   │
       */console.log(foo); /* Reference Error │ 일시적 사각지대(암묵적 사각지대)
       <--------------------------------------┘*/
       let foo; // <- 변수선언문이란 해당 코드가 런타임일때 초기화 단계가 실행된다. (런타임 = 초기화단계)
       console.log(foo); // undefined
       
       foo = 1;
       console.log(foo) // 1
       ```

       ![220740753](https://user-images.githubusercontent.com/62126380/93770377-0f768000-fc57-11ea-9130-eac9cd3f7167.jpg)

4. <u>전역객체 window 의 프로퍼티가 아니다.</u>

   ```javascript
   let x = 1;
   console.log(window.x);	//undefined
   console.log(x);		// 1
   /*-------------------------------------
   let, const 키워드로 선언한 변수는 전역 객체의 프로퍼티가 아니므로 window를 사용할수 없다.*/
   ```

### const 키워드 ( var 키워드 대신 사용해야 할 키워드2)

1. <u>변수의 중복 **선언**을 **금지**한다.</u> 

   - const 키워드로 선언한 변수는, 선언과 동시에 변수에 값을 할당해야 한다. ( 안 그러면 Syntax Error 가 난다. )

     ```javascript
     const foo = 1;
     console.log(foo) // 1
     
     const bar;
     console.log(bar) // Syntax Error
     ```

   2. <u>모든 코드블럭 내부 영역을 지역스코프로 인식한다. : **블록 레벨 스코프**로 인식한다.</u>  

      - 모든 코드블럭문 영역을 지역스코프로 인식하기 때문에, 다른 스코프라면 동일한 이름의 변수 사용이 가능하다.

        ```javascript
        const i = 10;
        
        function foo() {
            const i = 100;
            if (true) {
                const i = 1;
                console.log(i); // 1
            }
            console.log(i); // 100
        }
        foo();
        console.log(i); // 10
        ```

3. <u>변수 호이스팅이 발생하지 않는것처럼 동작한다.</u>

   - 사실은, const 키워드로 변수를 선언해도 변수 호이스팅이 발생하지만, 발생안하는 것처럼 동작한다. <br>-> 이는 프로그램 흐름의 가독성을 해치지 않고, 오류 발생률을 떨어뜨린다. 

     - const 키워드로 선언한 변수는 **선언단계**와 **초기화 단계**가 <u>동시에 진행</u>된다.

       ```javascript
       /*<------------------------------------┐
       									   │
       */console.log(foo); /* Reference Error │ 일시적 사각지대
       <--------------------------------------┘*/
       const foo = 1; // 선언문 = 값의 할당단계
       console.log(foo); // 1
       ```

4. **<u>재할당 금지</u>**

   - const 키워드로 선언한 변수는 재할당이 금지된다. 

   - const 키워드를 `상수`를 표현하는데 사용하기도 한다. 

     ><u>상수</u>
     >
     >- 재할당이 금지된 변수

   - 원시값은 원래 변경이 불가능한 값이기 때문에 const 키워드로 변수에 원시값을 할당한다한들 변경 할수 없다. <br>그렇다면 객체타입의 값은 어떨까?<br>객체타입의 값을 const 키워드로 선언한 변수에 할당하면, 이때는 값을 변경할수 있다. <br>**<u>단, 재할당없이 가능하다.</u>** 

   - 일반적으로 상수의 이름은 대문자로 선언해서 상수임을 명시적으로 나타낸다. 

     ![캡쳐105](https://user-images.githubusercontent.com/62126380/81821365-b9892180-956c-11ea-9de0-fb1dd6434e95.PNG) 

4. 전역객체 window 의 프로퍼티가 아니다.

   ```javascript
   const x = 1;
   console.log(window.x);	//undefined
   console.log(x);		// 1
   /*-------------------------------------
   let, const 키워드로 선언한 변수는 전역 객체의 프로퍼티가 아니므로 window를 사용할수 없다.*/
   ```

### var 키워드, let 키워드, const 키워드의 추천 사용법

---

- ES6를 사용한다면 var 키워드는 사용하지 마라
- 재할당이 필요한 경우에만 let 키워드를 사용해라. (이때 변수의 스코프는 좁게 만들어라)
- 변경하지않고 readOnly 한 원시값과 객체에는 const 키워드를 사용해라(const는 재할당을 금지하므로 var랑 let 보다 안전하다)
- var 키워드로 변수를 선언할거면 전부 다 var만 써라. var 도 쓰고 const도 쓰고 하면서 섞어 쓰면 안된다. 

