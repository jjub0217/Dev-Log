# 함수

들어가기에 앞서...

><u>함수를 사용하는 이유</u>
>
>- 코드의 재사용이라는 측면에서 매우 유용하다
>- 유지보수의 편의성을 높인다
>- 실수를 줄여서, 코드의 신뢰성을 높일수 있다. 

---

## 함수란? 

- 함수는 객체타입의 값이다. 함수도 함수 리터럴로 생성할수 있다. 
- 함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체다. <br>즉, 함수는 객체다.
- 일반객체는 호출할수 없지만 함수는 호출할 수 있으며, 함수는 객체만의 고유한 프로퍼티를 갖고 있다. 
- 일련의 과정을 문(statement)들로 구현 -> 코드 블록으로 감싸서 -> 하나의 실행단위로 정의 한것이다. 
- 함수는 입력(input)을 받아서 출력(putput)값인 return값을 내보내는 과정을 정의한 것이다. 
  - 함수 내부로 입력시키는 input 값을 인수(아규먼트: argument)라고 하고, <br>입력된 값을 전달받는 것을 매개변수(파라미터: parameter) 라고 하며 <br>매개변수를 사용해 일련의 과정을 통해 나온 것을 출력시키는 값을 반환값(return값)이라고 한다.  
- 함수는 함수정의를 통해 생성된다. 
  - 함수 정의만으로는 함수가 실행되진 않는다. <br>인수를 매개변수를 통해 함수에게 전달하면서 함수의 실행을 명시적으로 지시한 이후에 <br>함수호출을 해야, 함수 몸체 내부에서 일련의 과정이 실행되고, 그 결과값인 반환값을 반환한다.
- 함수호출은, 함수 이름으로 호출하는 것이 아니라, 함수 객체를 가리키는 식별자로 호출한다. 

---

![캡쳐93](https://user-images.githubusercontent.com/62126380/92209817-9b06b780-eec8-11ea-8aa1-31cca4bb5664.PNG)

 

1. 함수 이름

   -  함수 이름은 식별자이다.
   -  👆 <u>**함수 이름은 함수 몸체 내부에서만 참조할수 있다.**</u> 
   - 이름이 있는 함수를 기명함수 / 이름이 없는 함수를 익명함수 라고 한다. 

2. 매개변수

   -  0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다. 
     변수는 순서에 의미가 있다. 

   - 매개변수도 식별자이기 때문에, 식별자 네이밍 규칙을 준수해야 한다. 

   - 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다.

   - 함수 몸체 내에서 암묵적으로 매개변수가 생성되고, 변수처럼 undefined로 초기화 된 이후에 인수가 순서대로 할당된다.

   - 매개변수는 함수 몸체 내부에서만 참조할수 있고, 함수 몸체 외부에서는 참조할수 없다. <br>즉, 👆 **<u>매개변수의 스코프는 함수 내부이다.</u>**

   - 매개변수와 인수의 개수가 일치하지 않더라고 에러가 발생하지 않는다. 

     - 인수가, 매개변수 개수보다 부족할때 

       ```javascript
       function add(x, y){
           console.log(x) // 2
           console.log(y) // undefined
           return x + y; // 2 + undefined 
       }
       console.log(add(2)); // NaN
       ```

     - 인수가, 매개변수 개수보다 초과될때 -> 초과된 인수는 암묵적으로 arguments 라는 객체의프로퍼티로 보관된다.

       ```javascript
       function add(x, y){
           console.log(x) // 2
           console.log(y) // 5
           console.log(arguments) // arguments { 0: '2', 1: '2', 2: '10' }
           return x + y; // 2 + 5
       }
       console.log(add(2, 5, 10)); // 7
       ```

   - 매개변수에 맞춰서 인수도 동일하게 순서에 의미가 있기 때문에 두개의 순서를 고려해야 한다. <br>이상적인 매개변수의 개수는 0개이며, 최대 3개를 넘지 않는 것을 권장한다. <br>그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고, 객체를 인수로 전달받는 것이 유리하다.

     -> 함수 외부에서 내부로 객체를 전달한 이후에, 함수 내부에서 객체 내용을 변경하면, 함수 외부의 객체도 변경된다 ("부수효과")

3. 인수 

   - 👆 <u>**값으로 평가될 수 있는 표현식이어야 한다**</u>

   - JS의 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.

   - 인수가 전달되지 않은 경우에는 단축평가를 사용해서 매배견수에 기본값을 할당(에러가 나지 않게끔) 할수 있다. 

     ```javascript
     function add(a, b, c){
         a = a || 0;
         b = b || 0;
         c = c || 0;
         return a + b + c
     }
     console.log(1, 2, 3) // 6
     /*	<- a = 1 // true // 1
     	<- b = 2 // true // 2
     	<- c = 3 // true // 3
     	1 + 2 + 3 = 6
     */
     console.log(1, 2) // 3
     /*	<- a = 1 // true // 1
     	<- b = 2 // true // 2
     	<- c = undefined // 0 
     	1 + 2 + 0 = 3
     */
     console.log(1) // 1
     /*	<- a = 1 // true // 1
     	<- b = undefined // 0
     	<- c = undefined // 0
     	1 + 0 + 0 = 1
     */
     ```

4. 함수몸체

- 함수 몸체는 함수 호출에 의해 실행된다.

5. 반환문

   - 실행결과를 함수 외부로 반환(return) 할 수 있다.

   - 함수 몸체 내부에서만 사용할 수 있다. 

     1. 함수 몸체 내부에서 일련의 과정이 실행되다가 return 을 만나면, 그 시점에서 함수 실행을 중단하고 함수가 종료된다. (return 을 만나면, return 이후의 문은 실행되지 않고 무시된다.)

        ```javascript
        function add(x, y){
            return x + y;
            console.log('<- 해당 코드는 실행되지 않는 코드다')
        }
        console.log(add(2,5)) // 7
        ```

     2. return 뒤에 지정한 값을 반환한다. return 뒤에 값을 지정하지 않으면 undefined 가 반환된다.

        ```javascript
        function add(x, y){
            return
        }
        console.log(add(2, 5)) // undefined
        ```

     3. 함수 몸체 내부에서  return 값을 생략할수는 있지만, 생략하면 undefined 가 반환된다.

        ```javascript
        function add(x, y){
           
        }
        console.log(add(2, 5)) // undefined
        ```

---

## 함수를 정의하는 방법

### 1. 함수 선언문(함수 리터럴이라고 할수 있다. )

![캡쳐93](https://user-images.githubusercontent.com/62126380/92209817-9b06b780-eec8-11ea-8aa1-31cca4bb5664.PNG) 

- 함수 선언문과 함수 리터럴은 형태가 동일하다.

- 👆 <u>**함수 리터럴은 함수 이름을 생략할수 있다.**</u>

  | 함수 선언문               | 함수 리터럴                 |
  | ------------------------- | --------------------------- |
  | 함수 이름을 생략할수 없다 | 함수 이름을 생략할 수 있다. |

- 이름이 있는 함수를 기명함수 / 이름이 없는 함수를 익명함수 라고 한다. 

  <table>
      <thead>
      <tr>
        <th colspan=2  align="center">기명함수</th>
        <th align="center">익명함수</th>
      </tr>
      </thead>
      <tbody>
      <tr>
      <td colspan=2 align="center">이름이 있는 "함수선언문"으로 해석</td>
      <td rowspan=3 align="center">이름이 없는 "함수선언문"으로 해석</td>
      </tr>
      <tr>
        <td span style="font-weight:bold">단독으로 사용할 경우</td>
          <td>함수 선언문으로 해석</td>
          </tr>
  <tr>
  <td  span style="font-weight:bold">변수에 할당할 경우</td>
      <td>함수 표현식으로 해석</td>
      </tr>
      </tbody>
    </table>
  
  ### 함수 선언문은 표현식이 아닌 문이다.
  
  ---
  
  표현식이 아닌 문은 값으로 평가될수 없기때문에<br>( 함수 선언문을 실행하면 완료값인 undefined 가 나오기 때문에 값으로 평가될수 없다. ) <br>피연산자로도 사용할수 없다.
  
  그런데, 표현식이 아닌 문인데, 어째서 변수에 할당하는것이 가능할까??
  
  1. 이름이 있는 함수 선언문을 단독으로 사용할 경우 :  함수 선언문으로 해석
  
     ```javascript
     // 이름이 있는 함수 선언문(기명함수)를 단독으로 사용하는 경우 -> 그냥 함수선언문으로 해석
     
     function add(x,y){ 
         return x + y 
     }
     console.log(add(2, 5)) // 7 
     ```
  
     - 단독으로 사용된, 이름이 있는 함수 선언문의, 함수 이름으로 참조하면 원래 참조가 되면 안된다. ( ∵ 함수이름은 함수 몸체 내부에서만 참조가 가능하기 때문)
  
       그런데 참조가 가능하도록 실행이 되는 이유는 ,<br>👍 **<u>함수 선언문이 평가되면 함수이름과 동일한 식별자가 암묵적으로 생성되고, 그 식별자에 함수 객체가 할당되기 때문이다.</u>** 
  
       **<u>함수는 함수 객체를 가리키는 식별자로 호출한다.</u>**
  
       ```javascript
       function add(x,y){
           return x + y
       }
       // add 라는 함수 이름과 동일한 add 라는 식별자가 암묵적으로 생성되고, 새로 생성된 add 라는 식별자에 
       // 함수 객체가 할당되고, 새로 생성된 add 라는 식별자로 함수가 호출된다.
       
       console.log(add(2, 5)) // 7 
       ```
  
     - **함수선언문의 "함수 호이스팅"**
       - 단독으로 사용된, 이름이 있는 함수선언문으로(기명함수) 함수를 정의하면, 런타임 이전에 함수 객체가 생성되며,<br> 함수 이름과 동일한 이름으로 JS엔진이 암묵적으로 식별자를 생성하고, 그 식별자에 함수 객체를 할당한다.
       - 런타임에는 이미 함수 객체가 생성되어있으며, 함수 이름과 동일한 식별자에 함수가 할당된 상태이다. <br>즉, 함수 선언문 이전에 함수를 참조할수도 있고, 호출할수도 있다. <br>-> 함수 선언문 이전에 함수를 호출하면 "함수 호이스팅"으로 인해 함수 호출이 가능하다.
  
  2. 이름이 있는 함수 선언문을 변수에 할당할 경우 : <br>JS엔진은 이 이름이 있는 함수 선언문을, 표현식인 문인, 함수 리터럴 표현식으로 해석
  
     ```javascript
     // 이름이 있는 함수 선언문(기명함수)를 변수에 할당할 경우 -> 함수 표현식으로 해석
     
     var sum = function add(x,y){ 
         return x + y 
     }
     console.log(sum(2, 5)) // 7 
     ```

---

### 2. 함수 표현식

- 함수 선언문을 변수에 할당한 형태이다. 

  ```javascript
  // 이름이 있는 함수 선언문(기명함수)를 변수에 할당할 경우 -> 함수 표현식으로 해석
  
  var sum = function add(x,y){ 
      return x + y 
  }
  console.log(sum(2, 5)) // 7 
  ```

- 함수 표현식으로 정의된 함수의, 함수이름으로는 함수를 호출할수 없다

  - ∵ 함수 이름은 함수 몸체 외부에서는 호출할수 없기 때문

  - ∵  함수는 함수 객체를 가리키는 식별자로 호출하기 때문

    ─> ∴ 그러므로, 함수 선언문을 할당한 변수 이름으로는 함수를 호출할수 있기에, 함수를 호출할시에는, 변수 이름으로 호출한다.

- 함수 객체가 변수에 할당된 함수표현식은, 함수 표현식이 실행되는 런타임에 평가된 이후에 함수 객체가 생성된다. 
  - 👍 **<u>함수 표현식으로 함수를 정의하면 함수 호이스팅이 발행하는 것이 아니라 변수 호이스팅이 발생한것이다.</u>**

    ```javascript
    var sum;
    console.log(sum) // undefined
    console.log(sum()) // TypeError : sum is not function <- 함수 호출했지만 TypeError 났다. 
    				   // 함수 표현식으로 정의한 함수는, 함수 표현식 이전에 호출하면 Error 난다.
    sum = function(x, y) { return x + y } 
    ```

### 3. Function 생성자 함수

```javascript
var add = new Function ('x','y','return x + y');

/*	new : new 연산자
	Function : 프로포타입 객체인 Function 생성자 함수
	'x','y','return x + y' : 생성자 함수의 매개변수에 전달되는 값
```

- Function 생성자 함수로 함수를 생성(함수를 정의)하는 방법은 일반적이지 않으며, 바람직하지 않다. 

### 4. 화살표 함수

```javascript
var add = (x,y) => x + y;
/*		   ￣￣↓   ￣￣￣￣└> 함수 몸체 / 리턴값
 		    매개변수 
```

- 화살표 함수는 항상 익명함수로 정의한다. 
- 화살표 함수는 생성자 함수로 사용할수 없다

---

## 참조에 의한 전달과 외부 상태의 변경

