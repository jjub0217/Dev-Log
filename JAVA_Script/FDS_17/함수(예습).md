# 함수

들어가기에 앞서...

><u>함수를 사용하는 이유</u>
>
>- 코드의 재사용이라는 측면에서 매우 유용하다
>- 유지보수의 편의성을 높인다
>- 실수를 줄여서, 코드의 신뢰성을 높일수 있다. 

---

## 함수란? 

- 함수는 객체타입의 값이다. 함수도 함수 리터럴로 생성할수 있다. 
- 함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체다. <br>즉, 함수는 객체다.
- 일반객체는 호출할수 없지만 함수는 호출할 수 있으며, 함수는 객체만의 고유한 프로퍼티를 갖고 있다. 
- 일련의 과정을 문(statement)들로 구현 -> 코드 블록으로 감싸서 -> 하나의 실행단위로 정의 한것이다. 
- 함수는 입력(input)을 받아서 출력(putput)값인 return값을 내보내는 과정을 정의한 것이다. 
  - 함수 내부로 입력시키는 input 값을 인수(아규먼트: argument)라고 하고, <br>입력된 값을 전달받는 것을 매개변수(파라미터: parameter) 라고 하며 <br>매개변수를 사용해 일련의 과정을 통해 나온 것을 출력시키는 값을 반환값(return값)이라고 한다.  
- 함수는 함수정의를 통해 생성된다. 
  - 함수 정의만으로는 함수가 실행되진 않는다. <br>인수를 매개변수를 통해 함수에게 전달하면서 함수의 실행을 명시적으로 지시한 이후에 <br>함수호출을 해야, 함수 몸체 내부에서 일련의 과정이 실행되고, 그 결과값인 반환값을 반환한다.
- 함수호출은, 함수 이름으로 호출하는 것이 아니라, 함수 객체를 가리키는 식별자로 호출한다. 

---

![캡쳐93](https://user-images.githubusercontent.com/62126380/92209817-9b06b780-eec8-11ea-8aa1-31cca4bb5664.PNG)

 

1. 함수 이름

   -  함수 이름은 식별자이다.
   -  👆 <u>**함수 이름은 함수 몸체 내부에서만 참조할수 있다.**</u> 
   - 이름이 있는 함수를 기명함수 / 이름이 없는 함수를 익명함수 라고 한다. 

2. 매개변수

   -  0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다. 
     변수는 순서에 의미가 있다. 

   - 매개변수도 식별자이기 때문에, 식별자 네이밍 규칙을 준수해야 한다. 

   - 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다.

   - 함수 몸체 내에서 암묵적으로 매개변수가 생성되고, 변수처럼 undefined로 초기화 된 이후에 인수가 순서대로 할당된다.

   - 매개변수는 함수 몸체 내부에서만 참조할수 있고, 함수 몸체 외부에서는 참조할수 없다. <br>즉, 👆 **<u>매개변수의 스코프는 함수 내부이다.</u>**

   - 매개변수와 인수의 개수가 일치하지 않더라고 에러가 발생하지 않는다. 

     - 인수가, 매개변수 개수보다 부족할때 

       ```javascript
       function add(x, y){
           console.log(x) // 2
           console.log(y) // undefined
           return x + y; // 2 + undefined 
       }
       console.log(add(2)); // NaN
       ```

     - 인수가, 매개변수 개수보다 초과될때 -> 초과된 인수는 암묵적으로 arguments 라는 객체의프로퍼티로 보관된다.

       ```javascript
       function add(x, y){
           console.log(x) // 2
           console.log(y) // 5
           console.log(arguments) // arguments { 0: '2', 1: '2', 2: '10' }
           return x + y; // 2 + 5
       }
       console.log(add(2, 5, 10)); // 7
       ```

   - 매개변수에 맞춰서 인수도 동일하게 순서에 의미가 있기 때문에 두개의 순서를 고려해야 한다. <br>이상적인 매개변수의 개수는 0개이며, 최대 3개를 넘지 않는 것을 권장한다. <br>그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고, 객체를 인수로 전달받는 것이 유리하다.

     -> 함수 외부에서 내부로 객체를 전달한 이후에, 함수 내부에서 객체 내용을 변경하면, 함수 외부의 객체도 변경된다 ("부수효과")

3. 인수 

   - 👆 <u>**값으로 평가될 수 있는 표현식이어야 한다**</u>

   - JS의 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.

   - 인수가 전달되지 않은 경우에는 단축평가를 사용해서 매배견수에 기본값을 할당(에러가 나지 않게끔) 할수 있다. 

     ```javascript
     function add(a, b, c){
         a = a || 0;
         b = b || 0;
         c = c || 0;
         return a + b + c
     }
     console.log(1, 2, 3) // 6
     /*	<- a = 1 // true // 1
     	<- b = 2 // true // 2
     	<- c = 3 // true // 3
     	1 + 2 + 3 = 6
     */
     console.log(1, 2) // 3
     /*	<- a = 1 // true // 1
     	<- b = 2 // true // 2
     	<- c = undefined // 0 
     	1 + 2 + 0 = 3
     */
     console.log(1) // 1
     /*	<- a = 1 // true // 1
     	<- b = undefined // 0
     	<- c = undefined // 0
     	1 + 0 + 0 = 1
     */
     ```

4. 함수몸체

- 함수 몸체는 함수 호출에 의해 실행된다.

5. 반환문

   - 실행결과를 함수 외부로 반환(return) 할 수 있다.

   - 함수 몸체 내부에서만 사용할 수 있다. 

     1. 함수 몸체 내부에서 일련의 과정이 실행되다가 return 을 만나면, 그 시점에서 함수 실행을 중단하고 함수가 종료된다. (return 을 만나면, return 이후의 문은 실행되지 않고 무시된다.)

        ```javascript
        function add(x, y){
            return x + y;
            console.log('<- 해당 코드는 실행되지 않는 코드다')
        }
        console.log(add(2,5)) // 7
        ```

     2. return 뒤에 지정한 값을 반환한다. return 뒤에 값을 지정하지 않으면 undefined 가 반환된다.

        ```javascript
        function add(x, y){
            return
        }
        console.log(add(2, 5)) // undefined
        ```

     3. 함수 몸체 내부에서  return 값을 생략할수는 있지만, 생략하면 undefined 가 반환된다.

        ```javascript
        function add(x, y){
           
        }
        console.log(add(2, 5)) // undefined
        ```

---

## 함수를 정의하는 방법

### 1. 함수 선언문(함수 리터럴이라고 할수 있다. )

![캡쳐93](https://user-images.githubusercontent.com/62126380/92209817-9b06b780-eec8-11ea-8aa1-31cca4bb5664.PNG) 

- 함수 선언문과 함수 리터럴은 형태가 동일하다.

- 👆 <u>**함수 리터럴은 함수 이름을 생략할수 있다.**</u>

  | 함수 선언문               | 함수 리터럴                 |
  | ------------------------- | --------------------------- |
  | 함수 이름을 생략할수 없다 | 함수 이름을 생략할 수 있다. |

- 이름이 있는 함수를 기명함수 / 이름이 없는 함수를 익명함수 라고 한다. 

  <table>
      <thead>
      <tr>
        <th colspan=2  align="center">기명함수</th>
        <th align="center">익명함수</th>
      </tr>
      </thead>
      <tbody>
      <tr>
      <td colspan=2 align="center">이름이 있는 "함수선언문"으로 해석</td>
      <td rowspan=3 align="center">이름이 없는 "함수선언문"으로 해석</td>
      </tr>
      <tr>
        <td span style="font-weight:bold">단독으로 사용할 경우</td>
          <td>함수 선언문으로 해석</td>
          </tr>
  <tr>
  <td  span style="font-weight:bold">변수에 할당할 경우</td>
      <td>함수 표현식으로 해석</td>
      </tr>
      </tbody>
    </table>
  
  ### 함수 선언문은 표현식이 아닌 문이다.
  
  ---
  
  표현식이 아닌 문은 값으로 평가될수 없기때문에<br>( 함수 선언문을 실행하면 완료값인 undefined 가 나오기 때문에 값으로 평가될수 없다. ) <br>피연산자로도 사용할수 없다.
  
  그런데, 표현식이 아닌 문인데, 어째서 변수에 할당하는것이 가능할까??
  
  1. 이름이 있는 함수 선언문을 단독으로 사용할 경우 :  함수 선언문으로 해석
  
     ```javascript
     // 이름이 있는 함수 선언문(기명함수)를 단독으로 사용하는 경우 -> 그냥 함수선언문으로 해석
     
     function add(x,y){ 
         return x + y 
     }
     console.log(add(2, 5)) // 7 
     ```
  
     - 단독으로 사용된, 이름이 있는 함수 선언문의, 함수 이름으로 참조하면 원래 참조가 되면 안된다. ( ∵ 함수이름은 함수 몸체 내부에서만 참조가 가능하기 때문)
  
       그런데 참조가 가능하도록 실행이 되는 이유는 ,<br>👍 **<u>함수 선언문이 평가되면 함수이름과 동일한 식별자가 암묵적으로 생성되고, 그 식별자에 함수 객체가 할당되기 때문이다.</u>** 
  
       **<u>함수는 함수 객체를 가리키는 식별자로 호출한다.</u>**
  
       ```javascript
       function add(x,y){
           return x + y
       }
       // add 라는 함수 이름과 동일한 add 라는 식별자가 암묵적으로 생성되고, 새로 생성된 add 라는 식별자에 
       // 함수 객체가 할당되고, 새로 생성된 add 라는 식별자로 함수가 호출된다.
       
       console.log(add(2, 5)) // 7 
       ```
  
     - **함수선언문의 "함수 호이스팅"**
       - 단독으로 사용된, 이름이 있는 함수선언문으로(기명함수) 함수를 정의하면, 런타임 이전에 함수 객체가 생성되며,<br> 함수 이름과 동일한 이름으로 JS엔진이 암묵적으로 식별자를 생성하고, 그 식별자에 함수 객체를 할당한다.
       - 런타임에는 이미 함수 객체가 생성되어있으며, 함수 이름과 동일한 식별자에 함수가 할당된 상태이다. <br>즉, 함수 선언문 이전에 함수를 참조할수도 있고, 호출할수도 있다. <br>-> 함수 선언문 이전에 함수를 호출하면 "함수 호이스팅"으로 인해 함수 호출이 가능하다.
  
  2. 이름이 있는 함수 선언문을 변수에 할당할 경우 : <br>JS엔진은 이 이름이 있는 함수 선언문을, 표현식인 문인, 함수 리터럴 표현식으로 해석
  
     ```javascript
     // 이름이 있는 함수 선언문(기명함수)를 변수에 할당할 경우 -> 함수 표현식으로 해석
     
     var sum = function add(x,y){ 
         return x + y 
     }
     console.log(sum(2, 5)) // 7 
     ```

---

### 2. 함수 표현식

- 함수 선언문을 변수에 할당한 형태이다. 

  ```javascript
  // 이름이 있는 함수 선언문(기명함수)를 변수에 할당할 경우 -> 함수 표현식으로 해석
  
  var sum = function add(x,y){ 
      return x + y 
  }
  console.log(sum(2, 5)) // 7 
  ```

- 함수 표현식으로 정의된 함수의, 함수이름으로는 함수를 호출할수 없다

  - ∵ 함수 이름은 함수 몸체 외부에서는 호출할수 없기 때문

  - ∵  함수는 함수 객체를 가리키는 식별자로 호출하기 때문

    ─> ∴ 그러므로, 함수 선언문을 할당한 변수 이름으로는 함수를 호출할수 있기에, 함수를 호출할시에는, 변수 이름으로 호출한다.

- 함수 객체가 변수에 할당된 함수표현식은, 함수 표현식이 실행되는 런타임에 평가된 이후에 함수 객체가 생성된다. 
  - 👍 **<u>함수 표현식으로 함수를 정의하면 함수 호이스팅이 발행하는 것이 아니라 변수 호이스팅이 발생한것이다.</u>**

    ```javascript
    var sum;
    console.log(sum) // undefined
    console.log(sum()) // TypeError : sum is not function <- 함수 호출했지만 TypeError 났다. 
    				   // 함수 표현식으로 정의한 함수는, 함수 표현식 이전에 호출하면 Error 난다.
    sum = function(x, y) { return x + y } 
    ```

### 3. Function 생성자 함수

```javascript
var add = new Function ('x','y','return x + y');

/*	new : new 연산자
	Function : 프로포타입 객체인 Function 생성자 함수
	'x','y','return x + y' : 생성자 함수의 매개변수에 전달되는 값
```

- Function 생성자 함수로 함수를 생성(함수를 정의)하는 방법은 일반적이지 않으며, 바람직하지 않다. 

### 4. 화살표 함수

```javascript
var add = (x,y) => x + y;
/*		   ￣￣↓   ￣￣￣￣└> 함수 몸체 / 리턴값
 		    매개변수 
```

- **<u>화살표 함수는 항상 익명함수로 정의한다.</u>** 
- 화살표 함수는 생성자 함수로 사용할수 없다

---

## 참조에 의한 전달과 외부 상태의 변경

함수는 객체다. <br>그러므로, 객체는 참조에 의한 전달 방식으로 동작한다. 

함수의 매개변수(파라미터)는 함수 몸체 내부에서 변수와 동일하게 취급된다고 했다. <br>즉, 매개변수 또한 타입에 따라 값에 의한 전달과 참조에 의한 전달. 두가지의 방식을 따른다. 

![3444](https://user-images.githubusercontent.com/62126380/92323065-94b33f80-f070-11ea-868f-986f0d341b6e.jpg) 

- 매개변수를 통해 전달 받은 값이 원시값일 경우 

  - <u>재할당을 통해</u> 할당된 원시값을 새로운 원시값으로 교체

    >```javascript
    >primitive += 100;
    >```
    >
    >-> 원시값은 원본이 변경되지 않는다(원시값은 변경 불가능한 값이다. : immutable)
    >
    >```javascript
    >console.log(num) // 100
    >```

- 매개변수를 통해 전달 받은 값이 객체일 경우

  - 참조값이 복사되어서 매개변수에 전달

  - 함수 외부에서 함수 몸체 내부로 전달한, 참조값에 의해 원본 객체를 변경<br>(<u>함수외부에서 객체를 변경</u>)

    >```javascript
    >var person = { name: 'Lee' }
    >```
    >
    >-> 객체는 원본이 변경된다(객체타입의 값은 변경 가능한 값이다. : mutable)
    >
    >```javascript
    >console.log(person) // { name: 'kim' }
    >```

- 여러개의 변수가 참조에 의한 전달방식을 통해 참조값을 공유하고 있다면, 언제든지 참조하고 있는 객체를 직접 변경할 수 있다. <br>이는, 상태 변화를 추적하기 어려워지며, 코드의 복잡성을 증가시키고 가독성을 해치는 원인이 된다. <br>∴  객체를 <u>불변 객체</u>로 만들어 사용하면 된다.

  > <u>불변 객체</u>
  >
  > - 객체를 마치 원시값처럼 변경 불가능한 값으로 동작하게 만드는 것이다. 
  >
  > - 깊은 복사를 통해 새로운 객체를 생성하여 재할당을 통해 교체한다.

---

## 즉시실행함수

- 함수를 정의함과 동시에 호출 되는 함수

- 단 한번만 호출되고, 그 이후에 또 호출할수 없다. 

- 즉시 실행함수는 반드시 그룹 연산자인 `( )` 이것으로 감싸줘야 한다. <br>그룹 연산자로 감싸는 이유는, 함수 객체를 생성하기 위함이다. 

- 익명함수를 쓰는 것이 일반적이다. 

  ```javascript
  (function(){
  	var a = 3;
  	var b = 5;
  	return a + b
  })(); // 8
  ```

- 기명함수를 써도 되긴 하는데, 기명함수의 함수이름으로는 호출안되고, 기명함수를 할당한 식별자로 호출해야만 한다. <- 그룹 연산자인 `( )` 이것의 내부에 있는 기명함수는 함수선언문이 아니라 함수 리터럴로 평가된다. 

  ```javascript
  var sum = (function add(){
  	var a = 3;
  	var b = 5;
  	return a + b
  })(); 
  
  console.log(sum) // 8
  ```

- 즉시 실행함수도 일반 함수처럼 값을 반환할수도 있고, 인수를 전달할수도 있다. 

  ```javascript
  var sum = ( function(a, b){
      return a + b;
  })(3, 5)
  
  console.log(sum) // 8
  ```

## 재귀함수 







