# let, const 와 블록 레벨 스코프

ES5 까지 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이었지만.<br>ES6부터는 var 키워드 뿐 아니라, let 키워드와 const 키워드도 사용하여 번수를 사용할수 있게 되었다.

하지만 var 키워드에는 여러 문제점이 있기에, var 키워드보다 let과 const를 사용하는것이 좋다. <br>그렇다면 var 키워드에는 어떤 문제점들이 있을까?

## var 키워드의 문제점

1. 변수 중복 선언의 허용

2. 함수 레벨 스코프

   var 키워드로 선언한 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정하기 때문에 함수 몸체 밖에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다. 

   ```js
   ex 1) if 문 코드 블럭안에서 변수 선언해도 if 문 코드 블럭 밖에서 선언한 변수와 동일하면
   모두 전역변수가 된다.
   
   var x = 1;
   if (true){
       var x = 10;
   }
   console.log(x); // 10
   
   ex 2) for문 코드 블럭안에서 변수 선언해도 for문 코드 블럭 밖에서 선언한 변수와 동일하면 모두 전역변수가 된다.
   
   var i =10;
   for (var i = 0; i < 5; i++) {
       console.log(i) ;
   }
   console.log(x); // 5
   ```

3. 변수 호이스팅 발생

   변수 호이스팅이 발생하면 var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. <br>단, 할당문 이전에 변수를 참조하면 언제나 undefined 가 반환된다. <br>이는 에러를 발생시키지는 않지만 프로그램의 흐름 상 맞지 않을 뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다. 

## let 키워드

지금까지 얘기했던 var 키워드의 문제점을 보완해준다. <br>그렇다면 let 키워드가 뭘까?

- **<u>변수 중복 선언 금지</u>**

- **<u>let 과 const 는 블록 레벨 스코프를 지원한다.</u>**

  하여, let 키워드로 선언한 변수는 모든 코드블록을 또 다른 스코프인 블록 레빌 스코프로 인정하기<br>때문에 다른 스코프라면 동일한 이름의 변수 사용이 가능하다. 

  ![캡쳐98](https://user-images.githubusercontent.com/62126380/81500359-b5f75f80-930c-11ea-933a-d10657f41eb6.png) 

- **변수 호이스팅이 발생 안한다.** (사실은 발생하는거지만... 발생 안하는것처럼 보이는거임)

  let 키워드는 변수 호이스팅이 발생 안하는걸로 이해하자. <br>왜냐하면, var 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 동시에 일어나지만, 								<u>let 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 분리되어 진행</u>되기 때문이다.  

  ![](https://user-images.githubusercontent.com/62126380/81501156-b514fc80-9311-11ea-936e-da8ec261229f.PNG)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

  ==> 런타임 이전에 암묵적으로 "선언 단계"가 먼저 실행되지만 "초기화 단계"는 변수 선언문에 도달했을때에야 실행된다. 만약에 "초기화 단계"가 실행되기 이전에 변수에 접근하려고 하면 Reference Error가 난다. 

## 전역 객체와 let

전역객체 : 

- 코드가 실행되기 이전 단계에 JS엔진에 의해 제일 먼저 생성되는 객체
- 어떤 객체에도 속하지 않는 최상위 객체
- 브라우저 환경에서는 window 객체를 , node 환경에서는 global 객체를 가리킨다.

----

1. var 키워드로 선언한 <u>전역 변수</u>와 <u>전역 함수</u>, 그리고 <u>선언하지 않은 변수</u>에 값을 할당한것은 전역 객체의 프로퍼티가 된다. -> 전역 객체의 프로퍼티를 참조할때 window 를 생략할 수 있다.

```js
var x = 1;
y = 2;

function foo(){}

ⓐ console.log(window.x);	// 1
   console.log(x);		// 1

ⓑ console.log(window.y);	// 2
   console.log(y);		// 2

ⓒ console.log(window.foo);	// ƒ foo(){}
   conseole.log(foo);		// ƒ foo(){}
-----------------------------------
ⓐ var 키워드로 선언한 변수와 전역 함수는 전역 객체의 프로퍼티가 되기때문에 window를 사용하여 
   접근하는 것도 가능하고, window를 생략하고 접근하는 것도 가능하다.
ⓑ 선언하지 않은 변수는 암묵적 전역이므로 전역 객체의 프로퍼티가 되기때문에 window를 사용하여 접근하는 것도 가능하고, 
    window를 생략하고 접근하는 것도 가능하다.
ⓒ 함수 선언문으로 정의한 전역 함수는 전역 객체의 프로퍼티이며, 전역 객체의프로퍼티는 전역 변수처럼 사용할수 있다. 
   그러므로 window를 사용하여 접근하는 것도 가능하고, window를 생략하고 접근하는 것도 가능하다.
```

2. let 키워드로 선언한 변수와 함수들은 전역 변수가 아니고 전역 렉시컬 환경의 선언적 환경 레코드 내에 존재하는 것이기 때문에 window의 프로퍼티가 되지 않는다. -> window로 접근할 수 없다. 

```js
let x = 1;
console.log(window.x);	//undefined
console.log(x);		// 1
-------------------------------------
let, const 키워드로 선언한 변수는 전역 객체의 프로퍼티가 아니므로 window를 사용할수 없다.
```



# const 키워드

constant(상수) 의 줄임말로 const 라고 쓰인다.<br>뜻이 "상수"라서 상수에 대해서만  쓰여야 할것 같은 느낌이지만, 꼭 그렇지만은 않다. *<- 우리 var랑 let은 앞으로  쓰지 않기로 해여~~*

let 키워드와 마찬가지로 변수 호이스팅이 발생하지 않는다.(...지만 사실은 변수 호이스팅이 발생하는 것이다.)

### let 키워드와 const 키워드의 차이점

- 선언과 초기화 : <br>let키워드를 사용할때는 변수 선언단계와 초기화 단계가 구분되어있지만, <br>const 키워드를 사용하여 변수에 값을 할당하는 코드를 쓸거면 반드시 const 변수 선언과 값의 할당이 동시에 이뤄져야 한다. <- 안 그러면 SyntaxError(문법 에러)가 난다.

  ```js
  const foo = 1;
  ----------------
  const foo // SyntaxError
  ```

- 재할당 금지 :<br>var 키워드나, let 키워드는 변수에 값의 재할당이 자유롭지만 const 키워드로 사용한 변수는 재할당이 금지된다.

  ```js
  const foo = 1;
  foo = 2; // Error
  ```

- 상수 :<br>상수란 뭘까? 상수는 재할당이 금지된 변수이다. <br>그렇기 때문에 const 키워드로 선언한 변수에 원시값을 할당하면, 그 값은 변경이 불가능하다. <br><- 이 점을 이용하여 일부러 const 키워드를 사용하여 상수를 표현하기도 한다. 

  ![캡쳐105](https://user-images.githubusercontent.com/62126380/81821365-b9892180-956c-11ea-9de0-fb1dd6434e95.PNG)  

  - 위에서 let 키워드로 선언한 코드는 세법을 이용하여 쓴 코드이다. 세율은 바뀌기 어렵기 때문에 <br>아래에 const 키워드로 선언한 코드 처럼 상수로 정의하면 값의 의미를 쉽게 파악할수 있고, <br>변경될 수 없는 고정값으로 사용할수 있다. 

- const 키워드와 객체 :<br>위에서 언급한 것처럼 const 키워드로 선언한 변수에 원시값을 할당하면 이 값은 변경이 불가능하다. 하지만, 객체를 할당하면 값을 변경할 수 있다. 객체는 재할당 없이도 직접 변경이 가능하기 때문이다.

  ```js
  const person = {
      name: 'Lee'
  };
  person.name = 'Kim';
  
  console.log(person);	// {name: "Kim"}
  ```

  위 코드처럼 person이란 객체 내부의 name이란 프로퍼티 키의 값을 'Kim'으로 변경한것이다. -> 값이 'Lee' 에서 'Kim' 으로 변경되었다. 

  

## var 키워드, let 키워드, const 키워드의 추천 사용법

- ES6를 사용한다면 var 키워드는 사용하지 마라
- 재할당이 필요한 경우에만 let 키워드를 사용해라. (이때 변수의 스코프는 좁게 만들어라)
- 변경하지않고 readOnly 한 원시값과 객체에는 const 키워드를 사용해라(const는 재할당을 금지하므로 var랑 let 보다 안전하다)
- var 키워드로 변수를 선언할거면 전부 다 var만 써라. var 도 쓰고 const도 쓰고 하면서 섞어 쓰면 안된다. 