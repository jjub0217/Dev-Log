# 클래스

들어가기에 앞서...

><u>클래스</u>
>
>- 객체를 생성하는 방식들 중 하나이다. 
>
>  >1. 객체리터럴
>  >2. 생성자 함수
>  >3. Object 생성자함수
>  >4. Object.creat 메서드
>  >5. 클래스
>
>- 클래스는 함수이다. 즉, 클래스도 객체이다. 
>- ES5 까지만 해도, 상속관계를 구현하려면 생성자 함수와 프로토타입 객체를 통해서 구현할수 있었지만, ES6부터는, ES6 부터 도입된 클래스를 통해서 상속관계를 구현할수 있게 되었다. 
>- 클래스와 생성자 함수 둘다 프로토타입 기반으로 인스턴스를 생성하는 것으로 유사하게 동작하지만 둘은 엄연히 다르다.<br>즉, 클래스는 객체만을 생성하는 함수(인스턴스를 만드는 전용함수)이다.
>- 객체를 생성하는 새로운 매커니즘으로 보는것이 좀 더 합당하다

## 클래스와 생성자 함수의 차이점

|             | 클래스                                                       | 생성자 함수                                                  |
| ----------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 연산자 사용 | new 연산자를 반드시 함께 사용하여, <br>클래스 함수를 호출해야 한다.<br>( new 연산자 없이 호출하게 되면 에러난다) | new 연산자 없이 호출할수있다. (일반함수 호출)<br>new 연산자로 호출할수 있다.(생성자함수 호출) |
| 상속관계    | 상속관계를 구현하기 위한 키워드로 <br>extends 와  super 키워드가 사용된다. | 상속관계를 구현하기 위한 키워드가 딱히 없다.                 |
| 호이스팅    | 호이스팅이 발생하지만, let 키워드처럼 <br>호이스팅이 발생하지 않는것처럼 동작한다. | 함수선언문으로 생성한 함수는 함수호이스팅 발생<br>함수표현식으로 생성한 함수는 함수 내부에서 변수 호이스팅 발생 |
| strict mode | 암묵적으로 실행되며 해제할수 없다.                           | 암묵적으로 실행되지 않는다.                                  |
| 열거가능    | 열거 불가능                                                  | 열거 가능                                                    |

## 클래스 정의( 클래스 문법 )

- 함수표현식처럼 클래스 정의도 변수에 할당할수 있으며, 변수에 할당할수 있다는 것은 클래스 정의도 값으로 평가될수 있다는 의미이다. <br>즉, 클래스는 값으로 평가될수 있는 객체(일급객체)라는 의미이다. 

  ><u>일급객체가 될수 있는조건</u>
  >
  >- 무명의 리터럴로 생성 가능
  >- 변수나 자료구조(객체, 배열)에 저장가능
  >- 함수의 매개변수에 전달가능
  >- 함수의 반환값으로 사용가능

-  함수 선언문처럼 클래스의 이름이 있을수도 있고 없을수도 있다. 

  ```javascript
  // 클래스 선언문
  
  class Person {
      constructor(name){ //<---------------------------------------------------------------┐
          this.name = name; /* <- constructor 생성자 메서드로 인한, 인스턴스 초기화 단계        │
               ￣￣￣├> name(프로퍼티): name은 프로퍼티이며, public한 프로퍼티이다.              │ 생성자 메서드*/ 
      }// <--------------------------------------------------------------------------------┘
      
      sayHi(){ //<-------------------------------------┐
          console.log(`Hi! my name is ${this.name}`)// │ 프로토타입 메서드
      } //<--------------------------------------------┘
      
      static sayHello(){ //<----------┐
          console.log('Hello!')//     │ 정적 메서드
      } //<---------------------------┘
  }
  
  const me = new Person('주현'); // <- 인스턴스 생성
  
  console.log(me.name) // 주현  
  //└> constructor 생성자메서드 메서드 내부에다가 선언한 프로퍼티를 참조하려면, 생성한 인스턴스로 참조해야 한다
  
  me.sayHi() // Hi! my name is '주현' 
  //└> 프로토타입 메서드를 호출하려면, 생성한 인스턴스로 참조하여 호출해야 한다.
  
  Person.sayHello(); // Hello!
  // └> 정적 메서드를 호출하려면, 정적메서드를 소유하고 있는 클래스 이름으로 참조하여 호출해야 한다.
  ```

  ```javascript
  // 생성자함수 선언문
  
  const Person = (function () {
      
    function Person(name) { //<-----------┐
      this.name = name; /*                │ 생성자함수*/
    } // <--------------------------------┘
  
    Person.prototype.sayHi = function () { //<-------------┐
      console.log(`Hi! my name is ${this.name}`) // 	     │ 프로토타입 메서드
    } //<--------------------------------------------------┘
  
    Person.sayHello = function () { //<--------┐
      console.log('Hello!') //                 │ 정적 메서드
    } //<--------------------------------------┘
      
    return Person; //<- 생성자함수 반환
  })();
  
  const me = new Person('주현'); // <- 인스턴스 생성
  
  console.log(me.name) // 주현  
  //└> 인스턴스를 생성하는 함수인 생성자함수 내부에다가 선언한 프로퍼티를 참조하려면, 생성한 인스턴스로 참조해야 한다.
  
  me.sayHi() // Hi! my name is '주현' 
  //└> 프로토타입 메서드를 호출하려면, 생성한 인스턴스로 참조하여 호출해야 한다.
  
  Person.sayHello(); // Hello!
  // └> 정적 메서드를 호출하려면, 정적메서드를 소유하고 있는 생성자함수 이름으로 참조하여 호출해야 한다.
  ```

1. 일반 함수 정의할때 function 키워드 대신 class 라는 키워드가 쓰인다고 생각하면 이해하기 쉽다.
2. 소괄호 ( ) 가 쓰이지 않고, 바로 중괄호 { }가 쓰인다. 

3. 생성자함수와 마찬가지로 파스칼케이스가 쓰이는 것이 일반적이다.

4. 클래스 몸체에는 0개 이상의 메서드만 정의할수 있다. 

### 클래스 메서드

---

- function 키워드를 생략한 메서드 축약표현을 사용
- 클래스 메서드를 정의할때는, 클래스 내부에서 콤마가 필요없다.
- 암묵적으로 strict 모드가 실행된다.
- 열거할수 없다.( 클래스 메서드의 프로퍼티어트리뷰트 [[Ecumerable]]라는 내부슬롯의 값이 false이기 때문이다)
- new 연산자와 함께 호출할수 없다.

#### 1. constructor 생성자 메서드

- 인스턴스를 생성하고, 초기화 하기 위한 특수한 메서드다.

- 이름을 변경할수 없다.

- constructor 생성자 메서드는 클래스 내에, 한개만 존재해야 한다. 

  ```javascript
  // 클래스 선언문
  
  class Person {
      constructor(name){ //<------------------------------------------------------------------------┐
          this.name = name;/*                                                                       │
          ￣￣│ ￣￣￣├> name : name은 this에 추가한 프로퍼티(= Person 클래스가 생성한 인스턴스의 프로퍼티) │
              ├> Person 클래스가 생성한 인스턴스                                                       │*/
  		} //<-------------------------------------------------------------------------------------┘
    }// <- 인스턴스 초기화 과정(constuctor 생성자 메서드 내부의 this 에 인스턴스 프로퍼티 추가)
  
  const me = new Person('주현'); // '주현'(인스턴스 프로퍼티의 초기값) -> consturctor 메서드의 매개변수에 전달
  console.log(me) // Person { name: '주현' } <- Person 클래스로 생성한 인스턴스 : { name: '주현' }
  ```

- 클래스 정의가 평가단계를 거치면, constructor 생성자 메서드 내부에 코딩된 코드들이 동작하는 함수객체가 생성된다.

- 클래스의 constructor 생성자 메서드 내부에 return 값을 명시적으로 반환하면, <br>eturn 문 이전에, 암묵적으로 만들어진 인스턴스에, 초기화하면서 추가한 프로퍼티들로 꾸려진 인스턴스가 반환 되는것이<br>아니라, 명시적으로 반환한 return 값이 반환되기 때문에, constructor 생성자 메서드 내부에는, <br>생성자 함수 내부처럼 return 값을 명시적으로 주면 안되다. 또한, 생성자함수 내부처럼, return 값으로 원시값을 주면 <br>해당 원시값은 무시된다. 

- constructor 생성자 메서드는 생략이 가능한데,  인스턴스의 프로퍼티가 필요없는 경우에 생략이 가능하다.<br>인스턴스를 초기화하려면 constructor 생성자메서드는 반드시 필요하다.  

  - constructor 생성자 메서드를 생략하게 되면, 클래스 내부에 빈 객체가 생성이 된다.

    ```javascript
    class Person {
     // <- constructor 생성자 메서드 생략
    }
    
    const me = new Person();
    console.log(me) // Person {} <- Person 클래스로 생성한 빈객체 
    ```

#### 2. 프로토타입 메서드

- 생성자함수에서는, 프로토타입 메서드를 생성하려면,<br>`생성자함수 이름.prototype.메서드 이름` 으로 선언한 것에 함수를 할당시켰어야 했는데, <br>클래스에서 프로토타입 메서드를 생성하려면, <br>클래스의 prototype 프로퍼티에 메서드를 참조하지 않아도 된다.

  ```javascript
  // 클래스가 생성한 인스턴스는 프로토타입 체인의 부분이 된다.
  
  class Person {
      sayHi(){ //<-------------------------------------┐
          console.log(`Hi! my name is ${this.name}`)// │ 프로토타입 메서드
      } //<--------------------------------------------┘
  }
  
  const me = new Perosn('주현')
  me.sayHi(); // Hi! my name is '주현'
  
  
  Object.getPrototypeOf(me) === Person.prototype // true
  // └> me 의 부모객체가, Person.prototype 객체가 맞냐? : true
  Object.getPrototypeOf(Person.prototype) === Object.prototype; // true
  // └> me 의 부모객체인, Perosn.prototype의, 부모객체가, Object.prototype 객체가 맞냐? : true
  
  me instanceof Person; // true 
  // └> Person 객체의 인스턴스가 me 가 맞냐? : true
  me instanceof Object; // true
  // └> Object 객체의 인스턴스가 me 가 맞냐? : true
  
  Person.hasOwnProperty('constructor') // false
  // └> Person 클래스는 constructor 프로퍼티를 가지고있지 않다.
  console.log(Person.prototype.hasOwnProperty('constructor')); // true
  // └> Person.prototype 객체는 constructor 프로퍼티를 가지고 있다. 
  
  me.constructor === Person; // false
  // └> me 의 부모객인 Person.prototype 객체가 소유하고 있는 constructor라는 프로퍼티를, me 라는 인스턴스가
  // 	  상속받아서 사용할수 있으므로, me.constructor 로 접근하면 Person 클래스가 나온다.
  ```

#### 3. 정적메서드

---

- 인스턴스를 생성하지 않아도 호출할수 있는 메서드

- static 키워드를 붙여서 사용해야 한다.

- 프로토타입 체인 상에 클래스가 존재하지 않기 때문에, 클래스의 정적메서드는 인스턴스가 상속받아 사용할수 없다.

  ```javascript
  // 클래스 선언문
  
  class Person {
      
      static sayHello(){ //<----------┐
          console.log('Hello!')//     │ 정적 메서드
      } //<---------------------------┘
  
  }
  
  const me = new Person('주현'); // <- 인스턴스 생성
  
  me.sayHello(); // TypeError <- 클래스의 정적메서드는 인스턴스가 상속받아서 사용하지 못하기 때문에 에러가 난다.
  Person.sayHello(); // Hello!
  // └> 정적 메서드를 호출하려면, 정적메서드를 소유하고 있는 클래스 이름으로 참조하여 호출해야 한다.
  ```

---

#### 정적메서드 와 프로토타입 메서드의 차이점

```javascript
// 클래스 선언문

class Person {
    constructor(name){ //<---------------------------------------------------------------┐
        this.name = name; /* <- constructor 생성자 메서드로 인한, 인스턴스 초기화 단계        │
             ￣￣￣├> name(프로퍼티): name은 프로퍼티이며, public한 프로퍼티이다.              │ 생성자 메서드*/ 
    }// <--------------------------------------------------------------------------------┘
    
    sayHi(){ //<-------------------------------------┐
        console.log(`Hi! my name is ${this.name}`)// │ 프로토타입 메서드
    } //<--------------------------------------------┘
    
    static sayHello(){ //<----------┐
        console.log('Hello!')//     │ 정적 메서드
    } //<---------------------------┘
}

const me = new Person('주현'); // <- 인스턴스 생성

console.log(me.name) // 주현  
//└> constructor 생성자메서드 메서드 내부에다가 선언한 프로퍼티를 참조하려면, 생성한 인스턴스로 참조해야 한다

me.sayHi() // Hi! my name is '주현' 
//└> 프로토타입 메서드를 호출하려면, 생성한 인스턴스로 참조하여 호출해야 한다.

Person.sayHello(); // Hello!
// └> 정적 메서드를 호출하려면, 정적메서드를 소유하고 있는 클래스 이름으로 참조하여 호출해야 한다.
```

|                                      | 정적 메서드                                                  | 프로토타입 메서드                                            |
| ------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 자신이 속해있는<br>프로토타입 체인   | Person 클래스                                                | Person.prototype 객체                                        |
| 메서드를 호출하는 대상__             | 클래스로 호출                                                | 인스턴스로 호출                                              |
| 내부에서의 this                      | 클래스로 호출해야 하기때문에, <br>정적 메서드의 내부의, this는,<br>정적 메서드를 호출한, 클래스를 가리킨다. | 인스턴스로 호출해야 하기때문에,<br>프로토타입메서드의 내부의, this는,<br>프로토타입 메서드를 호출한, 인스턴스를 가리킨다. |
| 내부에서의 this 사용법               | this를 사용하지 않는 메서드를 <br>정의할때는 정적메서드로 정의 | 1. 인스턴스 프로퍼티를 참조하려면 <br> :  프로토타입메서드 내부에서 this를 사용해서 정의.<br>2. 인스턴스 프로퍼티를 참조할 필요가 없다면<br>: this를 사용하지 않아야 한다. |
| 프로퍼티 참조<br>(인스턴스 프로퍼티) | 인스턴스 프로퍼티 참조 불가능                                | 인스턴스 프로퍼티 참조 가능                                  |
| 장점                                 | 1. 전역에서 사용할 유틸리티 함수<br>2. 정적메서드를 모아 놓으면 <br>네임스페이스의 충돌 가능성을 줄여주고, <br>관련 함수들을 구조화할수 있다. |                                                              |

### 클래스 인스턴스

---

- 클래스는 new 연산자와 함께 호출되어 인스턴스를 생성하는 함수이다.

- 클래스는 인스턴스를 생성하는 전용함수이므로, 반드시 new 연산자와 인스턴스를 함께 호출해야 한다.

- 함수표현식처럼 변수에 클래스를 할당할수 있는데, 변수에 할당한 클래스이던, 아니던<br> 반드시 클래스를 가리키는 식별자로 인스턴스를 생성해야 한다. 

  ```javascript
  // 클래스 선언문
  
  class Perosn { }
  const me = new Person(); // <- 인스턴스 생성
  
  // ---------------------------------------------------
  
  // 클래스 표현식
  
  const Person = class MyName { }
  const my = new Myname(); // Refernce Error
  const my = new Person(); // <- 인스턴스 생성
  ```

#### 클래스 인스턴스 생성과정

---

```javascript
// 클래스 선언문

class Person {
    // ② <- 암묵적으로 빈 객체(클래스가 생성한 인스턴스) 생성
    // ③ <- Person.prototype 객체 생성
    // ④ <- 클래스 내부의 this에, 클래스가 생성한 인스턴스가 바인딩
    
    constructor(name){ //<----------------┐
        this.name = name;/*               │ ⑤ constructor 생성자 메서드 실행*/ 
    } //<---------------------------------┘	    -> 인스턴스 초기화(=인스턴스 프로퍼티 추가)  
    
    // ⑥ <- 완성된 인스턴스가 바인딩괸 this가 암묵적으로 반환
}

const me = new Person('주현'); // ① new 연산자와 클래스 이름을 함께 사용하여, 클래스 호출
```

① new 연산자와 클래스 이름을 함께 사용하여, 클래스 호출

② 암묵적으로 빈 객체(클래스가 생성한 인스턴스) 생성

③ Person.prototype 객체 생성

④ 클래스 내부의 this에, 클래스가 생성한 인스턴스가 바인딩

⑤ constructor 생성자 메서드 실행 -> 인스턴스 초기화(=인스턴스 프로퍼티 추가) 

⑥ 완성된 인스턴스가 바인딩괸 this가 암묵적으로 반환

### 클래스 프로퍼티

---

#### 1. 인스턴스 프로퍼티( = 클래스 필드)

- constructor 생성자 메서드 내부에서 정의해야 한다.

- 인스턴스 프로퍼티를 선언하고, 인스턴스 프로퍼티를 초기화하려면 반드시 constructor 생성자 메서드 내부에서, 반드시<br>this 라는 키워드를 사용애햐 한다. <br>그런데, 현재 this를 사용하지 않아도 클래스필드(프로퍼티)를 선언할수 있도록 TC39에 제안되어있다.

  #### 1-1. 클래스 필드 제안 ( TC39에 제안)

  ---
  - 인스턴스 프로퍼티를 선언하고, 인스턴스 프로퍼티를 초기화하려면 반드시 constructor 생성자 메서드 내부에서, 반드시<br>this 라는 키워드를 사용해야 하지만, 현재 this를 사용하지 않아도 클래스필드(프로퍼티)를 선언할수 있도록 <br>TC39에 제안되어있다.

    ```javascript
    // 클래스 선언문
    
    // 인스턴스 초기화 방식:  constructor 메서드 내부에서 this 키워드에 프로퍼티 추가
    
    class Person {
      constructor(name){ //<-------------------------------------------------------- --------┐
          this.name = name;/*                                                                │
          ￣￣│ ￣￣￣├> name : this에 추가한 프로퍼티(= Person 클래스가 생성한 인스턴스의 프로퍼티) │ 생성자메서드           ├> Person 클래스가 생성한 인스턴스                                                │*/
       } //<---------------------------------------------------------------------------------┘
      }// <- 인스턴스 초기화 과정(constuctor 생성자 메서드 내부의 this 에 인스턴스 프로퍼티 추가)
    
    const me = new Person('주현');
    console.log(me) /* Person { name: '주현' }
    -------------------------------------------------------------------------------------------------*/
    
    // 인스턴스 초기화 방식 : TC39에, this를 사용하지 않아도 되게끔 새로운 클래스 필드 정의 방식을 제안
    
    class Person { //<------------------┐
          name = '주현' } //<------------┘ 클래스 필드 정의
          
    const me = new Person('주현');
    console.log(me) // Person { name: '주현' }
    
    ```

  - 현재 TC39에 제안된 방식으로 클래스 필드를 정의할때는, this 키워드에 프로퍼티를 추가하면 안된다. <br>this 키워드는 클래스 몸체 내부에서 constructor 생성자 메서드 내부에서만 유효하기 때문이다.

    ```javascript
    // 인스턴스 프로퍼티 초기화 방식 : TC39에, this를 사용하지 않아도 되게끔 새로운 클래스 필드 정의 방식을 제안
    // └> this 키워드에 프로퍼티를 추가하면 에러가 난다.
    
    class Person { //<-------------------┐
          this.name = '주현' } //<--------┘ 클래스 필드 정의
          
    // Syntax Error (문법에러)
    ```

  - 현재 TC39에 제안된 방식으로 클래스 필드를 정의할때는, 클래스 필드에 값(초기값)을 할당하지 않으면, 클래스 필드의 값은 undefined 가 나온다.

    ```javascript
    // 인스턴스 프로퍼티 초기화 방식 : TC39에, this를 사용하지 않아도 되게끔 새로운 클래스 필드 정의 방식을 제안
    // └> 클래스 필드(인스턴스 프로퍼티)에 값을 할당하지 않으면, 해당 클래스필드의 값은 undefined 가 나온다.
    
    class Person { //<-------┐
          name; } //<--------┘ 클래스 필드 정의
          
    const me = new Person('주현')
    console.log(me); // Person { name : undefined } 
    ```

  - 클래스필드에, 값으로 함수를 할당하게 되면, 이 함수는 프로퍼티가 아니라 메서드가 된다.

  #### 1-2. 클래스 private  필드 제안 ( TC39에 제안)

  ---

  - 인스턴스 프로퍼티를 선언하고, 인스턴스 프로퍼티를 초기화하려면 반드시 constructor 생성자 메서드 내부에서, this와 초기화하려는 프로퍼티를 같이 참조해야 한다.<br>이렇게 선언하고 참조한 인스턴스 프로퍼티는 언제 어디서든 참조가 가능하다는, public한 프로퍼티가 된다.
  - public한 프로퍼티는 외부에 그대로 노출되기 때무에 보안상 취약하기때문에, 보안성을 높일수 있도록 TC39에 제안되어있다.
    - public 한 프로퍼티를 private한 프로퍼티로 만드려면, 클래스 필드 앞에 `#` 을 붙이면 된다.

  - private한 클래스 필드는 클래스 몸체 내부에서만 참조할수 있다. 

    ```javascript
    // 클래스 선언문
    
    // 인스턴스 프로퍼티(클래스 필드)는 언제나 public하다.
    
    class Person { //<-------------┐
      name = '주현'; //<------------┘ public한 클래스 필드 정의
      constructor(name) { //<--┐
        this.name = name;//    │ public한 클래스 필드 참조
      } //<--------------------┘ 
    } 
          
    const me = new Person('주현');
    console.log(me.name) /* '주현' <- public한 클래스 필드인 name인 클래스 외부에서 참조할수 있다.
    
    -------------------------------------------------------------------------------------------------*/
    
    // public한 클래스필드를, 접근하기 어렵게 private 하게 만드는 클래스 필드를 정의
    
    class Person { //<-------------┐
      #name = '주현'; //<-----------┘ private한 클래스 필드 정의
      constructor(name) { //<--┐
        this.#name = name;//    │ private한 클래스 필드 참조
      } //<--------------------┘ 
    } 
          
    const me = new Person('주현');
    console.log(me.#name) // SyntaxError: Private field '#name' must be declared in an enclosing class
    // └> private한 클래스 필드인 #name 은 클래스 외부에서 참조할수 없다. 
    ```

  #### 1-3. 클래스 static public 필드 / 클래스 static private 필드 / 클래스 static 메서드  제안 ( TC39에 제안 )

  ---

  - static 키워드를 사용해서, public한 클래스 필드와 private한 클래스 필드, 그리고 정적 메서드를 생성할수 있도록 TC39에 제안

    ```javascript
    // 클래스 선언문
    
    class Person { //<-----------------┐
      static name = '주현'; //<------┘ static public 클래스 필드 정의
    
      static #age = 33; // <- static private 클래스 필드 정의 
    
      static sayHello() { //<-------------------------┐
        return `${Person.name}의 나이는 ${Person.#age}이다.`//<- static 메서드//
      } //<----------------------------------------┘
    }    
    
    console.log(Person.name) // 주현  
    console.log(Person.sayHello()) // Hi! my name is '주현' 
    ```

#### 2. 접근자 프로퍼티

---

- 접근자 프로퍼티는 자체적으로 값을 가지고 있는 것이 아니라, 데이터 프로퍼티의 값을 읽거나 저장할때 사용하는 함수로 구성되어 있다. 
- 접근자 프로퍼티는 ( )로 호출하는게 아니다. <br>값을 저장하고, 접근자 프로퍼티 이름으로 참조만 해야, 접근자 프로퍼티 함수가 호출된다.

- 접근자 프로퍼티로 구성되어있는 함수에는 getter 함수와 setter 함수가 존재한다.

  - getter 함수 
    - 인스턴스 프로퍼티에 접근할때마다, 프로퍼티 값을 조작하거나 별도의 행위가 필요할때 사용
    - 프로퍼티처럼 참조하는 형식으로 사용하며, 참조 할때 내부적으로 getter 함수가 호출된다.
    - 반드시 무언가를 return 해야 한다.
  - setter 함수
    - **<u>인스턴스 프로퍼티에 값을 할당할때마다</u>** 프로퍼티 값을 조작하거나 별도의 행위가 필요할때 사용
    - 프로퍼티처럼 값을 할당하는 형식으로 사용하며, 할당 할때 내부적으로 setter 함수가 호출된다.
    - 반드시 매개변수가 있어야 하며, 단 하나의 값만 할당할수 있다.

  ```javascript
  // 객체리터럴로 만든 객체의 접근자 프로퍼티 동작 과정
  
  const Person = {
    firstName : '주현',
    lastName : '강',
    
    get fullName(){
      return `내 이름은 ${this.lastName} ${this.firstName}이다.`
    },
    set fullName(name){
      return [this.firstName, this.lastName] = name.split(' ')
    } 
  }
  
  
  console.log(Person.firstName); // 주현 <----┐
  console.log(Person.lastName); // 강 <-------┘ 데이터 프로퍼티 참조
  
  
  console.log(Person.fullName); // 내 이름은 강주현이다.<- 접근자 프로퍼티를 통한 프로퍼티 참조(getter 함수 호출)
  
  Person.fullName = '세진 오'; // <- 접근자 프로퍼티를 통한 프로퍼티 참조(setter 함수 호출)
  console.log(Person); // { firstName: '세진', lastName: '오'}
  ```

  ```javascript
  // 클래스로 만든 객체의 접근자 프로퍼티 동작 과정
  
  class Person {
    constructor(firstName, lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
    }
  
    get fullName() {
      return `내 이름은 ${this.lastName} ${this.firstName}이다.`
    }
    set fullName(name) {
      return [this.firstName, this.lastName] = name.split(' ')
    }
  }
  
  const me = new Person('주현', '강')
  
  console.log(me.firstName); // 주현 <----┐
  console.log(me.lastName); // 강 <-------┘ (데이터 프로퍼티 참조)
  //										  클래스로 생성한 객체의 데이터 프로퍼티는 인스턴스로 참조해야 한다.
  
  console.log(me.fullName); // 내 이름은 강주현이다.<- 접근자 프로퍼티를 통한 프로퍼티 참조(getter 함수 호출)
  //											   클래스로 생성한 객체의 접근자 프로퍼티는 인스턴스로 참조해야한다.
  
  me.fullName = '세진 오'; // <- 접근자 프로퍼티를 통한 프로퍼티 참조(setter 함수 호출)
  //							  클래스로 생성한 객체의 접근자 프로퍼티는 인스턴스로 참조해야한다.
  
  console.log(me); // { firstName: '세진', lastName: '오'}
  ```

## 클래스 호이스팅

- 클래스도 함수이며, 객체이다.
- 클래스와 생성자함수는 인스턴스를 생성하는 함수라는 점에서는 같으나, 동작하는 과정이 다르다.
- 클래스 선언문도 생성자함수 선언문처럼 호이스팅이 원래는 발생하지만, 호이스팅이 발생안하는 것처럼 동작한다.<br>즉, let 키워드나 const 키워드처럼 "일시적 사각지대"가 존재하기 때문에 클래스 호이스팅은 발생하지만, 안하는 것처럼 동작한다는 것이다. 

## 클래스 상속

- 상속에 의한 클래스 확장은 기존 클래스를 상속받아서, 새로운 클래스를 확장하여 정의하는 것이다.

#### extends 키워드로 확장하여 상속

- 클래스도 객체이기 때문에 프로토타입 객체를 생성하며, 프로토타입 체인을 통해 상속을 하고, 상속을 받을수 있다. 

- 클래스를 통해 상속구조를 구현하려면 extends 라는 키워드를 사용하여 상속관계 구조를 구현할수 있다. 

  - 수퍼 클래스 : 클래스 함수를 통해 생성된 부모 객체
  - 서브 클래스 : 클래스 함수를 통해, extends 키워드를 사용하여 생성한, 자식 객체

- 수퍼 클래스의 속성을, 서브 클래스는 상속받으면서, 서브 클래스 고유의 속성도 추가할수 있다.

  ```javascript
  class Animal { /* <---------------------------------------------┐
                                                                  │*/
      constructor(age, weight) { // <-┐                           │
        this.age = age;//             │                           │
        this.weight = weight;//       │ constructor 생성자 메서드   │
      } /*<---------------------------┘                           │
                                                                  │*/
      eat() { // <-------------┐                                  │
          return '먹는다';//    │ 수퍼 클래스의, 프로토타입 메서드     │  <- 수퍼 클래스
      }/* <--------------------┘                                  │
                                                                  │*/
      move() { // <------------┐                                  │
          return '움직인다';//  │ 수퍼 클래스의, 프로토타입 메서드     │
      }/* <--------------------┘                                  │
                                                                  │*/
  } // <----------------------------------------------------------┘
  
  
  // extends 키워드를 사용하여, 부모객체인 수퍼 클래스와 자식객체인 서브 클래스사이의 상속관계 구조를 구현할수 있다.
  
  class Bird extends Animal { // "클래스 Bird 확장한 을Animal"
      						// <-------------------------
      fly(){
          return '날다'
      }
  }
  
  const bird = new Bird(1, 5); // <- Bird의 특징(1, 5 : 수퍼 클래스의 constructor 내부로 들어가는 인수)
  ```

  ![44](https://user-images.githubusercontent.com/62126380/96577993-739c6a80-130f-11eb-8d3f-292c17d4db38.jpg)

#### 수퍼클래스로 생성한 인스턴스 생성 과정

---

![46](https://user-images.githubusercontent.com/62126380/96583518-ce39c480-1317-11eb-9c91-21c9fad0b41d.jpg)

① 서브클래스 내부의 constructor 메서드 내부에서의 super 호출

② 수퍼클래스 내부에서 암묵적으로 빈 객체(수퍼클래스가 생성한 인스턴스) 생성

③ Rectangle.prototype 객체 생성

④ 수퍼클래스 내부의 this에, 수퍼클래스가 생성한 인스턴스가 바인딩

⑤ 수퍼클래스 내부의 constructor 생성자 메서드 실행 -> 수퍼클래스가 생성한 인스턴스 초기화(=인스턴스 프로퍼티 추가) 

⑥ 수퍼클래스 내부에서 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환

⑦ 서브클래스 내부의 constructor 메서드로 복귀

⑧ 수퍼클래스에서 완성된 인스턴스가, 서브클래스 내부의 constructor 내부에서의 this 에 바인딩

⑨ 서브클래스 내부의 constructor 생성자 메서드 실행 -> 서브클래스가 생성한 인스턴스 초기화 (= 인스턴스 프로퍼티 추가)

⑩ 서브클래스 내부에서 완성된 인스턴스가 바인딘된 this가 암묵적으로 반환

 ### super 키워드로 상속 및 호출

---

#### super 호출

---

- super 키워드는 함수처럼 호출도 되고 식별자처럼 참조도 가능한 특수한 키워드이다. 

- 수퍼클래스의 constructor 생성자메서드 내부에 추가한 프로퍼티 + 서브 클래스의 constructor 생성자 메서 내부에 추가한 프로퍼티 둘다 상속받는 인스턴스를 생성하려면, <br>서브 클래스에서 constructor 생성자 메서드를 생략할수 없고, <br>서브클래스의 constructor 내부에서 super 라는 키워드를 사용하여호출해야 한다.

  - super 를 호출하면 수퍼클래스의 constructor 를 호출한다.
  - 서브클래스의 constructor 내부에서 super를 호출하기 이전에는 this를 참조할수 없다 : super 이전에 this가 만들어져있지 않다.
  - 서브클래스 내부에서 constructor를 생략하게 되면, 서브클래스 내부에서 super 를 호출하지 않아도 된다. 
  - super는 반드시 서브클래스 내부의 constructor 메서드 내부에서만 호출해야 한다.  

- 인스턴스를 초기화하려고 전달한 인수는 수퍼클래스와, 서브클래스에 배분되어 전달이 되고, 수퍼클래스와 서브클래스는 서로 <br>협력하여 인스턴스를 생성한다.

  ![45](https://user-images.githubusercontent.com/62126380/96581313-954c2080-1314-11eb-9a2f-6b4c305ebfbb.JPG)

#### super 참조

---

- super 를 참조하면 수퍼클래스의 메서드를 호출한다.
- **<u>서브클래스 내부의, 프로토타입 메서드 내부</u>**에서, `super.수퍼클래스의 프로토타입 메서드 이름`을 참조하면, <br>수퍼클래스의 프로토타입 메서드를 가리키게 된다.
- **<u>서브클래스 내부의, 정적 메서드 내부</u>**에서 `super.수퍼클래스의 프로토타입 메서드 이름` 을 참조하게 되면,<br>수퍼클래스의 정적 메서드를 가리키게 된다.
- 수퍼클래스의 프로토타입메서드를 호출할때는, 서브클래스 내부에서 call 메서드를 사용해서 this 를 전달해야 한다. 