# 함수와 일급객체

함수 = 객체.<br>객체 = 값.<br>함수 = 값

위 식처럼 누차 말하지만 함수는 객체라서, 함수를 객체와 동일하게 사용할수 있다. <br>또한, 객체는 값이므로 함수는 값과 동일하게 취급할 수 있다.<br>그 객체에는 '일급 객체' 라는 정의가 존재한다.<br>해당 정의가 성립되려면 아래의 전제 조건을 만족해야 한다.

1. __무명의 리터럴__로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.<br>--> 무명의 리터럴이 생성이 가능하다는 문법을 제공한다는 건, 무명 리터럴을 <br>__변수에 할당하라__는 의미와 동일하다. 즉, 무명 리터럴을 변수에 할당하는 것을 "함수 표현식"이라고 할수 있으니까, __무명의 리터럴(=함수표현식)의 함수 객체는 런타임에 생성된다__는 것과 동일한 의미이다. 
2. 함수를 변수나, 하나의 값만 갖는게 아닌 복합적으로 여러개의 값을 가질 수 있는 자료구조(객체, 배열 등)에 저장할 수 있다. 
3. 함수의 매개 변수에게 전달할 수 있다.
4. 함수의 결과값으로 반환 할 수 있다. 

하지만 객체와 함수는 엄밀히 따지만 같지 않다. <br>함수는 객체의 특징을 모조리 싹 다 갖고 있지만, 객체는 함수의 특징을 모두 다 갖고 있지는 않기 때문이다. 객체는 가지고 있지 않지만 함수만 갖고 있는 고유의 특징들 중 하나는, 호출을 할 수 있다는 점과 `함수 고유의 프로퍼티`를 갖고 있다는 점때문에 함수와 객체는 엄격히 말하면 같지 않다.

> __함수 고유의 프로퍼티__
>
> - arguments 프로퍼티
> - caller 프로퍼티
> - length 프로퍼티
> - name 프로퍼티
> - prototype 프로퍼티
> - __ proto __ 접근자 프로퍼티



## arguments 프로퍼티

- arguments 프로퍼티 값은 arguments 객체이다.

  ```js
  function () {
      arguments : arguments 객체
  }
  ```

  - arguments 객체는 유사 배열 객체이다.
  - arguments 객체는 함수 외부에서는 참조 할수 없다.

- 함수가 호출되면 `함수 몸체 내에서 암묵적으로 매개변수가 선언 -> undefined로 초기화 -> 인수 할당`의 과정을 거친다.

  ```js
  function muitiply(x, y) {
      // <- 암묵적으로 매개변수가 선언
      // <- undefined 로 매개변수 초기화 -> 인수 (1, 2)이 매개변수 (x, y)에 할당
      console.log(arguments);
      return x * y;
  }
  
  console.log(multiply(1, 2, 3)); // 2
  -------------------------------------------------
      ▶ Arguments(3)
  		0 : 1  ─┐
  		1 : 2	│ arguments 객체
  		2 : 3  ─┘
  
  0, 1, 2 = 인수의 순서 (arguments 객체에서 프로퍼티 키는 인수의 순서를 나타낸다.)
  1, 2, 3 = 인수 = 프로퍼티 값  (arguments 객체는 인수를 프로퍼티 값으로 소유한다.)
  ```



- __arguments 객체의 length 프로퍼티는 인수의 개수를 나타낸다.__<br>arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로 fot문으로 순회할 수 있다. 



## caller 프로퍼티

비 표준 프로퍼티이다.

함수 객체의 caller 프로퍼티는 함수 자신을 호출한 함수를 가리킨다는 것 말고는 별로 알 필요없다. 



## length 프로퍼티

__매개변수의 개수를 나타낸다.__

length 프로퍼티와 arguments 객체의 length 프로퍼티는 다른 것이다. <br>위에서도 언급했듯이, arguments 객체의 length 프로퍼티는 인수의 개수를 나타내고,<br>함수 객체의 length 프로퍼티는 매개 변수의 개수를 나타낸다.

```js
ex 1)

function foo(){
    console.log(foo.length);
}
// 0

ex 2)

function bar(x) {
    console.log(bar.length);
}
// 1

ex 3)

function baz(x, y) {
    console.log(baz.length);
}
// 2
```



## name 프로퍼티

함수 객체의 name 프로퍼티는 함수 이름을 나타낸다.

기명 함수 표현식에서의 name 프로퍼티와, 무명 함수 표현식에서의 name 프로퍼티가 함수 이름을 가리킨다는 것은 동일하지만, 무명 함수 표현식일때 ES5 문법에서와 ES6 문법에서는 가리키는것이 다르다.

무명 함수 표현식일때 ES5 문법에서는 name 프로퍼티가 함수 이름을 가리키지만,<br>ES6 문법에서는 name 프로퍼티가 함수 객체를 가리키는 변수 이름을 가리킨다.

```js
< 기명 함수 표현식일때의 name 프로퍼티>

var namedFunc = function foo() {};
console.log(namedFunc.name); 
// foo

---------------------------------------

<익명 함수 표현식일때의 name 프로퍼티> 

var barFunc = function () {};

console.log(barFunc.name);
// barFunc 
```



## prototype 프로퍼티

- 함수 객체만이 소유하고 있는 프로퍼티이다. 일반 객체에는 prototype 프로퍼티가 없다.

  ```js
  
  console.log((function(){}). hasOwnProperty     ('prototype')); // true
  ==> 	  " 함수 객체가     갖고있는 property에  'prototype'이라는 프로퍼티가 있다" //true
  -------------------------------------------------------------------------------------
  
  console.log(((){}).    hasOwnProperty     ('prototype')); // false
  ==>      " 일반 객체가  갖고있는 property에   'prototype'이라는 프로퍼티가 있다" //false
  
  ```

- 생성자 함수로 사용될때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.

  ```js
  var Person = function () {
      name: 'Lee';
      sayHi: function () {};
  }
  ```

  ![캡쳐115](https://user-images.githubusercontent.com/62126380/82549208-87dd0f80-9b97-11ea-9666-6583b47a51af.PNG) 



## __ proto __ 접근자 프로퍼티

모든 객체에는 [[prototype]] 이라는 내부슬롯을 갖고있는데, 이 내부슬롯에는 원래 직접 접근할 수 없다. <br>하지만, __ proto__ 라는 프로퍼티를 사용하면 `[[prototype]]` 이라는 내부슬롯에 간접적으로는 접근할수 있다.

> __[[prototype]]__
>
> 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다.





#  프로토타입

JS는 명령형으로도 짤수 있고, 함수형으로도 짤수 있고, 프로토타입 기반의 객체 지향으로도 짤수 있는 멀티 패러다임 프로그래밍 언어다. 그리고 JS는 프로토타입 기반의 언어이며, 객체 기반의 프로그래밍 언어이기 때문에 JS를 이루고 있는 거의 모든 것이 객체이다. 

객체지향이라는건 어떤 패러다임이냐면, 객체라고 하는 독립적인 무언가를 만들면, 그 객체들이 따로따로 존재한다고 해도, 독립적으로 존재하는 것이 아니라 서로서로 연관을 갖는다. 즉, 서로서로 데이터를 주고 받을수 있어야 한다는 얘기다. <br>그 중에 가장 기본적인 특징이 "`상속`"이다.

> __상속__
>
> 프로퍼티를 찾을때 자신에게 없으면 부모에게 프로퍼티를 찾으러 가는 구조

원래 JS에는 클래스가 없었는데 ES6 부터 클래스가 도입되었다. 그렇다고 해서 JS가 더이상 프로토타입 기반의 언어가 아니라는 얘기가 아니라, 클래스로 객체를 만들어도 JS 내부적으로는 프로토타입 기반의 언어라는 것을 잊으면 안된다. 

 

## 객체지향 프로그래밍

객체지향이라는 것은 여러개의 독립된 객체들을 만든것이다. 그 객체들을 연관을 지어서 프로그래밍을 하려고 하는 패러다임을 말한다. 그럼 객체는 뭘까? 객체를 개발자 또는 프로그램이 주체고, 그 개발자나 프로그램을 사용하는 대상 다 객체다.

근데 그 객체를 어케 표현하냐면 속성으로 표현한다. 그러면 모든 속성을 다 망라 해야하나요?

예를 들어서 사람이라는 객체를 만든다고 햇을때 사람들의 속성들이 굉장히 많겠지. 그 속성들을 다 망라하는게 아니라 우리가 관심이 있는 특징들만 뽑아서 객체를 구성한다. 그것을 추상화라고 한다.  

사람을 추상화하면 어떤식으로 나타낼수 있을까?

예를들어서 사람을 그린다고 하면 여러가지 방법이 있을거야. 완전히 똑같이 그리는거. 

가장 기본적인 방식이 다른거 필요없고 이름만 나한테 줘. 그리고 또 하나 필요한게 있는데 그건 나이. 그리고 또하나는 동작이다. 

이런식으로 3개의 프로퍼티를 표현한거잖아. 이런식으로 우리가 관심있어하는 3개의 프로퍼티로 사람을 표현하는걸 추상화라고 한다.

 객체 지향은 기본적으로 추상화로 객체를 표현하고, 그 객체들이 어떤 관계를 맺어야해? 다른 객체들하고. 데이터를 주고받아야 한다는 거다. 필요할때마다. 

그 주고받는 가장 기본적인게 상속이라는 거다.

그러면 이 사람이라는 객체를 만들었어. 사람이라는 객체의 부모는 우리가 매번 만들때마다 만들어줘야 할까?

부모는 우리가 객체를 만들때마다 조건을 만들어주는건 너무 귀찮잖아. 그래서 기본적으로 객체를 만들면 자동빵으로 상속이 이루어진다. 

예를 들어서 객체리터럴, 지금까지는 우리가 생성자 함수로 객체를 만드는 방법을 배웟는데. 아래 코드는 객체 리터럴로 만든거잖아.

객체 리터럴로 만들면 상속구조가 없을까? 예를 들어서 

```js
const person = {
    name: 'Lee'
};
console.log(person.constructor); // object
```

위 코드는 상속관계가 있을까? 얘도 상속관계가 있는데, 얘의 상속을 볼라면 어케 봐야 하냐면, 저렇게 쓰면 뭘 볼려고 하는거야?

이 위에 뭐가 있다면 얘는 뭘 하는거지? JS는 객체 리터럴로 만든 경우에 오브젝트 생성자 함수로 만든걸로 퉁치자 라고 약속한거다.  그래서 객체 리터럴도 객체니까 __ proto __ 가 있으니까 객체 리터럴의 __ proto __ 를 따라 올라가면 obcect.prototype 이 나오는거다. object 가 나오는게 아니다. 

```js
const Person = {
    name: 'Lee'
};
console.log(Person.constructor);
console.log(Person.__proto__ === Object); // false
console.log(Person.__proto__ === Object.prototype); // true
```

객체가 태어나면 그 객체의 종류에 따라서 자신의 부모를 정한다. 

왜 얘는 프로토타입 객체를 오브젝트 쩜 프로토타입으로 만들까? 

```js
const person = {
    name: 'Lee'
};
console.log(person.__proto__ === object.prototype); //true // person 은 object 의 자식이다.

const arr = [];  <- 얘도 객체다.(배열도 객체다. 배열이면서 객체다)
console.log(arr.__proto__ === Array.prototype); // true // arr 은 Array 의 자식이다. 
// 기본적으로 어레이.프로토타입이 가지고 잇는 모든 메소드를 사용가능한 상태에서 태어나는거다. 
```

기본적으로 객체들은 자기가 태어나면서 상속관계를 기본적으로 가지고 태어난다. 

따라서 얘네들은 얘가 가지고 있는 메소드랑 프로퍼티를 기본적으로 사용할수 있는 단계에서 태어난다. 

태어나면서 상속을 갖고 태어난다. 

## 상속과 프로토타입

프로토타입은 상속을 구현해내는 자스의 매커니즘이다. 

기본적으로 이런 예제가 잇다고 해봅시다. 

지금 생성자 함수의 문제는 바로 얘다. 얘가 어떻게 된다는 얘기냐?

얘가 중복된다는 거다. 자스는 프로토타입을 기반으로 해서 상속을 구현하고 잇다. 

![image-20200506170446333](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200506170446333.png) 

그러면 메소드만 상속되나? 프로퍼티는 안되나? 프로퍼티도 상속된다. 

this 레디우스는 ....

## 프로토타입 객체

우리가 생성자 함수를 만들거나 빌트인 생성자 함수가 만들어질때, 그니까 컨스트럭터. 즉 뉴와 함께 호출할 수 있는 함수들을 생성하면, 함수 객체들이 만들어지는데, 프로토타입도 쌍으로 만들어진다. 둘이 같이 만들어진다. 둘이 같이 만들어진다는건 동시에 만들어지는 것인가? 동시라는게 아니라 처리를 따로따로 되긴 하지만 만들어지고 바로 만드니까 같이 만들어진다고 이해하고 있자.

이 상황이 만들어지고 모든것이 시작된다는 것이다. 

그러면 현재  우리가 예를 들어서 생성자 함수를 만들고 그 생성자가 생성이 될때 그 생성자.프로토타입 이라고 하는 프로토타입 객체가 만들어질텐데,  그 프로토타입객체는 일단 컨스트럭터라는 프로퍼티를 제외하고 비어있는 상태이다. 왜 비어놨을까? 펄슨 생성자 함수를 만들었어. 그 생성자 함수가 평가되어서 함수 객체가 될때 펄슨.프로토타입이라는 프로토타입 객체가 만들어질텐데, 걔는 컨스트럭터밖에 없다고. 왜 비어놧냐고? 뭘 넣을지 알지 js는 모르니까. 일단 비어놓고 우리가 알아서 채워넣어야 한다. 꼭 채워넣어야 해? 꼭 채워넣을 필요는 없다. 

## __ proto__ 접근자 프로퍼티

언더바 프로토 라고 하는걸 접근자 프로퍼티라고 한다. 

얘는 뭘 가리키고 있냐면 모든 객체들은 그 객체가 함수가 되든 배열이 되든 뭐가 되든 무조건 모든 객체는 프로토타입이라고 하는 내부 슬롯을 가지고 있다. 이 내부 슬롯의 값은 언제 결정되나?내부슬롯이 있으니까 그 값도 있을거잖아.  그 값은 어케 결정되고 언제 결정되나? 자신이 태어날때 결정해야 하는데 그 결정을 어케 하냐? 이 값이라는게 화살표를 의미하는데 이 화살표가 어떻게 되냐고. 자신이 태어날때 반드시 자신과 연결되어진 생성자 함수가 반드시 있다.  그 생성자 함수에 프로토타입이라고 하는 프로퍼티가 가리키고있는 객체가 프로토타입의 값이 되는것이다. 

어떤 객체가 태어날라고 하고 있어. 태어나면, 뭘 해야 하냐면 내 부모가 누군지 결정해야 한다. 객체가 결정하는게 아니라 자스엔진이 얘를 태어나게 하면서 결정해줄텐데 그 결정에 규칙이 있는데 그 규칙이 뭐냐면 얘가 어떤 객체가 태어날때 모든 객체는 생성자 함수와 연결이 되어있다. 어케 연결되어있나? 그 생성자 함수를 어케 찾을수 있지? 

예를 들어서 펄슨 생성자 함수를 뉴로 해서 객체를 만들었다. 그럼 걔는 자신의 프로토타입을 어케 결정하냐고?

뉴해서 호출한 그놈의 프로토타입에 연결되어있는 객체가 그 값이다.

그니까 모든 객체는 생성자 함수와 연결되어잇다는 것이다.

리터럴로 생성된 객체는 부모가 없나? 부모가 있다는 것이다. 

객체들은 태어날때 자신의 부모를 안다. 그 부모의 참조를 여기다가 할당한다는 얘기다. 

얘는 누차 말하지만 내부슬롯인데, 내부슬롯은 우리가 참조할수 없는데, __ proto __ 라는걸로 우리가 참조 또는 갱신을 할수가 있다는 얘기다. 

기본적으로 자스는 모든 프로퍼티는 다 참조가 된다. 

모든 프로퍼티는 다 참조가 된다. 이렇게 언더바 프로토라고 이름을 짓지는 않을거잖아. 그리고 참조하기 어렵게 하는 이유가 있다. 심볼이 나오기 이전의 얘기다. 그래서 내부적으로 쓰려고 언더바 프로토 라고 이름을 지었던 것이다. 자스엔진을 만드는 제조사들이 자기들 내부적으로 쓰려고 이렇게 만든거다. 그래서  비표준이지만 이런 이름을 가지고, 옛날에는 프로토타입 객체에 접근할수 없었지만  어떠한 이유에서인지 브라우저 벤더들이 이런 프로퍼티 를 갖기 시작했다. 그래서 계속 비표준이다가 es6 되서 표준이 되었다. 

접근자 프로퍼티는 기본적으로 참조도 가능하고 할당도 가능하다. 접근자 프로퍼티로 접근을 하면 함수가 돈다. 게터가 도는 것이다. 게터가 돌면서 뭘하지? 게터가 돌면서 그 객체에( [[프로토타입]])에 참조 값을 반환한다. 

그 객체에 프로토타입 객체에 참조를 반환한다.그리고 저 언더바 프로토에 어떤 값을 할당하면 무슨 일이 일어날까? 세터가 돈다. 세터가 돌면서 [[프로토타입]]의 참조값을 바꾼다. 

결국 언더바 프로토는 자신의 프로토타입에 접근하거나 자신의 프로토타입을 교체할 수 잇다는 얘기다. 

그러면 언더바 프로토라는 접근자 프로터피는 누가 사용할수 있을까?

이걸 생각하려면 일케 생각하자. 쟤가 하는 일이 뭐지? 프로토타입에 접근하거나 교체하는 거잖아.

그러면 프로토타입을 가지고 있는 애는 누구냐? 모든 객체다.  따라서 언더바 프로토는 누가 가지고 있어야 하는 기능이지? 오브젝트 프로토타입이 가지고 잇어야 하는 거다. 모든 객체가 가지고 있어야 하는 기능이다.  그러면 모든 객체가 저 타입을 일일히 가지고 있어야 하나? 그럴 필요없다. 

오브젝트. 프로토타입에는 어떠한 메소드 또는 접근자 프로퍼티가 존재하냐? 객체로서 가져야 하는 기능은 다 가지고 잇어야한다. 

따라서 언더바 프로토는 존재의 위치가 어디냐? 오브젝트.프로토타입이다.

![image-20200506172025405](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200506172025405.png) 

네임: 리는 펄슨이라는 객체...

언더바 프로토 는 프로터티 키네. 언더바 프로토 밑에 잇는 애들은 참조한 애들이다.네임의 내용이다.

그럼 저 많은것들을 다 사용할수 있다. 

```js
const p = {
console.log(p.hasOwnProperty('name')); //true  <- name 은 프로퍼티 키다. "p 라는 객체에 name 이라는 프로퍼티가 있니? 라고 물어보는거다. name 이라는 프로퍼티가 상속관계로 가지고 잇는게 아니라 직접 가지고 있니? 라고 물어보는 것이다."
console.log(object.getOwnPropertyDescripts(p));
}
```

프로퍼티가 존재할수 있는 가능성이 있는 곳이 3개다. 

프로토타입 메소드는 인스턴스로 호출해야 한다.





## 함수 객체의 프로토타입 프로퍼티

언더바 프로토, [[프로토타입]], 프로토타입 <- 이 3개가 헷갈리게 한다.  앞에 두개가 세트이고, 

뒤에 프로토타입 앞에는 함수가 와야 하고, 언더바 프로토 앞에는 모든 객체가 와야 한다. 

모든 객체긴 한데 괄호열고(오브젝트. 프로토타입) 이걸 상속받는 객체다.

맨 뒤의 프로토타입 앞에 잇는 함수가 가리키고 있는 값이 뭐지? 이 함수가 생성할 인스턴스.. 프로토타입을 가진다.



예습: 21번까지  20번은 가볍게만 읽어보고 오기. 소감 물어볼거야. 뭘 얘기하는지 주제만 찾아오면 되. 









