# 함수와 일급객체

함수 = 객체.<br>객체 = 값.<br>함수 = 값

위 식처럼 누차 말하지만 함수는 객체라서, 함수를 객체와 동일하게 사용할수 있다. <br>또한, 객체는 값이므로 함수는 값과 동일하게 취급할 수 있다.<br>그 객체에는 '일급 객체' 라는 정의가 존재한다.<br>해당 정의가 성립되려면 아래의 전제 조건을 만족해야 한다.

1. __무명의 리터럴__로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.<br>--> 무명의 리터럴이 생성이 가능하다는 문법을 제공한다는 건, 무명 리터럴을 <br>__변수에 할당하라__는 의미와 동일하다. 즉, 무명 리터럴을 변수에 할당하는 것을 "함수 표현식"이라고 할수 있으니까, __무명의 리터럴(=함수표현식)의 함수 객체는 런타임에 생성된다__는 것과 동일한 의미이다. 
2. 함수를 변수나, 하나의 값만 갖는게 아닌 복합적으로 여러개의 값을 가질 수 있는 자료구조(객체, 배열 등)에 저장할 수 있다. 
3. 함수의 매개 변수에게 전달할 수 있다.
4. 함수의 결과값으로 반환 할 수 있다. 

하지만 객체와 함수는 엄밀히 따지만 같지 않다. <br>함수는 객체의 특징을 모조리 싹 다 갖고 있지만, 객체는 함수의 특징을 모두 다 갖고 있지는 않기 때문이다. 객체는 가지고 있지 않지만 함수만 갖고 있는 고유의 특징들 중 하나는, 호출을 할 수 있다는 점과 `함수 고유의 프로퍼티`를 갖고 있다는 점때문에 함수와 객체는 엄격히 말하면 같지 않다.

> __함수 고유의 프로퍼티__
>
> - arguments 프로퍼티
> - caller 프로퍼티
> - length 프로퍼티
> - name 프로퍼티
> - prototype 프로퍼티
> - __ proto __ 접근자 프로퍼티



## arguments 프로퍼티

- arguments 프로퍼티 값은 arguments 객체이다.

  ```js
  function () {
      arguments : arguments 객체
  }
  ```

  - arguments 객체는 유사 배열 객체이다.
  - arguments 객체는 함수 외부에서는 참조 할수 없다.

- 함수가 호출되면 `함수 몸체 내에서 암묵적으로 매개변수가 선언 -> undefined로 초기화 -> 인수 할당`의 과정을 거친다.

  ```js
  function muitiply(x, y) {
      // <- 암묵적으로 매개변수가 선언
      // <- undefined 로 매개변수 초기화 -> 인수 (1, 2)이 매개변수 (x, y)에 할당
      console.log(arguments);
      return x * y;
  }
  
  console.log(multiply(1, 2, 3)); // 2
  -------------------------------------------------
      ▶ Arguments(3)
  		0 : 1  ─┐
  		1 : 2	│ arguments 객체
  		2 : 3  ─┘
  
  0, 1, 2 = 인수의 순서 (arguments 객체에서 프로퍼티 키는 인수의 순서를 나타낸다.)
  1, 2, 3 = 인수 = 프로퍼티 값  (arguments 객체는 인수를 프로퍼티 값으로 소유한다.)
  ```



- __arguments 객체의 length 프로퍼티는 인수의 개수를 나타낸다.__<br>arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로 fot문으로 순회할 수 있다. 



## caller 프로퍼티

비 표준 프로퍼티이다.

함수 객체의 caller 프로퍼티는 함수 자신을 호출한 함수를 가리킨다는 것 말고는 별로 알 필요없다. 



## length 프로퍼티

__매개변수의 개수를 나타낸다.__

length 프로퍼티와 arguments 객체의 length 프로퍼티는 다른 것이다. <br>위에서도 언급했듯이, arguments 객체의 length 프로퍼티는 인수의 개수를 나타내고,<br>함수 객체의 length 프로퍼티는 매개 변수의 개수를 나타낸다.

```js
ex 1)

function foo(){
    console.log(foo.length);
}
// 0

ex 2)

function bar(x) {
    console.log(bar.length);
}
// 1

ex 3)

function baz(x, y) {
    console.log(baz.length);
}
// 2
```



## name 프로퍼티

함수 객체의 name 프로퍼티는 함수 이름을 나타낸다.

기명 함수 표현식에서의 name 프로퍼티와, 무명 함수 표현식에서의 name 프로퍼티가 함수 이름을 가리킨다      는 것은 동일하지만, 무명 함수 표현식일때 ES5 문법에서와 ES6 문법에서는 가리키는것이 다르다.

무명 함수 표현식일때 ES5 문법에서는 name 프로퍼티가 함수 이름을 가리키지만,<br>ES6 문법에서는 name 프로퍼티가 함수 객체를 가리키는 변수 이름을 가리킨다.

```js
< 기명 함수 표현식일때의 name 프로퍼티>

var namedFunc = function foo() {};
console.log(namedFunc.name); 
// foo

---------------------------------------

<익명 함수 표현식일때의 name 프로퍼티> 

var barFunc = function () {};

console.log(barFunc.name);
// barFunc 
```



## prototype 프로퍼티

- 함수 객체만이 소유하고 있는 프로퍼티이다. 일반 객체에는 prototype 프로퍼티가 없다.

  ```js
  
  console.log((function(){}). hasOwnProperty     ('prototype')); // true
  ==> 	  " 함수 객체가     갖고있는 property에  'prototype'이라는 프로퍼티가 있다" //true
  -------------------------------------------------------------------------------------
  
  console.log(((){}).    hasOwnProperty     ('prototype')); // false
  ==>      " 일반 객체가  갖고있는 property에   'prototype'이라는 프로퍼티가 있다" //false
  
  ```

- 생성자 함수로 사용될때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.

  ```js
  var Person = function () {
      name: 'Lee';
      sayHi: function () {};
  }
  ```

  ![캡쳐115](https://user-images.githubusercontent.com/62126380/82549208-87dd0f80-9b97-11ea-9666-6583b47a51af.PNG) 



## __ proto __ 접근자 프로퍼티

모든 객체에는 [[prototype]] 이라는 내부슬롯을 갖고있는데, 이 내부슬롯에는 원래 직접 접근할 수 없다. <br>하지만, __ proto__ 라는 프로퍼티를 사용하면 `[[prototype]]` 이라는 내부슬롯에 간접적으로는 접근할수 있다.

> __[[prototype]]__
>
> 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다.





#  프로토타입

자스는 멀티패러다임 언어다. 

자스는 클래스가 없다. 아~ 자스는 객체지향 언어가 아니라는 오해를 받았지만 

자스는 객체지향 언어이긴 하다. 근데 클래스 기반이 아니라 프로토타입 기반이다.

프로토타입 기반이 클래스기반보다 유연하다.

데이터를 주고받을수 있어야 한다. 그 중에 중요한게 상속이다. 프로퍼티를 찾을때... 부모를 찾으려고 하는게 상속구조다. 

자스는 훌륭한 객체지향 언어다. 

## 객체지향 프로그래밍

객체지향이라는 것은 여러개의 독립된 객체들을 만든것이다. 그 객체들을 연관을 지어서 프로그래밍을 하려는 패러다임을 말한다. 그럼 객체는 뭘까? 개발자 또는 프로그램이 주체고 ... 대상들이 다 객체다.

근데 그 객체를 어케 표현하냐면 속성으로 표현한다. 모든 속성ㄷ을 다 막라 해야하나요?

... 그것을 추상화라고 한다. 

```js
const person = {
    name: 'Lee'
};
console.log(person.constructor); // object
```

위 코드는 뭘 보려고 하는거야?

```js
const person = {
    name: 'Lee'
};
console.log(person.__proto__ === object.prototype); //true 

const arr = {};  <- 얘도 객체다.
console.log(arr.__proto__ === Array.prototyoe); // true
```

![image-20200506170446333](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200506170446333.png) 

this 레디우스는 ....

## 프로토타입 객체

모든 함수가 만들어질때에라고 하면 안된다. 컨스트럭터와 함께 호출할수 있는 함수들을 생성하면 함수 객체들이 만들어지는데, 프로토타입이 쌍으로 만들어진다. 동시에 만들어지는 것인가? 동시라는게 아니라 처리를 따로따로 되긴 하지만 만들고 바로 만드니까 같이 만들어진다고 이해하고 있자. 

우리가 예를 들어서 생성자 함수를 만들고 ... 프로토타입이라고 하는 프로토타입 객체가 만들어질텐데.. 비어있는 상태이다. 왜 이렇게 비어놧을까? 생성자 함수를 만들었어, 이게 평가되어져서... 프로토타입 객체가 만들어질텐데 .... 뭘 넣을지 모른다. 자스엔진은. 일단 비워놓는다. 그럼 알아서 채워넣어야 한다. 

꼭 채워넣어야 할 필요는 없다.

## __proto__ 접근자 프로퍼티

언더바 프로토 라고 하는걸 접근자 프로퍼티라고 한다. 

모든 객체들은 그 객체가 함수가 되든 배열이 되든 모든 객체는 프로토타입이라고 하는 내부 슬롯을 가지고 있다. 이 내부 슬롯의 값은 언제 결정되나? 그 값은 어케 결정되고 언제 결정되나? 자신이 태어날때 결정해야 하는데 그 결정을 어케 하냐? 자신과 연결되어진 생성자 함수가 반드시 있다 그 생성자 함수... 객체가 프로토타입의 값이 되는것이다. 

어떤 객체가 태어날라고 하고 있어. 태어나면. 뭘 해야 하냐면 내 부모가 누군지 결정해야 한다. 객체가 결정하는게 아니라 자스엔진이 얘를 태어나게 해주면서 결정해주는데 그 결정에 규칙이 있는데 그 규칙이 뭐냐면 모든 객체는 생성자 함수와 연결이 되어있다. 어케 연결되어있나? 그 생성자 함수를 어케 찾을수 있지? 예를 들어서 

펄슨 생성자 함수를 뉴로 해서 객체를 만들었다. 그럼 걔는 자신의 프로토타입을 어케 만들지?

... 이거의 값이다. 모든 객체들은 생성자 함수와 연결 되어잇다. 

객체들은 태어날때 자기의 부모를 안다. 그 부모의 참조를 프로토타입에 연결한다. 

내부슬롯의 값을 우리가 참조할수 없는데 언더바 프로토로 참조 또는 갱신을 할수가 있다. 

모든 프로퍼티는 다 참조가 된다. 이렇게 언더바 프로토라고 이름을 짓지는 않을거잖아. 그리고 참조하기 어렵게 하는 이유가 있다. 심볼이 나오기 이전의 얘기다. 내부적으로 쓰려고 언더바 프로토 라고 이름을 지었다. 이런 이름을 비표준이지만 이런 이름을 가지고 어떠한 이유에서인지 브라우저 밴더들이 이런 프로퍼티 를 갖기 시작했다. 계속 비표준이다가 es6 되서 표준이 되었다. 

기본적으로 참조도 가능하고 할당도 가능하다. 접근을 하면 함수가 돈다. 게터가 돈다. 게터가 돌면서 뭘하지? 그 객체에 [[프로토타입]]에 참조 값을 반환한다. 

그 객체에 프로토타입에 참조를 반환한다.그리고 저 언더바 프로토에 어떤 값을 할당하면 무슨 일이 일어날까? 세터가 돈다. 세터가 돌면서 [[프로토타입]]의 참조값을 바꾼다. 

.... 자신의... 를 교체할수 있다. 언더바 프로토라는 접근자 프로터피는 누가 사용할수 있을까?

이걸 생각하려면 일케 생각하자. 쟤가 하는 일이 뭐지? 프로토타입에 접근하거나 교체하는 거잖아.

그러면 프로토타입을 가지고 있는 애는 누구냐? 모든 객체다. 따라서 언더바 프로토는 누가 가지고 있어야 하는 기능이지? 모든 객체가 가지고 있어야 하는 기능이다.  그러면 모든 객체가 일일히 가지고 있어야 하나? 그럴 필요없다. 

언더바 프로토는 존재의 위치가 어디냐? 오브젝트 프로토타입이다.

![image-20200506172025405](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200506172025405.png) 

네임: 리는 펄슨이라는 객체...

언더바 프로토 는 프로터티 키네. 언더바 프로토 밑에 잇는 애들은 참조한 애들이다.네임의 내용이다.

그럼 저 많은것들을 다 사용할수 있다. 

```js
const p = {
console.log(p.hasOwnProperty('name')); //true
console.log(object.getOwnPropertyDescripts(p));
}
```

가능성이 있는 곳이 3개다. 



## 함수 객체의 프로토타입 프로퍼티

언더바 프로토, [[프로토타입]], 프로토타입 <- 이 3개가 헷갈리게 한다.  앞에 두개가 세트이고, 

뒤에 프로토타입 앞에는 함수가 와야 하고, 언더바 프로토 앞에는 모든 객체가 와야 한다. 

모든 객체긴 한데 괄호열고(오브젝트. 프로토타입) 이걸 상속받는 객체다.

맨 뒤의 프로토타입 앞에 잇는 함수가 가리키고 있는 값이 뭐지? 이 함수가 생성할 인스턴스.. 프로토타입을 가진다.



예습: 21번까지  20번은 가볍게만 읽어보고 오기. 소감 물어볼거야. 뭘 얘기하는지 주제만 찾아오면 되. 









