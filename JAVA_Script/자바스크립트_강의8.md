# 프로퍼티 어트리뷰트

인터프리터 : 말그대로 JS를 워싱코드로 바꿔준다. 자스엔진이 이해할수 있는 언어로 바꾸는 애다.

인터프리터만 있으면 안된다. 

문자열에서 얘를 해석해야 한다. 토큰으로 죄다 쪼개서 그것을 하나의 자료구조로 만들어야 한다. 이 자료구조를 인터프리터한테 준다. 

에크마스크립터 사양서는 누구를 위한거냐? 

자스엔진은 누구 소속일까? 파스오브 소속이다. 해석하는거에만 관심이 있다. 

우리가 만드는 자스코드들이 해석되어져서 자스어로 갈거다.  



엔진 만드는 사람들한테 만들어준거라서 우리는 뭔말인지 모르고, 되게 추상적으로 설명한 부분도 있어서 어렵다. 자스엔진이라는 애가 얘를 해석할거란말이지, 해석한것도 별도의 프로그램이다. 별도의 프로그램이 얘넬 읽어들여서 작업하는거다. 

지금부터 설명하는 것들을 자스라고 생각하면 좀 곤란하다. 

의사코드? 코드가 아닌데 코드 비스무리하게 대충 쓰는 짝퉁코드.

언어를 정확히 모르기때문에 의사코드를 써라. 정 모르겠으면 한글로 써라. 이런식으로 연습해야 머리가 로직화해준다. 메소드의 이름을 지어줘. 이름을 불러줘야 할거 아냐. 가상적으로 메소드 이름을 만들어준다. 그래서 이 메소드를 호출해라 이런식으로 한다. 

그래서 내부 메소드라고 부른다. 내부에서 쓰는 프로퍼티를 내부 슬롯이라고 한다. 

내부 슬롯과 내부 프로퍼티는 자스를 만드는 거다. 

기본적으로 내부 슬롯과 내부 프로퍼티는 비공개다. 안 알려준다. 

근데 우리가 코딩을 할때 여기서 일부 필요한것들이 잇다. 그것들은 자스코드로 접근할 방법을 간접적으로 제공한다. 



에크마스크립트에서 기술 안된것들은..... 

에크마 스크립트 기술서 안에서 대괄호 두개 해놓은것들이 내부 슬롯과 내부 메소드다. 

우리가 왜 이 용어들을 알아야 하느냐, 클로저라는게 뭐냐면 함수는 태어날때 객체가 만들어질때 상위 스코프를 기억한다. 기억한다는 건 정확히 함수는 객체이므로 프로퍼티가 있다. 자기가 태어날때 에크마 스크립트 사양서를 보면 [[en]] 여기에 저장하여라. 라고 쓰여있다. 저 대괄호 안에 있는건 내부 슬롯이다. 



모든 함수는 내부 슬롯을 가지고 있다. 내부 슬롯은 감춰진 프로퍼티다. 

일부 내부 슬롯과 내부 메소드에 관해서는 우리가 접근하는 일이 있을수도 잇다. 걔네는 자스로 우리에게 알려주는 프로퍼티 또는 메소드로 존재하는 경우가 있다. 

예를 들어서 객체 내부에 이런 객체가 또 있는거다. 

= 이거 하기 직전이다. 

무명리터럴: 이름이 없다라는 것은 얘가 어디에 할당된다는 뜻이다. 이름이 붙지않는 리터럴이 존재한다는 문법은.... 반드시 변수에 할당된다는 전제이다. 아니면 무명 리터럴이 있을수가 없다. 

무명리터럴이 가능하다는 얘기는 런타임에 생성된다는 얘기다. 프로퍼티는 객체가 생성될때 만들어짐.

이 변수에 할당되기 직전에 만들어진다. 얘가 만들어져야 객체가 완성된다. 

프로퍼티: 프로퍼티는 어트리뷰트를 가지고 있다. 프로퍼티는 가지고 있는 자산이라고 해석해야 한다.

프로퍼티들은 속성이 있다. 즉 어트리뷰트가 있다는 얘기다. 흡사 객체와 같은 얘기다. 

데이터 프로퍼티 / 접근자 프로퍼티 

우리가 지금까지 경험한 프로퍼티는 데이터 프로퍼티 라고 한다.

데이터 프로퍼티는 된쪽에 값이 온다. 

데이터 프로퍼티는 4가지의 어트리뷰트를 가지고 잇다.

1. [[벨류]] (프로퍼티 값)을 가지고 있다.

2. [[라이터블]]: 쓸수 있는가. -> 이 벨류 프로퍼티 값을 쓸수 있느냐 없느냐(갱신할수 있느냐 없느냐), 쓸수 있느냐 라고 물어보는건 리드온리하냐고 물어보는거다. 얘네는 트루 풜스를 갖고 있다.

3. [[이유머러블]] : 열거할수 있느냐. 이 얘기는 객체에 프로퍼티들이 존재하지? 이 프로퍼티들이 포문에 의해서 나열이 되느냐?  렝스가 없어서 포문에서 못돈다. 그럼 이거 되려면 어케 하지? 포 인문 이라는게 있고 오브젝트라는 객체에 키스(keys) 라는게 있다. 

   포인문 : 객체에 프로퍼티를 열거하는 전용 문법 (이거 쓰지마라)

   객체의 키 : 여기서 키는 프로퍼티 키를 뽑아서 배열로 리턴해준다. 그럼 그 배열로 순회하면서... 땡겨올수가 있다. 

4. [[컴피규어러블]] : 설정할수 있다 라는 얘기다. 얘가 만약에 풜스면 이 객체 내에서 프로퍼티에 값을 갱신할수 없고 쓸수도 없다. (읽기전용이 되고 추가도 안되고 지울수도 없다)



내부 슬롯에 접근할수 없지만 간접적인 방법으로 제공한다. 

....  유효한 메소드를 제공한다. 

객체마다 각자 프로퍼티가 다 다르다. 

모든 프로퍼티는 읽기쓰기가 가능하고 열거 가능하고 재정의가 가능하다. 

프로퍼티라는게 단순하지는 않단 얘기다. 자스엔진 내부에서는 프로퍼티가 어떻게 관리되고 잇다는거지?

프로퍼티 자체가 객체다. 내부 슬롯이 있잖아. 내부 슬롯을 프로퍼티 키라고 생각하면 된다. .... 하나의 객체로 다뤄진다. 그 ... 집합체를 객체라고 한다. 



우리가 자스엔진을 만든다고 생각해봐라. 어떤 자료구조를 만들어야 하잖아. 지금까지 살펴본건 데이터 프로퍼티다. 

프로퍼티 처럼 생긴 함수.

예를 들어서 

![image-20200504142710215](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504142710215.png) 

데이터 프로퍼티 : 벨류가 있는 놈이다. 근데 접근자 프로퍼티는 벨류가 없고, 벨류 대신 겟 이란 애랑 셋 이라는 애가 있다. 겟 셋 다 프로퍼티 어트리뷰트인데 둘다 함수를 가지고 있다. 



겟셋 없다고 생각하면 fullName 이 똑같다. 겟셋 두개가 게터세터이다. 

프로퍼티는 두가지 용도로 쓴다. 참조할때 쓴다. 프로퍼티로 값을 참조할수 잇나? 어케 참조하나? 펄슨.펄스트 네임 . 이건 참조다. 가지고 오는거다. 즉. 겟하는 것이다.

펄슨.펄트스 네임 = 어쩌고 이게 셋이다. 

접근자 프로퍼티는 .... 만들어준다. 

접근자 프로퍼티는 4개의 어트리뷰트를 갖고 잇다.

1. 겟 : 게터는 결국 리턴이 반드시 있어야 한다
2. 셋 : 리턴이 반드시 없어햐 한다.
3. 이뉴머러블
4. 컨피규러벌

오운(Own): 상속은 제외하고...... 것만.

 .... 프로퍼티 디스크립터 객체도 있다.

디파인 프로퍼티도, 데이터 프로퍼티를 만드는것이 가능하다는 것을 알앗고..... 만들수 잇는걸 알앗다.



## 객체 변경 방지

3가지 메소드가 있다. 

오브젝트. 프리즈

이런게 있다. 만 알고 넘어갑시다.

지금은 몰라도 됨

객체를 동결한다. 왜 객체를 얼릴까? 메소드를 통해서 객체를 얼리면 모든 프로퍼티가 리드온니가 된다.

왜 얼릴까? 원시값처럼 주소가 바뀌지 않는 상황에서... 객체를 원시값처럼 쓰고자 할때에는 오브젝트.프리즈를 통해서... 

객체를 바꾸려면 어케 해야 하나? 딥카피를 해야 한다. 객체를 새롭게 처음부터 만들어야 한다.

---



# 생성자 함수에 의한 객체 생성

다른 언어들 얘기를 좀 하면, 객체 지향언어들 얘기를 하면 그런 언어들은 기본적으로 객체를 만들때 리터럴로 만드는 방법이 없다 클래스라는걸 선정의하고 객체 만들기 전에 그 객체에 클래스라는 걸 미리 정의한다. 그 다음에 클래스를 뉴 연산자와 함께 호출한다. 그럼 객체가 만들어진다. 그 객체를 인스턴스라고 한다. 그러면 왜 그 언어들은 그런식으로 할까?

왜 자스는 객체 리터럴이란 방법을 제공할까? 이유가 있다. 그럼 여태까지 우리가 클래스라는 개념 모른다치고 객체 리터럴 쓰면서 느끼는게 있나? 객체 리터럴이 어떤 느낌이냐? 엄청 편한거다. 객체를 런타임에 만들수 있다. 클래스 함수를 미리 만들어놓고 ... 이게 클래스인데 얘네는 런타임에 만들수 없다. 



객체 리터럴은 무슨 문제점이 있지? 객체가 여러개 만들어질때 객체 리터럴이 조금 거시기 해. 왜냐면 첨부터 다 써야 하니까. 그리고 객체는 메소드 갖고 잇는데, 객체 여러개 잇을때 메소드는 거의 안바뀌지만 상태 데이터만 바뀐다. 그러면 우리가 100개의 객체 리터럴 만드는 것은 불합리하다. 

객체를 만들어내는 함수를 만드는 것이다. 그래서 그 함수를 호출하면 객체가 툭툭툭 만들어진다. 

그러면 심플하게 만들어지는것이다. 

따라서 객체는 만드는 방법이 여러개 있다.

객체 리터럴로만 만드는게 아니다.

객체 리터럴로 만드는게 있고 오브젝트 생성자 함수 로 만드는것도 있다. 



## 오브젝트 생성자 함수

아까 오브젝트. 어쩌고 저쩌고.

근데 얘는 정체가 뭐다? 함수다. 함수인데, 생성자 라는 말이 붙으면 얘의 존재 목적이 뭐냐면 객체를 만들어내는 목적을 가지고 잇는 함수다. 생성자 함수는 어케 호출하냐면 뉴 라는 연산자를 앞에 꼭 붙여줘야 한다. 문법이다. 붙여주고 안붙여주고 큰 차이가 있다. 자스는 뉴 안붙여줘도 에러가 안난다. 

![image-20200504152548503](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504152548503.png) 

오브젝트는 전역객체에 있다 전역객체는 브라우저가 켜지자마자 빌트인 객체가 주루룩 있다. 

우리가 코딩하는 시점에는 반드시 오브젝트 가 있다. 생성자 함수가 오브젝트인거 보니까 얘는 객체를 만드는 애다 . 근데 인수가 없으면 빈객체를 만든다. 빈 객체 만들고 프로퍼티 추가해주면 객체 만들수 있다. 

## 생성자 함수

![image-20200504152722348](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504152722348.png) 

플러스 빈문자열 하는게 좋다.

단항 연산자를...

느낌표를 두개 붙인다. 

스트링 앞에 뉴를 하면 문자열 객체를 만든다. 문자열도 객체가 있다는 말이다.

숫자 객체, 불리언 객체라는게 있다는 말이다. 

함수도 펑션 생성자 함수를 만들수도 있다. 이건 클로저를 안만들고 내부동작이 틀려서 쓰지 마라. 



## 생성자 함수 

### 객체 리터럴에 의한 객체 생성 방식의 문제점

![image-20200504152937725](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504152937725.png) 

원을 나타내는것이다. 

우리가 관리하고 싶은건 반지름이다. 반지름을 관리하겟다. 메소드가 하나있다. 비스무리한 객체를 또 만드려고 한다. 반지름만 다르다 

이 메소드는 뭐에 대한 행동이죠? 대부분 프로퍼티에 대한 행동이다. 얘를 조작하는 애다. 위의 객체는 고정값을 갖고 있다. 그래서 리터럴을 쓸때 고정값을 ..... 똑같은걸 써줘야 한다는 얘기다. 

프로퍼티 구좌가 똑같다면... 이게 생성자 함수라고 한다. 



멍멍개를 본적있나? 우리가 생각하는 개는 다 틀리다. 그럼 개가 뭔데? 다 틀리다. 그러면 개의이상이 있는거다. 개의 원형이 잇는거다. 예를 들어서 개는 다 다른가? 특징들이 있을거 아냐. 짓는 소리가 멍멍해야해. 그리고 색깔은 어떤 색이다. 그런것들을 미리 정할수 있을까 없을까 

예를 들어서 

털색깔 , 짓는 행동, 다리의 개수, 꼬랑지가 있다없다 트루 풜스. 그래서 걔를 클래스로 만드는거다. 

틀을 만드는것이다./ 그럼 개의 실체는 집에 있는 개일수도 있고.. 그 틀로 만들어진 실체다. 

클래스를 통해서 만들어진 애들을 인스턴스라고 한다. 

실체를 인스턴스라고 한다. 여기서 클래스라고 하는것은 클래스 기반이라고 하고 자스는 생성자 함수라고 한다. 

자 그러면 우리 사람의 이데아를 만들어보자.

생성자 함수로 만든것이다 라는걸 알리기 위해 함수 이름의 첫머리를 대문자로 한다. 

여기서 this 는 문맥에 따라서 가리키는 값이 달라진다. 그 문맥이 6가지 정도 된다. 

오늘은 3가지를 배울거다. 

생성자 함수 내부안에서의 디스는 이 생성자 함수가 만들어낼 인스턴스를 가리킨다. 

생성자 함수 내부안에서의 디스는 얘가 인스턴스를 만들거 아냐, 그 인스턴스를 가리킨다. 

미래에 만들어낼 인스턴스를 가리킨다. 디스 뒤에 프로퍼티를 쓴다. 인간세상은 다 이씨면 디스.네임 뒤에 'Lee' 라고 써야 하는 것이다. 

뉴를 붙히면 언디파인드, 띄면.....

뉴를 붙히면 생성자 함수로서 호출했다는 뜻이다. 

그러면 펄슨을 생성자 함수가 아닌 일반함수로서도 호출할수 있다는 얘기다. 



중의적인 의미를 가지고 잇으면 반드시 실수를 한다. 

실수를 하니까 방어코드가 있어야 한다. 얘가 뉴와 함께 호출되엇는지 알아차려야 한다. 

메소드는 프로퍼리를 조작하거나 동작하는 애다. 어케 접근할래?



객체 리터럴를 내부에서 쓸때 호출할때 쩜을 썻잖아. 쩜 앞에 잇는거다. 

함수몸체는 호출될때 실행된다. 호출될때마다 실행된다. 호출될때마다 만들어진다. 그니까 모든 인스턴스들은 내용이 같은 쎄이하이들을 중복소유한다. 방법은 이 함수를 펄슨의 부모에게 준다. 상속으로 한다. 부모가 저거 하나 가지고 잇으면 자식들이 다 갖는다. 



## 생성자 함수에 의한 객체 생성 방식의 장점

여러개 만들어야 한다. 몇개? 하여간 여러개. 그렇단 얘기죠. 

![image-20200504161723182](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504161723182.png) 

여기서 디스는 누굴 가리킬까요, 외우세요. 생성자 함수 내부에서 디스는 누구다? 생성자 함수가 생성할 인스턴스다. 객체 리터럴 내부에 메소드 내부에서 사용한 디스는 그 메소드를 호출할 객체다. 그 메소드가 소속한 객체가 아니고

일반함수에서 디스를 쓸수 있을까? 일반함수라는 것은 기존에 우리가 호출한거. 쓸수 있을까? 왜 있지?

원래 쓰면 안된다. 디스는 왜 쓰지? 디스는 원래 객체지향에서 의미가 있는거다.

일반함수에서 디스 왜써? 의미 없는거다. 근데 자스는 디스가 있어야 함.

일반함수에서 디스는 무조건 전역객체다. 

![image-20200504161938329](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504161938329.png) 

디스가 가리키는 값이 중요하다

우리가 함수라고 불리는 것이 일반 함수로서 호출될때가 있고 메소드로서 호출될때가 있고 생성자 함수로서 호출될때 장면이 잇다. 

![image-20200504162106833](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504162106833.png) 

위에 보면 일반함수같다. 여기서 디스는 전역객체다.

![image-20200504162204425](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504162204425.png) 

생성자 함수로서 호출했다는 것은 뉴와 함께 호출했다는 것이다.

![image-20200504162553404](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504162553404.png)

그럼 우리가 명시적으로 리턴하면 어케 될까? 그래서 어떤 객체를 리턴했다고 하면 우리가 명시적으로 리턴한 객체가 된다. 그러니까 주의해야 한다. 

원시값을 리턴하면 무시당한다.



## 내부 메소드

new : 연산자다.

얘 뒤에는, 우항에는 함수가 온다. 생성자 함수라는 문법이 있나요? 생성자 함수라는 문법을 지키면 생긴다는 식의 문법은 없다. ... 로도 될수 있다.

따라서 일반함수는 일반함수라는건 함수만드는거  몇가지? 

펑션 푸()

콘스트 푸 = 펑션() {}

위 두개는 생성자함수도, .. 도 호출할수 있다.

콘스트 푸 = ( )=> {})

위 하나는 생성자 함수로 호출 못한다.



우리가 일반적으로 메소드라는거. 객체 지향언어에서 다 메소드라고 한다.

우리가 메소드라고 통상 부르는거랑 에크마 에서 부르는 메소드는 다른거다. 

에크마에서 메소드라고 부르는 애는 단하나. 메소드 축햑형. (푸 () {}) 얘네만 문법상 메소드라고 한다.

에크마에서 메소드라고 지칭하는건 생성자 함수로 호출할수 없다. 메소드를 왜 생성자 함수로 호출하냐고~ 당연한거다. 

함수들의 종류가 있다.

생성자 함수로 호출할수 있고 없는 함수가 있다.

생성자 함수로서 호출 가능한거 함수 선언문, 함수 표현식

근데 생성자 함수로서 호출 안되는건 다 이엑스 식스 문법이다. 메소드랑 화살표함수. 

함수라는게 기본적으로 어떤 특성을 갖고 있어야 하나? 함수도 객체라매. 객체랑 함수의 차이는?

객체가 함수보다 큰 개념이다.

그러면 함수는 객체의 특성을 모두 갖고 잇을까?  싹 다 갖고 있다. 

그런데 함수만의 특징을 갖고잇다. 그 특징은 쉽게 말해서 호출할수 있다.

객체는 호출할수 없다

함수를 호출하면 함수가 내부적으로 [[call]] [[construct]] 얘네 내부 메소드다

함수 객체를 가리키는 식별자 ( )

위 두개를 호출하는거다. 내부동작이. 

어쩔때 콜, 어쩔대 콘스트럭 호출하느냐.

함수가 함수 선언문이랑 함수 표현식이 잇는데 [[콜]] [[콘스트럭트]] 둘다 가능하다. 둘다 가지고 있다. 

근데 콘스트럭트 화살표함수는 콜을 갖고잇다. 콜을 안갖고잇으면 함수가 아니다. 

근데 콘스트럭트는 있는애 가 잇고 없는 애가 있다. 없는 애를 논 컨스트럭트 , 있는애를 콘스트럭트라고 한다. 

![image-20200504163840394](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504163840394.png) 

위의 메소드는 콘스트럭트다. 뉴와 함께 호출할수 있다. 

그러면 콜 메소드도 갖고 잇고 내부에서 콘스트럭트고 갖고 있어서 함구 객체가 크다는 얘기다.

이렇게 저렇게 호출할수도 있다. 쓸데없는 기능을 갖고잇다는 얘기다. 

그래서 비효율적이다. 함수라는게 생성자, 일반 함수로도 호출할수 잇다. 이게 생성자 함수인지 일반 함수인지 파스칼케이스로 구분해서 알려줘라. 

함수를 만들때 파스칼케이스로 만들어줬는데 왜 생성자 함수로 호출 안했어? 라고 하는게 아니라 그 버튼을 만들지 말았어야지.

![image-20200504164417321](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504164417321.png) 

뉴를 안붙이는 경우 : 일반함수로 호출 한거. 그냥 일반함수 하듯이 선언문 먼저 찾는다. 



## 뉴 타겟

예를 들어서 

![image-20200504165909203](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504165909203.png) 



뉴.타겟 : 함수 객체를 가리키고 있다. 그래서 빈객체가 아니라는거다. 뉴와 함께 호출하지 않으면 언디파인드가 된다. 



![image-20200504170157078](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504170157078.png) 









방어코드가 있을까 없을까. 있다. 오브젝트도  뉴 오브젝트에서 빈객체 만들수 있었죠. 

펑션 생성자 함수도 ... 

문제는 얘네들이야.  빌트인 생성자 함수(Object, String, Number, Boolean, Function, Array, Date, RegExp, Promise 등) 얘네들. 

행동들이 일관되자 않다. 

![image-20200504170522844](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504170522844.png) 

위처럼 띄지 말고 붙여줘야 한다. 



디스를 안보는 메소드를 정적 메소드라고 한다.





