# 데이터 타입 

![캡쳐66](https://user-images.githubusercontent.com/62126380/80305488-ff698a00-87f7-11ea-8b20-25d1bcc97a06.PNG) 



## 데이터 타입의 필요성

- 모든 값은 데이터 타입을 갖고 있는데, 그 값이 메모리에 저장될때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 읽어들일때 읽어들일 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어들인 값의 2진수를 어떻게 해석할지(숫자타입인지, 문자열 타입인지 등) 결정하기 위해



## 동적 타이핑( 타입을 만든다 )

## 동적 타입 언어와 정적 타입 언어

예를 들어서, int (정수라는 뜻. 음수도 정수에 포함 0 도 포함 양수도 포함. 음수를 포함한 정수라른 뜻)

int 를 선언하면 int x : x 변수는 int  타입이란 뜻이다. 

근데 자스는 var x ;라고 선언하잖아. 그럼 var 라는 키워드는 의미는 변수를 선언해라, 그리고 타입의 의미 2개 있다. 의미는 담지 않고 변수를 선언하라는 키워드일뿐이다. int 언어 var 언어는 차이가 있다. var 동적 타입 언어 int 정적 타입언어

정적 타입언어는 변수 자체에 타입이 있는것이다. 

int x ; 이거 하고 

x = true 라고 하면 에러다. 

정적타입을 도입하지 않고 동적 타입을 도입했다. 자스 언어에는 타입이 없다. 

그럼 타입은 누구에 대한 얘기지? 값에 대한 얘기다. 값이 타입이 있는 거다. 

var x ;  x 라는 식별자가 가리키고, 메모리 공간 안에 들어있는 



 값은 언디파인드 타입이다. 



typeof 라는 연산자가 있는데 이 뒤에 피연산자가 온다. 피연산자 위치에  x ; 라고 쓰면 x 의 타입은??? 이라고 물어보고 있는 뜻이다. 변수의 타입을 물어보고 잇는 것일까?

이거는 변수 x 라는 애가 타입을 갖고있다고 보기보다는 변수 x 에 할당이 되어진 값에 타입이 있다는 뜻이다. 

그럼 저 두 언어의 차이점이 뭘까? 

int 언어는 변수선언할때 이 변수를 사용하는 목적이 뚜렷하다. var 는 이리저리 돌려써도 되 라는 의미를 담고 잇다. x =1 ; 이라고 할당하면 넘버타입, x = true 라고 재할당하면 불리언타입이고, x = { }라고 하면 객체 타입이 된다. 할당을 하면 할수록 타입이 바뀔 가능성이 있다. 

var 언어는 값에만 타입이 있기 때문에 어떤 값을 할당하느냐에 따라서 변수의 타입이 동적으로 바뀐다. 그래서 이것을 동적 타입언어라고 한다.  그리고 변수를 선언할 때 타입을 선언하지 않는다. 다만 var, let, const 라는 키워드(명령어)를 사용해서 변수를 선언할 뿐이다. 이러한 데이터 타입을 모르면 

어떤 문제가 생길까 ? 예를 들어서 1 + 1 은 2로 평가된다. 숫자타입 + 숫자타입 = 숫자타입

1 + 언디파인드 = NaN 값이다. (계산을 못한다. 그러면 에러를 내야 하는게 정석인데, 왠만하면 에러를 안내려고 하기 때문에 그래서 none 이란 어거지 값을 만들어서 계산을 못한다. 라는 값을 만들어 낸다. )



원래는 위 처럼 편하게 쓰라는 목적이 우리의 발목을 잡는다. 그래서 어케 해야 한다? 대부분 내가 뭘 쓸때 얘가 타입이 뭔지 확인할 필요가 있을수 있다. 





타이핑이라는 건 타입을 만든다 라는 뜻으로 받아들여야 한다. 

동적은 뭐고 정적은 뭘까

정적은 한번만들고 그 페이지가 안바뀌는걸 말한다. 

그럼 동적 웹사이트라는 건 뭘까 뭔가 내용이 바뀐다는 것이다. 예를 들어서 로그인화면, 이마리씨 어서오세요. 내가 이마리인줄 어케 알았지? 그 부분을 동적 웹사이트라고 한다. 그때그때 내용에 따라서 바뀌는걸 동적 웹사이트라고 한다. 

동적타입은 타입이 바뀐다. 언제 바뀌나요? 모르지 그건. 근데 바뀐다는 거다. 

정적타입은 타입이 안바뀐다는 것이다. 

변하느냐 안변하느냐. 뭐가? 타입이. 이걸로 동적이랑 정적으로 나눌수 잇다. 

예시) int num ;

​		var x ; 

변수에는 타입이란게 존재하지 않는다. 안 바뀐다는 말은 이 변수 자체가 타입을 갖고 있다는 말이다. 하지만 자스는, 변수에 타입이 있나요? 변수에 타입이라는게 존재하지 않는다. 존재하지 않지만 타입오브라는 연산자를 통해서  x 라고 햇을때, 여기에 표현식을 주는 거다. 

x 라느 타입을 본다라고 써있지만 사실을 하지만 표현식을 여기다 주는거기 때문에 이 표현식의 평가 결과의 타입을 보는 것이다. 

자스는 변수에 타입이 없다고. 그래서 타입이 없으니까 얘는 어떤값도 어떤값도 값을 재할당 할수 있다는 것이다.  바람직하진 않다. 

x= 1;

x = 'sit'

x = ture

x= { };

x = function

등등 

동적으로 타입이 변하고 있다. 이런걸 동적 타이핑이라고 한다. 이게 좋은건가? 편리하긴 하다. 

타입에 상관없이 막 넣을수 잇으니까 , 근데 편리하면 분명히 부작용이 있다. 타입을 알기 어렵다는 부작용.

정적타입은 타입을 바로 알지만 동적타입은 타입이 변하니까 변하는 것을 알아차리기 힘들다. 거기서 실수가 나오는거다. 그래서 변수를 많이 쓰지 말라는 이유다. 그럼 어케 하지?

타입이 반드시 넘버타입이어야 하는 상황이 있다면 그때는 체크를 해야 한다. 그 때 타입이 넘버이면. 라고 체크해야 한다. 근데 그 체크가 꽤나 귀찮다. 

우리는 동적타이핑이기 때문에 체크가 곤란하다. 

동적타입은 개발자 입장에서는 편하다. 하지만 메모리의 손해를 본다. 



재할당은 <u>"가급적"</u> 안하는 거다. 

따라서 var 는 재할당이 자유롭다. let 도 자유롭다 const 는 재할당 못한다. 

필요없는 재할당을 막기위해서 const를 많이 쓰게 될것이다.

우리가 재할당을 왜 하나?  

만약에 재할당을 하게 됬다고 한거면 왜 했을까, 기존의 값을 교체 햇다는 건데,  그건 상태가 변했다는 의미이다. 

예를 들면 지금 불이 켜져잇는데 누가 불을 끄면 불이 꺼져잇는 상태(상태를 유지해야 할때 재할당을 쓰게 된다. 근데 무의미하게 재할당의 길을 열어놓지 말아라.)



변수는 타입이 없지만, 타입이 잇다고 가정하면, 변수의 타입은 언제 결졍되? 할당될때 결정된다. 

그걸 타입 추론이라고 한다. 타입을 지정해주지 않아도 할당되어진 값에 의해서 타입을 추론할수 있다. 

자스는 동적타입 언어이기 때문에 변수를 쓸때 주의해야 한다. 

동적타입언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할수 있다. 

편리는 하지만 위험도 있다. 



**암묵적 타입변환** : 타입이 변하기도 한다는 뜻. 암묵적으로 일어난건 너 모르게 내가 살짝 한다는 뜻이잖아. 그럼 암묵적으로 일어나는 일들을 내가 알고 있지 않으면, 그런 일을 했으리라고 상상도 못하는 것다. 그래서 자스엔진은 암묵적으로 하는게 많기 때문에 우리가 이것을 머릿속에 담아두고 있지 않으면 실수할 가능성이 높다.  그래서 오히려 브랜든 씨는 우리에게 친절한 언어로 만들어줬지만 그게 우리에게 발목을 잡는다. 

**명시적 타입변환 :**



변수는 필요할때만 써라. 이건 당연한 얘기지만 필요할때만 쓰지 못하는 경우들도 있다. 

변수는 재할당이 가능해서 타입때문에 오류가 발생할 가능성이 크다. 변수는 꼭 필요할때만 써라. 

그래서 변수 선언할때 꼭 써야 하는지 생각하고 써라. 

변수가 오래살면 리소스를 차지하게 된다. 



전역변수는 적극적으로 사용을 억제해야 한다. 전역변수는 우리의 적이다. 



변수라는 개념이 있고 상수라는 개념이 있는데 변수는 변하는 수, 상수는 변하지 않는 수라고 알고 잇지만 그렇게 알고 잇으면 안된다. 변수는 재할당이 가능한것이고 상수는 재할당이 불가능한것이라고 알고 잇어야 한다. 재할당이 불필요한 애들한테는 const를 써서 상수화한다. 



![image-20200424154421863](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200424154421863.png)

일주일전의 나와 대화를 하자... 심신을 차분히 가라앉히고... 후...



# 연산자

연산을 하는 무엇인가를 연산자라고 한다. 

연산이 되는 대상을 피연산자라고 한다. 

1개 단항

2개 이항

3개 삼항 연산자

피연산자가 값이라는 명사의 역할을 한다면 연산자는 동사의 역할을 한다. 

## 산술 연산자

더하고 빼고 곱하고 나누고 나머지 

3 % 2 = 1

4 % 2 = 0 (2로 나눠서 0 이면 짝수, 1이면 홀수)

---

## 단항 산술 연산자

++ 증가

-- 감소

"+ " 아무것도 안한다. 

증가를 한다는게 뭘까?

증가를 한다는 의미. x 를 1 증가 시킨다. 증가가 되었다는건 재할당 했다는 말이다. 암묵적으로 재할당이 이뤄졌다고 한다. 이런식으로 연산자 중에서 암묵적으로 재할당이 되는건 2개가 있다. ++ / -- 

부수효과가 잇다. 

= 가 먼저고 x+1 이 다음에 이뤄진다. -> 이건 문법이다. = 보다 먼저된다 나중된다라고 할수 있다. 

암묵적 타입변환 : 지가 알아서 변환하는거

명시적 타입변환 : + 으로 명시적 타입변환 하는게 많다. 

원래 + 뒤에 숫자가 와야 하는 문맥인데 숫자가 안왔다는걸 알아차린다. 뒤에꺼를 숫자로 바꿔버린다. 

var x = '10'

---

## 문자열 연결 연산자

" + " : 피연산자 두개 모두 숫자이면 산술연산자로 동작한다. 둘중에 피연산자 중에 단하나라도 문자열이면 문자열 연결 연산자로 동작한다. 

사실 이게 숫자이기를 바랫던 상황이라면 어케 하면 될까? 그땐 오류를 발생시키겟지. 

true를 숫자로 바꾼다. (문맥에 따라서) + 뒤에 숫자가 오는 문맥이라서 true 를 1로 변환시켜서 값은 2가 된다. 

'1' + false = 1false

null 은 없다라는 뜻이라서 0 이랑 비슷하다. 그래서 0으로 평가된다. 

언디파인드 : 언디파인드 앞에 플러스 연산자 붙힌 코드의 의도는 아~ 이 사람이 언디파인드를 숫자로 바꾸려고 했네~ 였지. 근데 얘가 좀 들 알았네~? 왜? 언디파인드는 약간 부정적 의미를 갖고있지만 0 값이 아니다

1이랑 언디파인드 더하면 NaN 이 나온다. 



---

## 할당 연산자

=  : 5라는 숫자값을 x 변수값에 할당

 += : x 는 x +  5 라는 뜻

표현식이다. 

할당되어지는 값으로 평가되기 때문에 표현식이다. 

c = 0 ; 부터 처리가 된다.

c = 0 을 먼저 안하면 어쩔건데 부터 생각을 해봐라. 원래 맨처음은 0 이다. 0 을 결정하고 ...

= 0  을 0 으로 생각해야한다. b = c  = 0 까지 0  으로 평가된다

## 비교 연산자

= 하나짜리는 할당 연산자이다. 

같은 경우가 있고 틀린 경우가 있으면 트루 풜스로....

== 사용금지이다. 얘는 우리 코드에서 한번이라도 쓰이면 안된다. 

5 == 5  : 왼쪽 5도 리터러리, 오른쪽 5도 리터러리. 값 자체를 비교한것이다. 

원시값일 경우엔 값 자체를 비교한다. 

=== 왼쪽 오른쪽이 같으냐 라고 물어보는거, 같으면 트루값

왼쪽! == 세모  : 왼쪽이랑 오른쪽이랑 다르니? 다르면 트루값, 같으면 풜스

함수 이름은 동사로 지어야 한다. 값은 명사이고 함수는 행위이기 때문에 동사로 지어야 한다.



## 대소관계 비교 연산자

대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.

 var x = 1;  x 가 무슨 값인지 모르는데, x 가 짝수이면 아래 x의 ...

var result ; '' ';

if (x %2 === 0) 이게 0이면 짝수라는 뜻

result = '짝수';(

else)

---

## 삼항 조건 연산자

var x = 1; 

var result = ' ';



if ( x % 2 ===0 ;) {

result = '짝수';

}else {

result = '홀수;

'}

이게 더 가독성이 좋아보입니다. 라고 하지만 

if ( x % 2)  { result = '홀수';

}else {

result = '짝수';

}

이게 더 자연스러운거다.

x % 2?  -> x 가 트루니 풜스니 라고 물어보는것이다.

x 가 트루이면 홀수로 평가되어지고 거짓이면 짝수로 평가되어져야 한다.  ( result = x % 2 ? '홀수' : '짝수';) 



? 랑 : 이거로 이뤄져있다. 

ㅁ ? ㅁ : ㅁ -> 이게 표현식의 문이다.  

ㅁ ? ㅁ : ㅁ

if 문에 쓰여지는 조건식 ? 평가되어지는 표현식 : ㅁ 

- if else를 대체 할수 있다.

  var x = 1;

  var result = x % 2? '홀수' : '짝수';

  이렇게 될수 잇다.

결론 : 일단 if 문으로 만든다 -> 그래서 얘를 삼항 조건 연산자로 고치면 어케 될지 해봐야 한다 -> 더럽다 -> 다시 돌아간다. 

---

## 논리 연산자

논리합 :

true or true = true ll true

하나라도 참이면 참으로 평가한다. 

논리곱: true && true

어느 한쪽이라도 풜스면 풜스

부정: ! true

------

암묵적 타입 변환

10 ;   여기에 트루 풜스가 와야 하는 문맥이야. 

! 'hello' ; 

---

var x ;

var result = ' ';

if (x){

}

: 값을 할당하지 않으면 안하겟다. 

---

## 단축평가

빈 문자열이면 풜스, 아니면 트루 

'cat' 얘가 트루여도 뒤에있는 'dog' 도 봐야한다. 'dog'  가 결정하니까 이 표현식을 결정지어줄 애는  'dog'

## 쉼표 연산자

쓰지 마세요

표현식인 문이다. 

---

## 그룹 연산자

## 타입오브 연산자

## 지수 연산자

math pow(2,2)

-> 첫번째 2 가 밑, 두번째 2 가 지수

반드시 (-5)를 해야 에러가 안난다. (-5 ** 2 )하면 에러난다.

2 * 5 ** 2 ;

 -> "** " 얘가 우선순위 톱이다.

## 연산자의 부수 효과

부수효과 : 연산자가 3개야. 플러스플러스 / 마이너스마이너스  /딜리트 / 

변수의 값이 교체되느냐 를 말하는 것이다. 