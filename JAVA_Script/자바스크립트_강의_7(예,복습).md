# 순수 함수와 비순수 함수

## 순수 함수

*<u>"부수 효과가 없는 함수"</u>*

순수함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다. <br>즉, 매개변수를 통해 함수내부로 전달된 인수에게만 의존하여 반환값을 만드는 함수를 순수함수라고 한다.

```js
var count = 0;
function increase(n) {
return ++n;
}
count = increase(count);
console.log(count); // 1
----------------------------
① count라는 변수에 undefined가 할당되었다가 초기화된다.
② count라는 변수는 새로운 메모리공간에 0 값이 할당된 곳을 가리키게 된다. 
③ 또 다른 메모리공간에 빈 객체가 생성되었다가 그 곳에 객체의 내용이 생성된다.
④ increase라는 함수의 이름이 가리키고 있는 메모리공간은 이미 객체가 생성된 곳의 메모리 주소가 채워져있다.(참조값)
⑤ 함수가 실행이 되어 1이라는 값이 반환된다. 
⑥ 반환된 1이라는 값은 또 다른 새로운 메모리 공간에 채워져서 count값으로 재할당되어,count는 결국 1이라는 값을 가리키게 된다. -> 1 이라는 결과값 도출

count = increase(count);
console.log(count); //2
--------------------------
① 위에서 도출된 count의 1 이라는 값이 다시 매개변수에 할당된다.  
② 함수가 실행이 되어 2라는 값이 반환된다. 
③ 반환된 2이라는 값은 또 다른 새로운 메모리 공간에 채워져서 count값으로 재할당되어,count는 결국 2이라는 값을 가리키게 된다. -> 2 이라는 결과값 도출
```



## 비순수 함수

*<u>"부수 효과가 있는 함수"</u>*

비순수 함수는 함수 외부 상태에 따라 반환값이 달라진다.<br>또한, 비순수 함수는 함수 내부에서 외부 상태(var count = 0;)를 직접 참조하면 외부 상태에 의존하게 되어 반환값이 변할 수 있고, 외부 상태도 변경할 수 있다.  

```js
var count = 0;
function increase() {
return ++count;
}
count = increase();
console.log(count); // 1
----------------------------
① count라는 변수에 undefined가 할당되었다가 초기화된다.
② count라는 변수는 새로운 메모리공간에 0 값이 할당된 곳을 가리키게 된다. 
③ 또 다른 메모리공간에 빈 객체가 생성되었다가 그 곳에 객체의 내용이 생성된다.
④ increase라는 함수의 이름이 가리키고 있는 메모리공간은 이미 객체가 생성된 곳의 메모리 주소가 채워져있다.(참조값)
⑤ 함수 내부에서 함수 외부에 있는 var count = 0; 라는 외부 상태를 직접 참조하는 함수가 실행이 되어 0 이라는 값에서 1이라는 값이 반환된다. 
⑥ 반환된 1이라는 값은 또 다른 새로운 메모리 공간에 채워져서 count값으로 재할당되어,count는 결국 1이라는 값을 가리키게 된다. -> 1 이라는 결과값 도출

count = increase();
console.log(count); //2
--------------------------
① 위에서 도출된 count의 1 이라는 값이 다시 매개변수에 할당된다.  
② 함수가 실행이 되어 1이었던 값은 2라는 값으로 바뀌어 반환된다. 
③ 반환된 2이라는 값은 또 다른 새로운 메모리 공간에 채워져서 count값으로 재할당되어,count는 결국 2이라는 값을 가리키게 된다. -> 2 이라는 결과값 도출
```



모든 함수가 순수 함수인게 가장 이상적이지만 항상 그렇게 되진 않는다.<br>순수 함수로 만든다면 외부 상태에 전혀 의존하지 않고 외부의 상태를 바꾸지도 않기때문에, 보다 견고한 프로그램을 만들수 있다.<br>그렇게 함수형 패러다임은 모든 함수를 순수함수로 만들어보는것을 추구하고 있지만 그렇게 만드는것이 어렵다. <br>하지만 모두 다 순수함수로 만든다면 상태를 관리하는 것이 어렵게 되므로 주의하자.

---

---



# `스코프`란?

> "<u>유효범위</u>"
>
> "JS엔진이 식별자를 찾는 규칙을 스코프라고 한다."
>
> 스코프라고 하는 문법을 통해서 식별자를 찾으러 다닌다.

스코프는 식별자와, 그리고 함수하고 관련이 있다. <br>예를 들어서, 함수의 매개변수는 함수 몸체 내부에서만 참조할수 있고, 유효하다고 누차 얘기해왔다.<br>즉, **매개변수**의 유효범위. 즉 **스코프는 함수 몸체 내부**라고도 말할 수 있는 것이다. 

```js
ex) 매개변수의 스코프는 함수 몸체 내부이다.

function add(x, y) {
console.log(x, y) 
return x + y;
}
add(2, 5);      // 2 5 
				//매개변수 x, y는 함수 몸체 내부에서만 유효하여, 참조 가능하다.
-----------------
console.log(x, y) // ReferenceError
				 // 매개변수 x, y 는 함수 외부 영역에서는 참조할수 없다. 
```

---

또한, var 키워드로 선언한 변수는 같은 스코프 내에서 중복 선언이 허용되며, 함수 내부만 지역으로 인정한다. 	그 외의 키워드로 선언한 변수(let이나 cont)는 코드블록도 스코프로 인정한다.  														  -> 중복 선언이 되어져도 에러를 발생시키지 않는다. 하지만 값의 재할당으로 인해서 값이 바뀔뿐 아니라. ES6 부터는 let이나 const 는 에러를 발생시킨다.

```js
function foo () {
var x = 1;
var x = 2;
console.log(x);
}
foo();
---------------------
// 위 코드는 함수 몸체 내부안에 있는 변수 x 는 하나의 스코프 안에서 동일한 변수를 중복 사용한 상황이다. 중복 사용하여도 에러는 안나지만 값의 재할당으로 인해서 값이 바뀐다. 
```

---

위에서 언급했듯이, JS엔진이 스코프에서 식별자를 찾아다니는데, 하위 스코프에서 상위 스코프로 즉, 아래에서 위로 찾아다니는 모습의 자료구조를 보고 "단방향 링크"라고 한다. 

- 단방향 링크 : 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조가 가능하지만, 하위 스코프에서 유효햔 변수를 상위 스코프에서 참조 할수 없다.



## 전역 스코프 

- 전역 스코프 내의 전역 변수는 어디서든 참조할 수 있다.

- <u>함수 몸체 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언되었다 하더라도 모두 전역 변수이다.</u>
- **<u>함수 객체가 전역 스코프에서 만들어질때, 런타임 이전에 식별자를 선언하고, 함수 객체를 만들고 할당까지 끝마친다.</u>** 

## 지역 스코프

함수  몸체 내부의 영역을 지역 스코프라고 하며 변수 자신의 지역 스코프와 하위 지역 스코프에서 유효하다. 

## (전역 스코프& 지역 스코프 )스코프 정리

"렉시컬 스코프"

![캡쳐96](https://user-images.githubusercontent.com/62126380/81477010-ffce4000-924f-11ea-93de-e7a671de16fb.PNG) 



```js
var x = 1;
function foo (){
    var x = 10;
    bar ();
}
function bar (){
    console.log(x);
}
foo();
bar();
--------------------------------
// 전역 스코프 안의 변수와 지역 스코프 안의 변수가 동일한 이름의 식별자이지만 다른 식별자이다. 스코프가 다른 변수는 서로 다른 식별자이다.
// 1. 전역 스코프: 전역 스코프에 전역 변수로 x 와 foo 와 bar 가 만들어지고, 각각 값은 undefined, 함수 객체 2개가 만들어진다. 
// 2. 런타임이 실행되면서 변수 x의 값은 1 로 재할당이 되며 foo 함수가 호출이 된다.
// 3. foo 함수를 호출하려면 foo함수를 찾아야 하는데, 보니까 foo 함수는 전역 스코프에 있다. 스코프 내에 변수가 있으면 호출이 가능하므로 foo 함수의 지역 스코프가 만들어진다.
// 4. 지역 스코프: foo의 지역 스코프 내에서 x 가 undefined로 할당되었다가 초기화가 되고 10 이 재할당되어진다. 그리고 bar 함수가 호출이 된다.
// 5. bar 함수를 호출하려면 bar 함수를 찾아야 하는데, 찾아보니까 bar 함수는 지역 스코프에 없다. 그래서 상위 스코프로 찾으러 가보니까 젼역 스코프에 있었다. 스코프 내에 변수가 있으면 호출이 가능하므로 bar 함수의 지역 스코프가 만들어진다.
// 6. bar 함수의 지역 스코프를 보니 변수 선언이 되어있지 않고 변수 x 를 출력하라는 console.log만 찍혀있다. 그래서 변수 x 를 보니까 같은 지역 스코프에 없어서 상위 스코프인 전역 스코프를 보니까 변수 1로 값이 할당된 x 가 있다. 

// 결과값 1 1 이란 값이 도출된다.
```

- 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.

- **<u>함수를 어디서 호출했는지 가 아니라 함수를 어디서 정의했는지에 따라서 상위 스코프를 결정한다.</u>**

- JS엔진은 식별자는 스코프 체인에서 찾고, 프로퍼티는 프로퍼티 체인에서 찾는다. 스코프 체인과 프로퍼티 체인 두개가 같이 협력하면서 코드가 실행되어진다. 
- 식별자가 등록이 되면 어딘가에 기억을 해야 하는데, 이때 <u>자료구조</u>를 만들어서 기억을 한다. 그 자료구조를 "실행 컨텍스트" 라고 한다. 실행 컨텍스트에 식별자가 등록이 될때 스코프를 구분해서 등록이 된다. 

---

---



# 전역변수의 문제점

<p style="color:red";> 들어가기에 앞서...</p>

> 변수 호이스팅이나 함수 호이스팅은 스코프를 단위로 동작한다.<br>즉, 호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작한다.

---

전역 변수의 무분별한 사용은 위험하다. 

1. <u>전역변수의 생명주기가 길기 때문이다.</u>

   변수는 생성되고 값을 할당받고 언젠가 짜부러진다. 이렇듯 전역 변수는 생명주기가 있는데, 언제 소멸되느냐를 말한다면 전역 변수는 윈도우가 살아있으면 그때 소멸이 된다. 즉, 윈도우 창을 닫지 않으면 소멸되지 않는다는건데, 이렇게 생명주기가 길게 되면 메모리도 많이 쓰게 되고, 변수의 상태를 변경할 수 있는 시간도 길고, 전역변수는 모든 함수가 참조할수 있기 때문에 상태를 변경할 기회도 많다. 

   -> 변수의 변경이 많이 될 확률이 높아지면 추적도 어려워진다. 이는 에러 발생의 원인이다.

2. <u>var 키워드로 선언한 전역 변수는 전역 객체의 프로터티가 되기 때문이다.</u>

   전역 변수의 생명 주이가 전역 객체의 생명 주기와 일치한다는 말인데, 이렇게 되면 위에서 언급한것처럼 메모리 소모와 추적의 어려움이 있다. 

3.  <u>전역 변수는 어디에서나 참조가 가능하기 때문이다.("암묵적 결합")</u>

   이도 위에서 언급했다. 전역 변수는 코드 어디에서나 참조가 가능한데, 이를 "암묵적 결합"이라고 한다. <br>암묵적 결합이 생기면 변수의 스코프(유효 범위)도 넓어지고, 그렇게 되면 코드의 가독성은 나빠지게 된다.  	함수는 작게 만들어야 한다. 한 함수에서 많은 일을 하게 하지 말고 스코프를 좁게 만들어야 좋다. 

4. <u>전역 변수는 스코프 체인 상에서 종점에 존재하기 때문이다.</u>

   전역 변수는 스코프에서 식별자를 찾을때 가장 마지막에 찾아지는 변수다. 즉, 전역 변수를 스코프 내에서 찾는 속도가 느리다는 것이다. 

5. <u>네임 스페이스가 오염되기 때문이다.</u>

   "네임 스페이스"란, 이름들이(식별자들)이 기억되어지는 공간을 말한다.<br>JS파일을 여러개 만든다 해도 JS는 하나의 전역 스코프를 공유한다. 즉, 파일이 분리되어있다 해도 하나의 전역 스코프를 공유함으로써 이름이 중복될 가능성이 크며, 그로 인해 이름이 충돌될 가능성도 높다. 

   JS에서 var 키워드는 중복 선언이 허용되는 만큼, 이름이 충돌된 가능성이 높아진다는 것이다. 그렇게 되면 예기치 않은 일들이 발생할 가능성도 높아진다. 

-> 그렇기 때문에 지역 변수를 써야 한다. 

### 지역변수를 써야하는 이유는?

1. <u>지역 변수의 생명주기가 전역 변수의 생명 주기보다 짧기 때문이다.</u>

   지역 변수는 함수가 호출되어야 생성이 되고, 소멸은 함수가 종료가 되면 그때 소멸이 된다. 즉, 윈도우창을 닫지 않으면 계속 살아있는 전역 변수들보다는 생명주기가 짧은 것이다. 그렇게 되면 메모리 소모도, 추적의 어려움도 적어진다.

2. <u>지역변수는 함수가 호출되기 이전에는 생성되지 않기 때문이다.</u>

   위에서 언급한것처럼, 지역 변수는 함수가 호출되어야 생성이 된다. 즉, 지역 변수의 생명 주기는 함수의 생명주기와 일치한다. 

   -> 따라서 지역변수는 금새 태어났다가 금새 죽는다. 

3. <u>지역변수는 지역에서만 참조할수 있기 때문이다.</u>

   지역변수는 지역에서만 참조할수 있기 때문에, 변경이 되는 가능성이 적다.<br>그래서 지역변수가 전역변수보다 훨씬 안전하다. ![캡쳐97](https://user-images.githubusercontent.com/62126380/81494616-3b671980-92e5-11ea-9b2d-c2a6f4267eb6.PNG) 

   ​				└> 지역변수의 생명주기는 전역변수의 생명주기보다 짧다. 



## 전역 변수 사용 억제 방법

전역 변수를 반드시 사용해야 하는 이유가 없다면 지역 변수를 사용해야 한다. <br>그러면 이렇게 전역 변수를 자제하고 다른 방법을 쓸수 있는 것들이 뭐가 있을까?

1. <u>즉시 실행 함수을 사용한다.</u>

   즉시 실행 함수는 함수 정의와 동시에 호출되면서, 단 한번만 호출이 된다. 즉, 모든 코드를 즉시 실행 함수로 만든다면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. 이렇게 지역변수로 만드는것이다.

2. <u>전역에 네임 스페이스 객체를 만든다.</u>

   네임 스페이스 객체안에 또 다른 동일한 네임 스페이스 객체를 프로퍼티로 추가하여 구조를 계층적으로 만드는것이다. 이렇게 하면 식별자 충돌은 막을수 있지만 네임 스페이스 객체 자체가 전역 변수에 할당되므로 별로다. 

   -> 전역 변수를 빈 객체로 하나만 만들고 동일한 네임 스페이스 객체를 프로퍼티로 추가

   ```js
   네임 스페이스 객체 안에 동일하지만 다른 네임 스페이스 객체를 프로퍼티로 추가 
   
   ex 1)
   var MYAPP = {};
   MYAPP.name = 'Lee';    // 동일한 네임 스페이스 객체를 프로퍼티로 추가
   console.log(MYAPP.name);
   
   ex 2)
   var MYAPP = {};
   MYAPP.person = {    // 동일한 네임 스페이스 객체를 프로퍼티로 추가
       name: 'Lee',
       address: 'Seoul'
   };
   console.log(MYAPP.person.name);
   ```

3. <u>모듈 패턴</u> <- 이건 클로저를 알아야 한다. 

4. <u>ES6 모듈을 사용한다</u>

   원래 JS에너 모듈을 지원하지 않았는데, ES6 부터 지원하기 시작했다. 하지만 아직 현 단계에서는 불안해서 아직 현업에서 대중적으로 사용하고 있지는 않다.

   script 태구에 type="module" 이란 어트리뷰트를 추가하면 모듈사용을 할수 있다. <br>모듈 파일의 확장자는 "mjs"를 권장한다. 

   ---

   ---



# let, const 와 블록 레벨 스코프

ES5 까지 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이었지만.<br>ES6부터는 var 키워드 뿐 아니라, let 키워드와 const 키워드도 사용하여 번수를 사용할수 있게 되었다.

하지만 var 키워드에는 여러 문제점이 있기에, var 키워드보다 let과 const를 사용하는것이 좋다. <br>그렇다면 var 키워드에는 어떤 문제점들이 있을까?

## var 키워드의 문제점

1. 변수 중복 선언의 허용

2. 함수 레벨 스코프

   var 키워드로 선언한 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정하기 때문에 함수 몸체 밖에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다. 

   ```js
   ex 1) if 문 코드 블럭안에서 변수 선언해도 if 문 코드 블럭 밖에서 선언한 변수와 동일하면
   모두 전역변수가 된다.
   
   var x = 1;
   if (true){
       var x = 10;
   }
   console.log(x); // 10
   
   ex 2) for문 코드 블럭안에서 변수 선언해도 for문 코드 블럭 밖에서 선언한 변수와 동일하면 모두 전역변수가 된다.
   
   var i =10;
   for (var i = 0; i < 5; i++) {
       console.log(i) ;
   }
   console.log(x); // 5
   ```

3. 변수 호이스팅 발생

   변수 호이스팅이 발생하면 var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. <br>단, 할당문 이전에 변수를 참조하면 언제나 undefined 가 반환된다. <br>이는 에러를 발생시키지는 않지만 프로그램의 흐름 상 맞지 않을 뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다. 

## let 키워드

지금까지 얘기했던 var 키워드의 문제점을 보완해준다. <br>그렇다면 let 키워드가 뭘까?

- **<u>변수 중복 선언 금지</u>**

- **<u>let 과 const 는 블록 레벨 스코프를 지원한다.</u>**

  하여, let 키워드로 선언한 변수는 모든 코드블록을 또 다른 스코프인 블록 레빌 스코프로 인정하기<br>때문에 다른 스코프라면 동일한 이름의 변수 사용이 가능하다. 

  ![캡쳐98](https://user-images.githubusercontent.com/62126380/81500359-b5f75f80-930c-11ea-933a-d10657f41eb6.png) 

- **변수 호이스팅이 발생 안한다.** (사실은 발생하는거지만... 발생 안하는것처럼 보이는거임)

  let 키워드는 변수 호이스팅이 발생 안하는걸로 이해하자. <br>왜냐하면, var 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 동시에 일어나지만, 								<u>let 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 분리되어 진행</u>되기 때문이다.  

  ![](https://user-images.githubusercontent.com/62126380/81501156-b514fc80-9311-11ea-936e-da8ec261229f.PNG)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

  ==> 런타임 이전에 암묵적으로 "선언 단계"가 먼저 실행되지만 "초기화 단계"는 변수 선언문에 도달했을때에야 실행된다. 만약에 "초기화 단계"가 실행되기 이전에 변수에 접근하려고 하면 Reference Error가 난다. 

## 전역 객체와 let

전역객체 : 

- 코드가 실행되기 이전 단계에 JS엔진에 의해 제일 먼저 생성되는 객체
- 어떤 객체에도 속하지 않는 최상위 객체
- 브라우저 환경에서는 window 객체를 , node 환경에서는 global 객체를 가리킨다.

----

1. var 키워드로 선언한 <u>전역 변수</u>와 <u>전역 함수</u>, 그리고 <u>선언하지 않은 변수</u>에 값을 할당한것은 전역 객체의 프로퍼티가 된다. -> 전역 객체의 프로퍼티를 참조할때 window 를 생략할 수 있다.

```js
var x = 1;
y = 2;

function foo(){}

ⓐ console.log(window.x);	// 1
   console.log(x);		// 1

ⓑ console.log(window.y);	// 2
   console.log(y);		// 2

ⓒ console.log(window.foo);	// ƒ foo(){}
   conseole.log(foo);		// ƒ foo(){}
-----------------------------------
ⓐ var 키워드로 선언한 변수와 전역 함수는 전역 객체의 프로퍼티가 되기때문에 window를 사용하여 
   접근하는 것도 가능하고, window를 생략하고 접근하는 것도 가능하다.
ⓑ 선언하지 않은 변수는 암묵적 전역이므로 전역 객체의 프로퍼티가 되기때문에 window를 사용하여 접근하는 것도 가능하고, window를 생략하고 접근하는 것도 가능하다.
ⓒ 함수 선언문으로 정의한 전역 함수는 전역 객체의 프로퍼티이며, 전역 객체의프로퍼티는 전역 변수처럼 사용할수 있다. 그러므로 window를 사용하여 접근하는 것도 가능하고, window를 생략하고 접근하는 것도 가능하다.
```

2. let 키워드로 선언한 변수와 함수들은 전역 변수가 아니고 전역 렉시컬 환경의 선언적 환경 레코드 내에 존재하는 것이기 때문에 window의 프로퍼티가 되지 않는다. -> window로 접근할 수 없다. 

```js
let x = 1;
console.log(window.x);	//undefined
console.log(x);		// 1
-------------------------------------
let, const 키워드로 선언한 변수는 전역 객체의 프로퍼티가 아니므로 window를 사용할수 없다.
```



# const 키워드

constant(상수) 의 줄임말로 const 라고 쓰인다.<br>뜻이 "상수"라서 상수에 대해서만  쓰여야 할것 같은 느낌이지만, 꼭 그렇지만은 않다. *<- 우리 var랑 let은 앞으로  쓰지 않기로 해여~~*

let 키워드와 마찬가지로 변수 호이스팅이 발생하지 않는다.(...지만 사실은 변수 호이스팅이 발생하는 것이다.)

### let 키워드와 const 키워드의 차이점

- 선언과 초기화 : <br>let키워드를 사용할때는 변수 선언단계와 초기화 단계가 구분되어있지만, <br>const 키워드를 사용하여 변수에 값을 할당하는 코드를 쓸거면 반드시 const 변수 선언과 값의 할당이 동시에 이뤄져야 한다. <- 안 그러면 SyntaxError(문법 에러)가 난다.

  ```js
  const foo = 1;
  ----------------
  const foo // SyntaxError
  ```

- 재할당 금지 :<br>var 키워드나, let 키워드는 변수에 값의 재할당이 자유롭지만 const 키워드로 사용한 변수는 재할당이 금지된다.

  ```js
  const foo = 1;
  foo = 2; // Error
  ```

- 상수 :<br>상수란 뭘까? 상수는 재할당이 금지된 변수이다. <br>그렇기 때문에 const 키워드로 선언한 변수에 원시값을 할당하면, 그 값은 변경이 불가능하다. <br><- 이 점을 이용하여 일부러 const 키워드를 사용하여 상수를 표현하기도 한다. 

  ![캡쳐105](https://user-images.githubusercontent.com/62126380/81821365-b9892180-956c-11ea-9de0-fb1dd6434e95.PNG)  

  - 위에서 let 키워드로 선언한 코드는 세법을 이용하여 쓴 코드이다. 세율은 바뀌기 어렵기 때문에 <br>아래에 const 키워드로 선언한 코드 처럼 상수로 정의하면 값의 의미를 쉽게 파악할수 있고, <br>변경될 수 없는 고정값으로 사용할수 있다. 

- const 키워드와 객체 :<br>위에서 언급한 것처럼 const 키워드로 선언한 변수에 원시값을 할당하면 이 값은 변경이 불가능하다. 하지만, 객체를 할당하면 값을 변경할 수 있다. 객체는 재할당 없이도 직접 변경이 가능하기 때문이다.

  ```js
  const person = {
      name: 'Lee'
  };
  person.name = 'Kim';
  
  console.log(person);	// {name: "Kim"}
  ```

  위 코드처럼 person이란 객체 내부의 name이란 프로퍼티 키의 값을 'Kim'으로 변경한것이다. -> 값이 'Lee' 에서 'Kim' 으로 변경되었다. 

  

## var 키워드, let 키워드, const 키워드의 추천 사용법

- ES6를 사용한다면 var 키워드는 사용하지 마라
- 재할당이 필요한 경우에만 let 키워드를 사용해라. (이때 변수의 스코프는 좁게 만들어라)
- 변경하지않고 readOnly 한 원시값과 객체에는 const 키워드를 사용해라(const는 재할당을 금지하므로 var랑 let 보다 안전하다)
- var 키워드로 변수를 선언할거면 전부 다 var만 써라. var 도 쓰고 const도 쓰고 하면서 섞어 쓰면 안된다. 