# 생성자 함수에 의한 객체 생성

객체를 생성하는 방법은 다양하다.

1. 객체 리터럴을 사용하여 생성
2. Object 생성자 함수로 생성
3. 생성자 함수로 생성
4. Object.creat 라는 메소드로 생성

위 방법들 중 1번 객체 리터럴을 사용하여 생성하는 건 앞서 다룬 내용이므로, 이번엔 2번부터 시작하는 생성자 함수로 객체를 생성하는 방법을 알아보겠다. 

---



## Object 생성자 함수

__new연산자__ 와 함께 **Object 생성자 함수를 호출** 하면 **빈 객체를 생성**하여 반환한다.<br>이 이후에 **프로퍼티 또는 메소드를 추가**하여 빈 객체를 채워서, 내용을 채운 객체를 완성할 수 있다.

반드시 Object 생성자 함수를 사용해서 빈 객체를 생성해야 하는 것은 아니므로, 특별한 이유가 없다면<br>사용하지마라. 유용하지 않은 함수다.

---



## 생성자 함수 

- 생성자 함수 라고 함은, 객체를 만들어내는 목적을 가지고 있는 함수다

- new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수<br>즉, 생성자 함수에 의해 생성된 객체를 인스턴스라고 한다.

- 생성자 함수와 일반 함수가 생긴 것은 똑같이 생겼지만, 구분하기 위해서 생성자 함수의 함수 이름 첫글자를 대문자로 사용한다.( *<-소문자로 해도 Error는 나지 않지만, 구분을 해주자* )

- 생성자 함수에는 여러 빌트인 함수들이 있는데, 그 중에 우리가 만들수 있는 생성자 함수는<br>Object 생성자 함수 / String 생성자 함수 / Number 생성자 함수 / Boolean 생성자 함수 <br>/ Function 생성자 함수 / Array 생성자 함수/ Date 생성자 함수 / RegExp 생성자 함수 이다. 

  ```js
  1. String 생성자 함수를 사용하여 생성한 String 객체
  const strObj = new String('Lee');
  console.log(typeof strObj); // object (문자열 객체)
  console.log(strObj); // String {"Lee"}
  
  2. Number 생성자 함수를 사용하여 생성한 Number 객체
  const numObj = new Number(123); 
  console.log(typeof munObj); // object(number 객체)
  console.log(numObj); // Number {123}
  
  3. Boolean 생성자 함수를 사용하여 생성한 Boolean 객체
  const booObj = new Boolean(true);
  console.log(typeof booObj); // object(boolean 객체)
  console.log(booObj); // Boolean {true}
  
  4. Function 생성자 함수를 사용하여 생성한 Function 객체
  const func = new Function('x', 'return x * x');
  console.log(typeof func); // object(function 함수 객체)
  console.log(func); // ƒ anonymous(x)
  
  5. Array 생성자 함수를 사용하여 생성한 Array 객체
  const arr = new Array(1, 2, 3);
  consoel.log(typeof arr); // object(array 객체)
  console.log(arr); // [1, 2, 3]
  
  6. Date 생성자 함수를 사용하여 생성한 Date 객체
  const date = new Date();
  conosole.log(typeof date); // object(date 객체)
  console.log(date); // Sun May 17 2020 21:17:00 GMT+0900 
  
  7. RegExp 생성자 함수를 사용하여 생성한 RegExp 객체 
  ```

- 객체 리터럴에 의한 객체 생성은 단 하나의 객체만 생성하기 때문에 프로퍼티 구조가 똑같으면 매번 똑같은  객체를 만들어야 하므로 비효율 적이다 -> 프로퍼티 구조가 똑같은 객체라면, 생성자 함수로 <br>객체를 짧고 간결하게 만들 수 있다.  <br>(대부분 객체마다 프로퍼티 값이 다를수 있지만 메소드는 내용이 동일한 경우가 일반적이기 때문이다.)

  - 객체 리털

  

  ![캡쳐111](https://user-images.githubusercontent.com/62126380/82146669-e9933600-9886-11ea-8535-faedbc3b1eb4.PNG) 

  위 코드에서 볼수 있듯이,

1. 생성자 함수 내부에서의 this 

   - 생성자 함수가 미래에 생성할 인스턴스를 가리킨다.
   - this에는 우리가 필요로 하는 프로퍼티를 담는다.(그러므로, this 뒤에는 꼭 프로퍼티가 와야 한다)
   - 생성자 함수 내부에서의 this는 문맥에 따라서 가리키는 값이 달라진다. 

  2. news 연산자를 통해서 생성자 함수를 호출했다. 

     - new를 쓰지 않고 호출하면 undefined 가 나오고, new를 붙여야 값이 호출된다.

       (new 연산자와 함께 호출하면 해당 함수는 행성자 함수로 동작하지만,<br>new 연산자와 함께 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다.)

        

### 생성자 함수에 의한 객체 생성 방식의 장점

생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스다. <br>객체 리터럴 내부의 메소드 내부에서 사용한 this는 그 메소드를 호출한 객체다. 

그러면 일반함수에서 this를 쓸수 있을까? <br>쓸 수는 있지만, 그때의 this 는 전역객체를 가리킨다.  

![캡쳐112](https://user-images.githubusercontent.com/62126380/82152629-97114400-989d-11ea-9fbe-51373715b52d.PNG)  



### 생성자 함수의 인스턴스 생성 과정

1. 인스턴스(객체) 생성과 this 바인딩

   - 암묵적으로 빈 객체가 생성되고, 생성된 인스턴스, 즉 객체는 this에 `바인딩`된다.

   - 이 처리는 런타임 이전에 실행된다. 

     > __바인딩__
     >
     > 식별자와 값을 연결하는 과정

2. 인스턴스 초기화

   - this에 바인딩되어 있는 인스턴스를 초기화한다

3. 인스턴스 반환

   - 생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된, this가 암묵적으로 반환된다.

![캡쳐113](https://user-images.githubusercontent.com/62126380/82153560-22410880-98a3-11ea-8dad-b666ab5a5138.PNG) 

- 3번의 과정에서 명시적으로 다른 객체를 return  하면 반환해야 하는 this 가 반환되지 못하고, <br>개발자 본인이 명시작 객체가 반환된다.

- 3번 과정에서 명시적으로 원시값을 return 하면 원시값 반환은 무시되고 원래 반환해야 하는 this가 반환된다.

  ==> 따라서 생성자 함수 내부에서 return 문은 절대 명시적으로 쓰면 안된다.  

위에꺼 무조건 외워야 한다. 디스가 가리키는 값이 중요하다.

```js
function foo(){}

foo();
new foo();
```



### 내부  메소드 : [[Call]] 과 [[Construct]]

누차 얘기하지만 함수는 객체다. <br>

<img src = "https://user-images.githubusercontent.com/62126380/82228620-529cab80-9964-11ea-9848-b2460e4693df.PNG"> 

- 함수도 객체이므로, 호출이 가능하다는 함수의 특징을 갖고 있을뿐 아니라, <br>프로터리와 메소드를 갖고있다는 객체의 특징을 갖고있으므로 일반 객체와 동일하게 동작이 가능하다.  <br>__여기서 주의할점은, 일반 객체는 호출을 할수 없지만, 함수는 호출을 할수 있다는 점이다.__         
- [[Call]] 과 [[Construct]] 라는 내부 메소드를 갖고 있다.        



### new 연산자

일반함수와 생성자 함수에 특별한 차이는 없다.

<table>
        <tr align ="center" span style="color:pink">
        <th>[[Call]]</th>
            <th>[[Construct]]</th>
            <th>Non-Construct</th>
            </tr>
    <tr align = "center">
    <td>일반 함수로서 호출</td>
    <td>new 연산자와 함께 <br>생성자 함수로서 호출</td>
            <td rowspan="2">생성자 함수로서 <br>호출할수 없는 함수</td>
    </tr>
    <tr align = "center">
    <td>내부 메소드 <br>[[Call]]이 호출된다.</td>
    <td>내부 메소드 <br>[[Construct]]가 호출된다</td>
    </tr>
        <tr align = "center">
    <td>내부 메소드 [[Call]을 <br>갖는 함수 객체</td>
    <td>내부 메소드 [[Construct]]을<br> 갖는 함수 객체</td>
                <td>내부 메소드 [[Construct]]을<br> 갖지 않는 함수 객체</td>
    </tr>
        <tr align = "center">
    <td>callable 이라고 한다.</td>
    <td>constructor 이라고 한다.</td>
                <td>non-constructor 이라고 한다.</td>
    </tr>
    <tr align = "center">
    <td>모든 함수 객체는 내부 메소드<br> [[Call]]을 갖고 있으므로<br> 호출할수 있다. </td>
    <td>함수 선언문, 함수 표현식,<br> 클래스</td>
                <td>메소드(ES6 메소드 축약표현), 화살표 함수</td>
    </tr>
</table>


==> 모든 함수 객체는 호출할 수 있지만 모든 함수 객체를 생성자 함수로서 호출할 수 있는 것은 아니다.



### new.target

파스칼 케이스를 써서 생성자 함수를 썼다라는걸 알린다 해도 인간이란 늘 실수를 하기 마련이다.<br>이를 방지하기 위하여 ES6 에서는 `new.target` 이라는 방식을 지원한다.

>this 와 유사하게 constructor 인 모든 함수 내부에서 암묵적인 지열 변수와 같이 사용되며
>
>메타 프로퍼티라고도 부른다.

- this 처럼 함수 내부에서 암묵적으로 사용할수 있는 식별자 같은 역할을 한다. <br>즉, new 연산자와 함께 그 함수가 호출되었는지 안되었는지를 식별해낼 수 있는 기능이 있다는 것이다.
- new 연산자와 같이 생성자 함수로서 호출이 되면 함수 내부에서의 new.target은 함수 자신을 가리킨다.만약에 new와 함께 호출되지 않으면 new.target은 undefined 를 가리킨다.  
- 대부분의 빌트인 생성자 함수들은 new 연산자와 함께 호출되었는지 안되었는지 확인하고, <br>적절한 값을 반환하긴 한다. <br>하지만, <br>빌트인 생성자 함수들 중에 String, Number, Boolean 생성자 함수들이 new 연산자와 함께 호출되었다면 String 객체를 생성하고 반환하지만, new 연산자 없이 호출하면 문자열, 숫자, 불리언 값을 반환한다. (타입변환만 한다는 뜻이다.)

---

---

#### 1. 알아두기!!

```js
1번)

function Person(name) {
this.name = naeme;
}
const me = new Person();
```

```js
2번)

const me = new Person('Lee');
function Person(name) {
this.name = naeme;
}
```

1번 코드는 Person 생성자 함수로서 호출을 함수 선언문 아래에 한거고,<br>2번 코드는 Person 생성자 함수로서 호출을 함수 선언문 위에 한것이다.

함수 선언문은 런타임 이전에 실행되니까 둘다 동작은 똑같지만,  2번 코드처럼 코딩하면 안된다. 



#### 2. 알아두기!!

```js
function Person(name) {
this.name = name;
this.sayHi = function () {    
    console.log(`Hi! my name is ${this.name}.`);
    };
}
const me = new Person('Lee');
const you = new Person('Kim')
console.log(me.sayHi === you.sayHi); //false
```

도출되는 결과값이 false 로 나오는 이유는, <br>me 에 할당된 새로운 Person 생성자 함수의 메모리 주소와<br>you에 할당된 또 다른 새로운 Person 생성자 함수의 메모리 주소가 다르기 때문에 false 라는 결과값이 도출된것이다.



#### 3. 알아두기!!

```js
function Person(name) {
this.name = name;
this.sayHi = function () {    
    console.log(`Hi! my name is ${this.name}.`);
    };
}
const me = new Person('Lee');
const you = new Person('Kim')
```

위 코드는 문제점이 있는 코드이다. 

생성자 함수 객체를 새로 만들때마다 sayHi 부분이 쓸데없이 계속 중복으로 만들어 지는 중복의 문제점이 있는 코드인것이다.

-> 그래서 Person 생성자 함수 밖에서 프로토타입 메소드를 만들고, 거기에 sayHi를 넣어주면 된다.<br>아래 코드가 중복의 문제점을 해결한 코드이다. 

```js
function Person(name) {
this.name = name;
}
Person.prototype.sayHi = function () {    
    console.log(`Hi! my name is ${this.name}.`);
    };

const me = new Person('Lee');
const you = new Person('Kim')
```

