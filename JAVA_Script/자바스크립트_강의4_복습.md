

## 조건문

- else if 문을 30번 썼다는건 32개의 경우의수 가 있다는 것이다 -> 이때는 스위치문을 쓰는게 좋다. 

  스위치문은 문법이 개떡같아서 웬만해선 안쓴다. 어쩔수 없는 경우에만 쓴다. 꼭 써야 하는지 생각을 다시 해보고 써보자. 

  if else  를 대체할수 있는건 스위치문이다. 

  

## 스위치문 

정수를 주면 1에서 12까지의 정수를 주면 영어로 노벰버 라는 식으로 번역을 해주는 프로그램을 만든다. 

1에서 10까지의 정수를 주면 1월부터 노벰버까지 만들어서 프로그램을 만든다. 

이걸 이프문으로 할수 있겟찌? 할수 있어요. 이프 먼스는 1이면, 먼스네임은 제눠어리. 

삼항조건으로는 어때? 할수는 있겠지만 지옥일거야. 하지마라. 이프문으로 하면 코드가 지저분해질거니까 스위치문으로 하는게 가독성이 좋을수가 있다. 

이프문에는 괄호 안에 조건식을 줬지만 스위치문에는 괄호안에 표현식을 주면 된다.

케이스문은 콜론으로 문법이 끝난다. -> 이건 먼스가 1이면 이란 뜻이다. 

먼스가 1이면 콜론뒤에 있는 문들을 실행할것이다. 

만약에 괄호 먼스에 숫자값이 들어오면 숫자값이 들어온다. 세미콜론이 아니라 콜론으로 끝난다

트루 풜스로 평가될 필요가 없다. 

먼스가 1이면, 요 콜론 뒤에있는 문들을 실행할것이다.(콜론 뒤에 있는 문: 먼스네임 = 쩨니어리)

반드시 마지막에 브레이크 문이라는 문을 만들어줘야 한다. 

스위치문이나 반복문에서 탈출한다는 것을 브레이크문 이라고 한다. 하나의 키워드,명령문으로 브레이크 를 받아들이면 된다. 

이 실행문이 실행된 후에 브레이크 문이 실행되고 코드블록을 탈출하게 된다. 

스위치문 을 쓸때는 브레이크 문을 안쓰면 큰일난다. 

여러개의 케이스문이 올수도 있음



예를 들어서, 먼스가 1 또는 3 또는 5 또는 7 또는 ... 10 또는 12 

그때에 데이에다가 31 을 주고 브레이크를 한다. 

그리고 먼스가 4 또는 6 또는 ...

이럴때 겹치게 쓸수도 있다. 이 경우에는 윤년 계산 하는 알고리즘을 써야 한다. 할때는 이프 문보다 스위치문이 가독성이 좋다. 

이런 경우 이외에는 스위치문은 별로다.  스위치문을 애용하지 않길 바란다. 

이프 엘스문으로 해결할수 있으면 이프 엘스 문을 써라. 



## 반복문

조건식이 참이라면 반복을 하겠지. 뭐를 ? 코드블록문을 반복하겠지.

자스는 반복문이 3개가 있다.

포문 , 와일문, 두 와일문 이 있는데 두 와일문 잘 안쓴다. 



### 포문

```
for ( ) { }
```

괄호 안에 이프문은 조건식을 썼지만 포문은 문을 3개 준다. 

기본적으로 변수 선언문 하나를 만들어주고, 그 다음에 조건식이 온다. 

i  는 반복을 위한 변수로 통상적으로 쓴다. 

```
for ( var i = 0; i <3 l i ++){ }
```

그러면 위 코드는 어떤식으로 동작하냐면 

저기에 콘솔로그 (아이)를 찍으면 

쭈욱 실행되는게 아니라, 문이 3개 있는데 ㅣ첫번째 문을 딱 한번만 실행되서 아이라는 변수가 만들어지고 0 으로 초기화 된다., 그 아늠아이가 ㅅ감보다 작은거 문이 실행된다. 근데 저게 트루니까 참으로 평가되면 저 코드 블럭이 실행된다. 그럼 값으 0이 찍이 찍힌다. 그 아믕 그다음에 아이 플러플러스가 실행된다. 

아이 플러스플러스는 부수ㅎ부수효과가 있으니까 1이 된다. 현재 아이가 몇? 1 삼보다 작으니까 또 코드블럭이 실행횓낟. 그다음에 첫번째 변수선엄문이 아니라 삼번 아이 플러프러스러고 간다 . 그다음에 아이가 2가 되고 또 2가 값으로 찍힘 

그럼 아이가 3이 된다. 또 아이가 삽ㅁ보바다 작은게 풜스니까 아예 결과값으로 빠진다. 

![image-20200427151025361](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200427151025361.png)



위 코드일 경우에는 1로 아이를 초기화했다. 그다음에 아이가 0보다 같거나 큰거 실행문 실행하고 트루니까 저 코드 블럭이 실행되서 1이 찍히고 아이 -- 실행된다 그럼 1 에서 -- 되서 0 이 찍힘 그 후에 -1 이 찍힘 풜스 니까 안찍고 탈출된다. 앞으로 돌릴수도 있고, 뒤로 돌릴수도 있고. 아이는 아이 플러스 2하면 2씩 증가하는 건다. 

(;;) : 빈 문이라고 한다. 문법상 오케이다. 이거 쓰면 무한반복을 한게 된다. 무한반복을 하게 되면 무슨일이 일어날까 코드블럭이 계속 실행하게 되는데 컴터가 계속 실행하게 될까? 컴터는 이상하게 될수도 있다. 치명적인 경우에는 컴터가 파란색이 될수도 있다. 

![image-20200427151130969](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200427151130969.png)



위코드를 이중 포문이라고 한다. 

저기에 왜 제이가 쓰였을까? 아이 다음은 제이니까. 삼중 포문, 사중 포문(사중 포문은 인간은 이해 못한다. ) 기본 포문은 선형을 쓴다. 12345678 일차원을 위한 포문이다. 2중 포문은 행렬을 나타낼때 쓰임

포문은 가급적 2차까지 쓴다. 3차 쓰는 경우는 게임같은거 , 엔진 만들때 쓰인다. 

위 코드는 어떻게 될지 포문을 머릿속으로 돌려볼까?

맨 처음에 우리가 기억해야 하는 게 뭘까. ... 머릿속에 기억을 해야 해.

아이는 몇? 1 부터 시작해서 6바퀴 도는 거다. 아이가 어떤식으로 변하냐면 123456 까지 변한다. 

1일때 몇바퀴도냐? 6바퀴 2 일때 6바퀴 ...... 36개짜리 경우의 수가 나옴다. 

콘솔로그가 36번 찍힌다. 

아이가 1 , 1  두번째 루프가 첫번째 중괄호 내용이 실행되는거다. 아이는 1인상태고,.... 

1,1 일때는 2니까 안찍고 1, 5일때는 찍고 여기까지 한 사이클 돌았으니까 한번 탈출하고, 다시 실행되서 

아이가 2가 된 상태에서 6번 돈다. 아이가 2일때 제이가 4일때만 찍겠네. 

포문 : 어떠한 자료구조를 순회할때 쓰이는 것이다. 

포문은 실무에서 잘 안쓰이지만 알고리즘 풀때 쓰인다. 알고리즘은 공간복잡도와 시간 복잡도를 써서 퍼포먼스에 쓰인다. 퍼포먼스에 포문이 짱이다. 그래서 그냥 넘어갈수는 없다. 

```javascript
1 변수 x 가 10보다 크고 20보다 작을 때 변수 x 를 출력하는 조건식을 완성하라
(크고 = and = &&)

var x = 15 ;
if(...) {
   console.log(x);
   }
------------------
if(x > 10) && (x < 20) {
    console.log(x);
}
```

 한국말로 정리안되면 코딩이 안됨. 그게 안된 상태에서 코딩을 하면 안된다. 

```javascript
2.for문을 사용하여 0부터 10 미만의 정수 중에서 짝수만을 작은 수부터 출력하시오.
 (for 문을 10바퀴 돌려서 그 안에서 짝수만을 작은 수부터 출력해야 하는데, 짝수를 판별해야 겠네? 짝수면 찍고, 짝수 아니면 아무것도 안한다)

for(var i = 0; i < 10; )
    0부터 라고 했으니까 = 0 ; 
	짝수이면 출력
--------------------------
 for(var i = 0; i < 10; i++) {
  if(i % 2 === 0) console.log(i);
}  
```

```javascript
3.
var str = '';
for (var i = 0; i < 10; i++) {
if(i % 2 ===0) str += i;
}
console.log(str);
콘솔이 str += i ; 다음에 오면 안된다.
밖에서 콘솔로그 찍어야 한다.
```

## 와일문

- 반복문
- 아까 괄호 안에 문 3개 써야 한다고 했는데, 와일문은 하나만 써준다. 
- 몇번 돌아야 할지 모르지만, 계속 값이 중간에 바뀌는데 그 값이 어떤값이 될때까지 돈다. 라고 할때 쓰인다. 

- while (조건식)

  여기서 말하는 조건식이 참이면 그 동안 계속 실행한다. 라는 뜻이다. 

  만약에 조건식이 true 다. 

  while (true) {

  console.log('a')

  }

- var count = 0;

  while ( count < 10) {

  count++;

  console.log(count)}

- 브레이크 문 : 코드블록을 탈출한다는 의미. 이프문은 탈출하지 못한다. 에러가 발생한다. 왜? 이프문에서는 빠져나갈 일이 없다. 빠져나가야한다는 것은 어떤 상황에서 못나가고 있는 경우인데 이프문은 어차피 빠져나가니까 에러난다. 

- 브레이크문에서는 스위치문에서 사용가능한다. 

- 포문에서도 브레이크문, 와일문에서 브레이크문에서 사용가능하다. (레이블문에서도 사용가능한데, 몰라되 됌)

  ```javascript
  몇바퀴 돌지 몰라서 카운트를 1씩 증가한다. 
  
  // 무한루프
  while (true) {
    console.log(count);
    count++;
    // count가 3이면 코드 블록을 탈출한다.
    if (count === 3) break;
  } // 0 1 2
  ```

   브레이크가 되면 이 밑으로 올까? 탈출하면 이프 카운트 문 실행될까? 브레이크 되면 실행안됨. 

## 두 와일문

- 두 한다음 에 와일이야.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
- 이 코드블럭을 한번 실행한다음에....
- 코드 블럭을 최소 한번 이상 하느냐 안하느냐. 

## 브레이크문

- 이프문에서는 못쓴다

- 레이블문 

  - 문에 이름을 붙힌다.

    ``` javascript
    foo: console.log('foo'); // foo라는 레이블 식별자가 붙은 레이블 문
    ```

  -   포문도 이름이니까 포문에 이름을 붙힐수 있다. 

  - ![image-20200427160432196](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200427160432196.png)

    위코드에서 브레이크 아웃이 아니라 브레이크만 있으면...

    바깥쪽 포문에만 붙혓다. 

- 포문은 중요하다. 많이 쓰니까. 왜 많이 쓸까? 반복할 일이 많다는 것이다. 어떨 때 반복을 많이 할까? 데이터(자료구조)가 반복적 구조를 가지고 있으면 반복문을 쓴다. 

- 자료구조: 데이터 스트럭쳐

  코딩 시작전에 정석은 자료구조부터 배우고 와야하는데 시간이 없으니까 그냥 들어간다.

  얘를 뭐라 하냐면, 변수를 우리가 뭐라 하지? **<u>하나의 값</u>**을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별할수 잇는 이름. 변수에는 하나의 값만 담을수 있잖아. 근데 여러개의 값을 담을 일이 많다. 여러개의 값을 뭉뚱그려서 관리할 필요가 있을까? 그게 가능하다면. 여러개의 값이 관련이 있으니까. 그 사용자라는 데이터는 이름과 주민번호로 구성되어져있다. 그 데이터가 있어야 사용자 정보이다. 이런식으로 여러개의 데이터가 더 큰 개념의 데이터를 만드는 경우가 상당히 많다. 

  이때 자료구조라는 것을 만드는 것이다. 

  가장 쉬운 자료구조 : 배열( array) [ 1,2,3 ]

  var x = [1,2,3] 여기서 123 을 각각 요소라고 한다. 1 에 접근 하는 방법은 이름이 x 니까 

  x[0]: 1번째 인덱스(순서)의 요소를 가져와라

  x[1]: 2번째 인덱스(순서)의 요소를 가져와라

  x[2] : 3번째 인덱스(순서)의 요소를 가져와라

  그래서 포문ㅇ을 쓰는데, 

  예를 들어 아래를 포문으로 하나하나하나 볼수 있을까요? 3바퀴 돌아야함.

  arr.length:이 배열의 길이

  var arr = [1,2,3];   

  for ( var  i = 0;  i < arr.length); i++) { 

  console.log( arr [ i ] );

  } 

  -------------------

  todos = [

  { id: 1, content: 'HTML', completed: false },

  { id: 2, content: 'CSS', completed: true},

  { id: 3, content: 'Javascript', completed: false }

  ];

---

string: 객체

length: 프로퍼티

문자열의 길이. 

![image-20200427162207532](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200427162207532.png)



## 컨티뉴문

- 탈출하는게 아니고~
- ![image-20200427162741577](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200427162741577.png)

스트랭스[i] 가 H 라는것이다. 

문자가 엘이 아니면 세지 않는다.  

엘이 엘이면 1 증가시키고 아니면 1 안 증가 시키면 되서 이프 엘스 써도 되는거 아닌가?

 엘이 아니라 o 로 바꾸면 어떻게 될까?

대문자 h면... 

# 타입변환과 단축 평가

- 만약에 명시적으로 타입변환을 했다면 개발자의 의도가 드러냈어서...

- 항상 문제가 되는건 암묵적 처리다. 암묵적으로 타입변환되는걸 캐치하지 못하면 모르기때문에 오류를 맞이할지도 모른다. 그래서 우리는 암묵적 처리하는걸 알아야 한다.

- x.tostring : 쩜을 찍었다는 것은 객체라는 것이다. 

  x 라는 숫자값을 문자열로 바꿧네. 라고 읽힐수가 있다. 투스트링이라는 암호를 호출했다는 것은.... 누가? 개발자가. 개발자가 어떤 이유로 숫자값을 문자값으로 타입을 바꿨네~ 

  이런것은 가독성인 면에서 타입이 변환된것을 알수 잇다. 

- 투 스트링이라는 이름이 오고 괄호를 열고 닫은건 투스트링이라는게 함수라는 것이다. 괄호를 열고 닫은건 함수를 호출한다는 뜻이다. 우리가 함수를 사용하면 우리가 타이밍을 맞춰서 그 코드블럭을 실행할건지 결정할수 잇다. 

```javascript
var x = 10;

// 암묵적 타입 변환
// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다.
var str = x + '';    -> 문자열 10 이 되겟네~ 라고 알수 있다. 
console.log(typeof str, str); // string 10

// 변수 x의 값이 변경된 것은 아니다.
console.log(typeof x, x); // number 10
```

```javascript
// 원시값 1이 '1'로 직접 변경되는 것이 아니다.
// 1을 사용해 타입이 다른 '1'을 새롭게 생성하여 '1' + ''을 평가한다.
1 + '' // '1'
```

바로 위코드에서 1 이라는 숫자 리터럴이 평가가 됨. 1 부터 해석한다. 

숫자고 문자인데 어카지? 라고 컴터가 파악한다. 한쪽이 문자열이면 문자열 연결 연산자로 해석해서 문자열 1이란 값이 도출된다. 그때 숫자 1을 바탕으로 문자열 1을 만들고 그 두개를 이어 붙힌다. 

숫자 1은 문자열이 되는게 아니다. 

예를 들어서 

x = 1; -> 1을 x 로 할당한다는 뜻이다. 

1 + 2 : 1에서 2로 해석한다. 



타입변환에는 명시적타입변환 : 명시적으로 타입변환이 일어나는지 알기 쉽다

암묵적타입변환: 알기 어렵다. 

근데 꼭 그러냐? 암묵적 타입변환은 쓰지 말고, 명시적 타입변환만 쓰라는 말이냐? 그렇지 않고, 암묵적 타입변환이 더 가독성이 좋을수도 있다는 말이다. 실제로는 명시적 타입변환보다 암묵적 타입변환을 더 써서 타입변환 하는게 많다. 

예를 들어서 숫자를 문자열로 명시적으로 개발자가 바꾼다. 이럴때 방법은 여러가지가 있는데 

1이란 숫자를 문자열로 바꿀때 가장 많이 쓰이는 방법은 1 + '' 로 많이 쓴다. 

(1)tostring()   이건 장황하다. 꼭 암묵적 타입변환이 나쁜건 아니다. 



암묵적 타입변환: 코드에는 문맥이라는게 있다. 요 위치는 값이 와야 하는 문맥, 값 중에서느 트루 풜스가 와야 하는 문맥 등이 있다. 

예를 들어서  if (여기는 표현식이 와야 하는데 , 불리언이 왔으면 좋겠지만 꼭 불리언이 안와도 암묵적 타입변환으로 불리언 값이 와도 된다. )

![image-20200427165755758](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200427165755758.png)



첫번째 2 는 암묵적 타입변환으로 문자열이 되었다.

두번째는

곱하기는 문자 연결의 의미가 없다 좌항 우항 모두 숫자가 와야하는 문맥인데 숫자가 아닌게 와도 숫자로 암묵적 타입변환을 한다. 근데 암묵적 타입변환을 못하면 NaN 이된다. 

세번째는 처음에 not 이 왔죠. 근데 불리언이 안왔죠. 0 은 풜스니까 풜스로 타입변환이 되고 앞에 낫이 붙엇으니까 트루다. 

네번째는 괄호 안에 불리언값이 와야 하는데 1이 왔지만 불리언 값으로 타입변환이 된다. 

### 문자열로 타입이 변환되는 경우

x + ' '

문자열이 와야하는 문맥이겠지. 

![image-20200427170056917](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200427170056917.png) 

1 위치는 문자열이 와야 하는 문맥이자

![image-20200427170219417](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200427170219417.png) 

연산의 결과도 암묵적 타입변환이 된다. 

심볼타입 : 함수로 되고, 암묵적타입변환이 안 일어난다. 

### 숫자 타입으로 변환

숫자 타입이 와야하는 문맥이겟지. 

- "+"x

### 불리언 타입으로 변환

불리언 값이 와야하는 문맥이겠지.

대표적으로 조건식이다. 

- "x

```javascript
if ('') console.log(x);
---------------------
빈 문자열이 있기때문에 풜스값이 나온다.

```

아래 값들은 false로 평가되는 Falsy 값이다.

- false
- undefined
- null
- 0, -0
- NaN
- ’’ (빈문자열)

!! 두개면 트루티인지 풜시인지 알수가 있다. 



### 명시적 타입으로 변환

- 문자열로 타입 변환
  - 스트링이라는 생성장소를 호출하면....
  - 스트링 이란 글자 첫번째가 대문자 : 파스칼 케이스로 이름 짓는 경우는 생성자 함수가 클래스일때. 스트링 객체열 ....

- 숫자열로 타입변환
  - 숫자가 와야하는 문맥 
  - 3번, 4번으로. 
  - 곱하기 1 하는 것도 방법이 된다: 숫자로 만들어줄건데, 3번의 첫번째를 추천한다. 
- 불리언 타입으로 변환
  - 낫을 두번 붙이는걸 추천한다. (느낌표 두개) : 불리언값으로 타입변환이 이루어진다. 



### 단축평가

논리연산자에는 논리합이 있고, 논리곱이 있다. 논리합은 트루트루트루 

논리곱은 트루 앤드 트루만 트루

&& 는 원래 논리적 참거짓 구별할때 쓰이지만....

```
'Cat' || 'Dog' // 'Cat'
캣이 트루티니까...
```



``