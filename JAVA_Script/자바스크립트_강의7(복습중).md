# 순수 함수와 비순수 함수

## 순수 함수

*<u>"부수 효과가 없는 함수"</u>*

순수함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다. <br>즉, 매개변수를 통해 함수내부로 전달된 인수에게만 의존하여 반환값을 만드는 함수를 순수함수라고 한다.

```js
var count = 0;
function increase(n) {
return ++n;
}
count = increase(count);
console.log(count); // 1
----------------------------
① count라는 변수에 undefined가 할당되었다가 초기화된다.
② count라는 변수는 새로운 메모리공간에 0 값이 할당된 곳을 가리키게 된다. 
③ 또 다른 메모리공간에 빈 객체가 생성되었다가 그 곳에 객체의 내용이 생성된다.
④ increase라는 함수의 이름이 가리키고 있는 메모리공간은 이미 객체가 생성된 곳의 메모리 주소가 채워져있다.(참조값)
⑤ 함수가 실행이 되어 1이라는 값이 반환된다. 
⑥ 반환된 1이라는 값은 또 다른 새로운 메모리 공간에 채워져서 count값으로 재할당되어,count는 결국 1이라는 값을 가리키게 된다. -> 1 이라는 결과값 도출

count = increase(count);
console.log(count); //2
--------------------------
① 위에서 도출된 count의 1 이라는 값이 다시 매개변수에 할당된다.  
② 함수가 실행이 되어 2라는 값이 반환된다. 
③ 반환된 2이라는 값은 또 다른 새로운 메모리 공간에 채워져서 count값으로 재할당되어,count는 결국 2이라는 값을 가리키게 된다. -> 2 이라는 결과값 도출
```



## 비순수 함수

*<u>"부수 효과가 있는 함수"</u>*

비순수 함수는 함수 외부 상태에 따라 반환값이 달라진다.<br>또한, 비순수 함수는 함수 내부에서 외부 상태(var count = 0;)를 직접 참조하면 외부 상태에 의존하게 되어 반환값이 변할 수 있고, 외부 상태도 변경할 수 있다.  

```js
var count = 0;
function increase() {
return ++count;
}
count = increase();
console.log(count); // 1
----------------------------
① count라는 변수에 undefined가 할당되었다가 초기화된다.
② count라는 변수는 새로운 메모리공간에 0 값이 할당된 곳을 가리키게 된다. 
③ 또 다른 메모리공간에 빈 객체가 생성되었다가 그 곳에 객체의 내용이 생성된다.
④ increase라는 함수의 이름이 가리키고 있는 메모리공간은 이미 객체가 생성된 곳의 메모리 주소가 채워져있다.(참조값)
⑤ 함수 내부에서 함수 외부에 있는 var count = 0; 라는 외부 상태를 직접 참조하는 함수가 실행이 되어 0 이라는 값에서 1이라는 값이 반환된다. 
⑥ 반환된 1이라는 값은 또 다른 새로운 메모리 공간에 채워져서 count값으로 재할당되어,count는 결국 1이라는 값을 가리키게 된다. -> 1 이라는 결과값 도출

count = increase();
console.log(count); //2
--------------------------
① 위에서 도출된 count의 1 이라는 값이 다시 매개변수에 할당된다.  
② 함수가 실행이 되어 1이었던 값은 2라는 값으로 바뀌어 반환된다. 
③ 반환된 2이라는 값은 또 다른 새로운 메모리 공간에 채워져서 count값으로 재할당되어,count는 결국 2이라는 값을 가리키게 된다. -> 2 이라는 결과값 도출
```



모든 함수가 순수 함수인게 가장 이상적이지만 항상 그렇게 되진 않는다.<br>순수 함수로 만든다면 외부 상태에 전혀 의존하지 않고 외부의 상태를 바꾸지도 않기때문에, 보다 견고한 프로그램을 만들수 있다.<br>그렇게 함수형 패러다임은 모든 함수를 순수함수로 만들어보는것을 추구하고 있지만 그렇게 만드는것이 어렵다. <br>하지만 모두 다 순수함수로 만든다면 상태를 관리하는 것이 어렵게 되므로 주의하자.

 

---



# `스코프`란?

> "<u>유효범위</u>"
>
> "JS엔진이 스코프 체인에서 식별자를 찾는 규칙" : 식별자를 찾으러 다닌다.

스코프는 식별자와, 그리고 함수하고 관련이 있다. 

예를 들어서, 함수의 매개변수는 함수 몸체 내부에서만 참조할수 있고, 유효하다고 누차 얘기해왔다.<br>즉, 매개변수의 유효범위. 즉 스코프는 함수 몸체 내부라고도 말할 수 있는 것이다. 

```js
ex) 매개변수의 스코프는 함수 몸체 내부이다.

function add(x, y) {
console.log(x, y) 
return x + y;
}
add(2, 5);      // 2 5 
				//매개변수 x, y는 함수 몸체 내부에서만 유효하여, 참조 가능하다.
-----------------
console.log(x, y) // ReferenceError
				 // 매개변수 x, y 는 함수 외부 영역에서는 참조할수 없다. 
```



 자스엔진 모든 코드는 어디에서, 뭘 찾는다고 하면 식별자는 스코프 체인에서, 프로퍼티는 프로퍼티 체인에서 찾는다. 

이 두개가 같이 협력하면서 코드가 실행되어진다.





스코프라는게 어떤 개념이냐?

함수의 중첩에 의해서 체인이 된다. 부자관계를 맺는다. 만약에 자신의 스코프에서 무언가를 찾는데, 무언가를 찾을때 없으면 위에꺼를 보러 가고, 또 없으면 또 위에꺼를 보러 간다. 그런데 자신의 스코프에도 어떤 식별자가 있고 상위 스코프에도 식별자가 있다고 하면,  자신의 스코프에 있는 걸 보고 상위 스코프에 있는 걸 못본다. 그래서 시야가 가린다라고 한다. 

그래서 가려진다. 라고도 한다. 



그리고 또하나 우리가 함수를 만들었을때 매개변수를 함수외부에서 참조할수 있었나? 없다. 

funtion foo(x,y) {

}

log(x)

---> 위의 x, y 는 중괄호 안에서 하는거다. 위 코드를 코드블럭 밖에 있다고 생각하면 안된다. 이건 이 안으로 주입되는 인터페이스이기 때문에 안에 있는걸로 생각해야 한다. 즉 매개변수들은 함수 내부가 유효범위다.  

여태까지 우리는 변수들을 다 어디에 선언했지? 다 밖에 선언했었다. 

```javascript
var x = 0;

function foo{
var x = 1;
}
```

두개 식별자 x 는 중복이냐? 변수의 존재목적이 값을 구별하여 식별하기 위한거라서 고유해야 한다. 고유하지않으면 식별을 하지 못한다. 두개의 식별자 x 는 중복이 아니다. 왜 아니냐. 스코프가 다르다. 스코프가 다르면 이름이 중복되지 않는다라고 얘기한다. 그럼 중복의 기준은 뭐가 분리된다는거지? 논리적으로 따져봣을 때 스코프가 기준이 된다.

그럼 스코프가 도대체 뭐냐? 

펑션{ }  : 지역 (함수 내부는 다 지역이다.) 지역은 함수가 만든다. 

var x = 0 ; : 전역 (=글로벌)(전역에 위치해서 전역변수)

변수는 자신이 선언된 위치에 의해서 유효범위가 결정된다. 뭐에 따라서? 자신이 선언된 위치에  따라서.

```javascript
var x = 0;

function foo{
var x = 1;
}
function bar {
var x = 1;
}
-----------
두개의 펑션{} 은 다른 지역이다.레벨은 같다. 레빌이라는 것은 전역이 가장 위이고, 그 다음이 지역이다. 
```

그러면 지역은 어떤식으로 불러야할까? foo함수가 만든 지역 var함수가 만든 지역. 그럼 지역은 누가만든다? 함수가 만든다. 근데 원래 지역이라는건  함수만 만드는거냐? 원래는 정석은 뭐가 만드냐면 코드블럭이 만드는 것이다. 근데 자스의 특징 중 하나인데, 바 키워드로 선언한 변수는 함수 내부만 지역으로만 인정한다.                                 

그 외의 키워드로 선언한 변수는 코드블록도 스코프로 인정한다. 



그러면 이프문에 있는 코드블록 있잖아요, 

```javascript
var x = 0;

function foo{
var x = 1;
}
function bar {
var x = 1;
}

if (true) {
var x = 10;    -> 전역변수(함수가 아니니까. )
}

for (var x = 0; x <1; x++) { }
```

다른언어에서는  코드블록을 다 스코프로 인정하기 때문에 바 키워드로 선언한 변수의 경우에 함수 내부에서 선언된 변수는 지역변수로 인정하기때문에.

```javascript
var x = 0;

function foo{
var x = 1;
    function bar {
var x = 1;
}
}
```

위 코드는 중접함수이다. 중첩이라고 하면 부자관계다. 위 코드는 스코프가 3개 있다. 이 스코프들이 어떤 관계를 갖느냐~ 전혀 다른 상관없는 관계냐, 서로 관계가 있느냐 하는건데, 서로 관계가 없으면 어떤 문제가 발생하냐? 서로 관계없으면 서로 각각각이야. 3개의 스코프가 서로 유기적인 연관이 없다면, 동립적으로 동작한다면 아~ 스코프들은 서로 연관관계가 있다. 이걸 스코프체인이라고 한다. 체인이 되엇다는 건 연쇄가 되있다는 말인데, 이건 위아래가 있다는 얘기이다. 가장 위가 누구?  var x = 0; 

전역이 가장 위에 있는것이다. 

변수선언이 뭐라고? 

var x ;

변수선언이란? 식별자의 존재를 자스엔진에 알리는것이다. 나 이제 엑스라는 이름이 있어., 라고 자스엔진에게 알리는것이다. 안 알리면 여기서 콘솔로그 엑스햇을때 안알렸으니까 모르지. 모르니까 어케되? 참조를 못한다. 그럼 알린다는 말은 자스엔진이 앞으로 아~ 앞으로 엑스라는 식별자라는것이 있다. 라는 것을 알고 있어야 한다. 

알린다 = 등록한다.



```javascript
var x = 0;

function foo{
var x = 1;

    function bar {
	var x = 2;
	console.log(x);
}
bar();
}
foo{};
```

알린다는 말을 다른말로 하면 등록한다. 라고도 한다. 식별자로 태어나면 등록을 해야 한다.

식별자로 등록하면 어딘가에 기억해야 한다. 중구난방으로 기억할까, 자료구조를 만들어서 기억할까? 자료구조를 만들어서 기억한다.

그 자료구조를  실행컨텍스트라고 한다. 식별자를 실행컨텍스트에 등록이 된다. 실행컨텍스트 라는건 자료구조라고 생각하면 된다.  그건 통짜로 만들어서 모든 식별자를 다 때려넣을까? 아니다. 

스코프를 구분해서 등록하게 된다. 애를 낳으면 종로구민인지 성동구민인지 구분해서 등록하는것처럼.

어디 출생이냐에 따라서(어디에서 선언되어졌느냐) 스코프를 구분해서 등록이 된다. 

즉 실행컨텍스트에는 스코프가 구분되어져잇다. 각각의  모든 스코프가 유기적인 관련이 있다. 그래서 모든 스코프가 일직선으로 연결되어있다. 찾아서 없으면 위로 가고 거기서도 없으면 위로 가고 한다.

변수가 선언이 되면 등록이 되어진다. 등록이 되어지기 때문에 우리가 찾을수 있다. 

우리는 스코프에서 찾을수 있다. 스코프가 구분되어져있다. 

전역, 푸, 바 에 스코프가 있다. 찾으러 가야되. 그러면 찾으러 갈때는 규칙이 있어야 함. 

얘 이 코드가 있는 위치의 스코프를 찾는거다. 창조하는 코드도 어느 스코프엔가에는 소속되어있다. 

얘는 바 함수에 스코프에 참조 코드가 소속되있음. 그럼 어디서 찾냐면 바 스코프에서 먼저 찾는거다.

찾아서 있으면 쓰고, 위로 올라간다? 안올라간다. 만약에 없어. 없으면 한단계 위로 올라간다 .

얘 위는 상위스코프라고 한다. 상위 스코프에 올라갓더니 잇어 없어? 잇어. 그럼 1이다. 없었으면 하나 더 위로 올라가야되. 

이 선언문이 전역에 있기 때문이라고. 선언문이 어디에 위치하는지에 따라서 스코프가 결정된다.

바로 선언되어있기 때문에 함수 외부에 있으면 무조건 전역변수다.

이프문도 중첩될수 잇을까? 된다. 세번째도 전역이다. 

함수 안에 있으니까 지역이다. 다섯번째도 지역이다. 

이 바 함수는 푸 함수의 중첩함수다.  중첩함수는 스코프를 안만들고 얘랑 스코프 같이 쓰냐? 아니다. 따로 만드는거다. 

전역에서 찾았는데 없으면 지역으로 간다? 이런건 없다. 이런 자료구조를 단방향 링크 리스트라고 한다. 

![image-20200501144500577](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501144500577.png) 



여태까지 변수가 스코프가 있는것처럼 얘기 했는데 변수만 스코프가 있을까? 함수에는 없을까?

foo  함수는 전역함수라고 부를수 있다.

![image-20200501150040703](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501150040703.png) 

전역변수는 어디서 참조가 가능한가? 참조가 안되는 곳이 없다. 다 참조 가능하다. 전역변수는 어디서 호출가능할까? 어디서나 다 호출가능하다. 함수선언문이니까 얘도 식별자를 만들수 있다. 위 코드에서는 푸라는 식별자는 어디에 등록될까?  전역 스코프에 등록된다. 

위에서부터 실행한 선언문은 두개이다. 펑션 {} 이건 런타임 이전에 식별자를 선언하고 함수객체를 만들어서 할당까지 한다.  

함수는 정의했다고 반드시 호출한다는 보장은 없다. 호출 안할수도 있다. 그러면 안되지만 그런 코드가 잇을수도 있다. 그러면 호출도 안되는 걸 먼저 만들었냐? 따라서 모든 프로그램 언어는 최대한 일을 늦게 한다. 미리 하면 손해 볼수 있다. 

펑션 { }안에 있는 내용은 현시점에는 안합니다. 그냥 넘어옵니다. 함수객체만 만들고 끝.  선언문 두개 실행이 끝. 런타임에 들어가서 할당문만 하면 x 라는게 잇어야 할당하죠? 그게 무슨 말이냐면 요 문을 실행할때 맨처음에  x 를 찾는다. 얘가 선언이 된 변수인지 아닌지를 먼저 확인한다.,만약에 선언이 된 변수가 아니라면 할당을 못한다. 그래서 먼저 찾는다. 

어디서? 전역 스코프에서 찾는다. 왜? 요 부분만 참조로 보셔야 해요. 



두개의 선언문을 먼저 한다.그러면 먼저 전역변수 x 를 등록해야 한다. 어디에 등록할래? 전역 스코프에 등록해야 해. 

그럼 이 시점엔 전역 스코프의 실체가 있어야 한다. 이 시점에 그 실체를 만든다. 

 

함수는 호출하는 위치가 중요한게 아니라 정의된 위치가 중요하다. 위 코드는 전역에 정의 되었기 때문에 전역스코프가 상위 스코프다.  정의된 스코프가 자신의 상위 스코프다.

프로퍼티는 어디서 찾을까? 프로토타입 체인에서 찾는다. 







함수 선언문으로 선언된 함수가 있을때 함수 이름이 있고, 함수 이름으로 된 식별자가 있다. 얘네는 스코프가 다른다. 그래서 foo 라는 함수를 만들었을때 foo 라는 식별자는 그 함수가 정의되어진 위치에 해당하는 스코프에 등록되어지고, 함수 이름은 그 foo 함수가 만들어진 스코프 안으로 들어간다. 

따라서, 식별자 이름이 갖다고 해도 이런 식으로 스코프가 분리되어있기 때문에 얘와 얘는 른 애다. 

그런데, 실제로 객체로 존재한다. 모든 식별자는 프로퍼티 키로 생각하면 된다. 

정확히 얘기하면 식별자는 스코프 내에서 중복되면 안된다. 그러면 스코프를 왜 만들었을까?

스코프가 없으면 어케 되? 프로그램을 만들때 한번 변수 이름만들면 두번다시 못쓴다. 이름짓기가 아주...

큰 애플리케이션 만들때 식별자 몇개일까? 몇천개이다. 그걸 다 유니크하게 지어야 하는데 가능할까? 굉장히 어려울것이다. 그렇게 되면 변수에 의미를 주지 못하고 일련번호로 주게 될것이다.



스코프가 있기때문에 유의미한 이름을 지을수 잇다. 

식별자는 폴더 안에 들어가있다고 생각하면 쉬울것이다. 



## 렉시컬 스코프

그 유명한 클로저랑 연결이 된다.

![image-20200501152802524](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501152802524.png) 

대부분 렉시컬 스코프이다. 

어디서 호출되엇는지 별로 안중요하지만

변수의 스코프는 어디서 선언됬느냐, 함수도 어디서 정의 되었느냐가 중요하다

위 코드에서 푸는...

바는... 전역에서 정의 되었다. 그래서 상위 스코프는 전역이다. 

그래서 위 코드 정답은 1 1 이다.



함수는 객체라서 프로퍼티가 있다. ... 감춰진... 이게 바로 클로저다. 



# 전역변수의 문제점

전역변수를 안쓰려면 클로저... 허다하다.

전역변수는 일단 가장 큰 문제점이 뭐냐면 생명주기가 길다. 

변수는 생명주기가 있는데 태어나면 죽는다. 등록이 되어지는걸 태어난다고 한다. 태어나서 언제 죽을까

가비지 컬렉터에 의해서 해방되는걸 죽는다고 한다. 

![image-20200501154312776](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501154312776.png) 

함수가 호출되면 태어났다. 

함수 호출 되기전에 x 는 안태어난다. 호출을 해야 지역변수가 생기다. 

리턴하면 함수가 종료된다. 코드블럭 안에 있는것들이 이때 별볼일 없게 된다. 이때 렉시컬 환경이 해방되어진다. 함수가 호출되면 지역변수가 태어나고 함수가 종료되면 지역변수가 죽는다. 

저 함수가 호출되고 종료될때까지 얼마나 걸릴까? 모르지만 0.001초나 걸릴까말까 하는데 금새 태어낫다가 금새 죽는다. 메모리 공간을 확보하고 다른 애들이 못쓰게 킵한다. 로컬이 6개글자니까 최소 12바티으 공간을 확보하고 다른애들이 못쓰게 한다. 다 쓰면 더이상 이 객체를 아무도 안본다. 가비지 컬렉터에 의해서 해방된다. 함수가 종료되면 해제된다. 죽는다고 생각하자.



따라서 지역변수는 금새 죽는다. 함수를 작게 만들수록 더 빨리 죽는다. 아무리 많은 변수를 만들어도 눈깜짝할 사이에 해방된다. 

근데 전역변수는 어떨까? 전역변수는 언제 태어나고 언제 죽을까? 바 키워드로 선언한 전역변수는..

```javascript
var x = 1;
x  // 1
window.x //1
```

바 키워드로 선언한 엑스라는 전역변수는 언제 죽을까? 윈도우가 살아있으면 안죽는다. 

그럼 윈도우가 언제 죽을까? 윈도우는 창을 닫지 않으면 안죽는다. 

그니까 지역을 써야 한다. 



그래서 우리는 함수를 만들때 함수는 어케 만들어야 한다? 작게 만들어야한다. 왜 작게 만들어야 하나?

스코프를... 하려고. 

하나의 일만 간단하게 짧게 해라 가 기본이다. 

함수만들때 예를 들어서 몇백줄만드는건 심각한거다. 

함수 선언은 스코프 기준으로 올라간다. 스코프 단위로 올라간다. 



전역변수의 문제점은 너무 오래 살아남는다. 

전역변수는 어디서 참조할수 있다? 어디서라고 말하지 말고 어느 코드가 참조할수 잇다? 모든 코드가 참조할수 있으므로 모든 코드가 고칠수 있다. 고칠수 잇으니 변경이 될 확률이 높아지므로 추적이 어려워진다. 



지역변수는 지역에서만 참조할수 있어서, 지역변수는 고칠수 있는 찬스도 적고 변경 될 가능성도 적다.

그래서 지역변수가 전역변수보다 안전하다. 



네임 스페이스가 오염된다. 이름들이 기억되어지는 공간을 네임 스페이스라고 한다. 

이름이 중복될 가능성이 크다. .... 메인 스페이스를 공유한다. 따라서 전역은 안쓰는게 좋다.



## 전역 변수 사용 억제 방법

1. 즉시 실행 함수로 막는다.
2. 네임 스페이스 객체 (좀 올드한 얘기) : 전역변수를 하나만 만든다. 전역변수로 쓰고 싶은 애들은 이 객체의 프로퍼티로 등록한다. <- 이거 하지마세요
3. 모듈 패턴 <- 이건 클로저를 알아야 한다.
4. 모듈





# let, const 와 블록 레벨 스코프



1. 변수 중복 선언 허용

2. 함수 레벨 스코프 :블록 레벨을 지원하지 않는다

    바 키워드로 선언.... 다 전역변수다. 

3.  변수 호이스팅이 발생한다

   선언하고 씁시다.



## let 키워드

변수 중복 선언하면 에러난다. 같은 이름으로 선언하면 에러난다.

렛과 컨스트는 블록 레벨을 지원한다. 이때는 지역변수다. 포문에 변수선언문을 렛으로 선언하면 어디를 지역으로 보나? 포문의 ..... 

![image-20200501162854593](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501162854593.png) 

두 푸는 다른 애다.

그렇다면 호이스팅은 어떨까? 결론적으로는 호이스팅이 발생하긴 하지만 발생 안하는것처럼 동작한다.

![image-20200501162934331](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501162934331.png) 

여기서 바 하면 언디파인드다. 할당이 안되있으니까. = 1 해도 언디파인드다. 

그러면 렛은? 레퍼런스 에러난다. 위 코드만 보면 호이스팅 안일어나네~  할수 있지만 호이스팅 일어나지만 안일어나는것처럼 보인다. 

![image-20200501163035356](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501163035356.png) 

만약에 위 코드에서 호이스팅이 안일어나면 푸는 1이 나와야 한다. 런타임 이전에 변수가 선언되어져야 하는데...  초기화 하기 전까지는 푸에 억세스 못한다. 이게 바로 호이스팅 한다는 거다. 

템퍼러리 데드존 : 일시적 사각지대

언디파인드가 절대 안나온다. 참조 자체가 안된다. 그러면 위코드의 두번째 푸는 초기화가 어케 될꺼 같아? 일단 푸가 등록이 되긴 한다. 특별한 조치를 취한거 같아. 뭐냐면 접근했을때 에러를 발생시킨다고. 그러면 값은 뭘까? 값은 모른다. 그 값으로 평가되면 에러를 발생시킨다고 되어잇다.

모든 식별자를 만드는 .... 전부 호이스팅을 하는데 언디파인드로 초기화되는건 바 키워드가 유일.

함수 선언문은 먼저 식별자가 만들어지고 .... 

렛 컨스트로 선언한 변수는 스코프에 변수가 해당되어지는 스코프에 가장 선두부터 선언문에 도달할때까지 일시적 사각지대에 빠져서 참조할수 없다.



## 전역 객체와 let

브라우저 환경에서는 프론트엔드는 윈도우, 셀프 여러가지 이름이 있지만 우리는 윈도우라고 하면 된다.

글로벌 디스라고도 한다. 

예를 들어서 윈도우 창을 들여다보자. 어떻게 생긴애인지. 



# const 키워드

컨스트는 컨스턴트의 줄임말이다.

컨스턴트는 상수에 대해서만 쓰여야 할거 같은 느낌이다.

상수는? 수학의 상수는 변하지 않는 수. 한번 고정되면 고정된 값에서 변하지 않는 수.

자스에서 상수는 조금 다르다.

재할당을 선언과 동시에 이루어져야한다.

변수에 컨스트가 붙으면 재할당이 금지된 변수다 라는 뜻이다. 그이상 그이하의 뜻이 없다.

즉 객체를 할당했을때 객체를  고칠수 있다. 원시값일때는 못바꾼다. 그러면 우리가 컨스트로 원시값을 할당하면 재할당이 안되잖아? 그때 상수라고 할수 있다. 왜냐면 절대 못바꾸니까. 그때 컨스트를 렛으로 바꾸면 재할당 할수 있다. 



만약에 바 키워드 쓸거면 싹다 바 쓰자. 바도 쓰고 컨스트도 쓰고 하면 안된다. 

---

배열은 렝스 프로퍼티가 있고 객체는 렝스 프로퍼티가 없다. 

아규먼트는 왜 렝스가 잇었지? 걔네는 특별히 유사배열 프로퍼티라서 잇는 것이다. 

```
const arr = [];
const arr = [1]; // 렝스는 요소릐 길이를 나타내기때문에 1 . 순서는 0번이다. 
-----------------
const arr = [1, 2, 3];  
console.log(arr.length);   // 렝스 3 나온다.
-------------------------

for (let i =0; i< arr.length; i++){     // 0 1 2 해서 3번 돌것이다.
console.log(arr[i]);
}
```



---

 선형검색 

선형 : [1, 2, 3] -> 1차원 배열

여기서 2 가 있냐, 있으면 2의 인덱스를 출력. // 1 



```javascript
function linearSearch(array, target) {

}

console.log(linearSearch([1, 2, 3, 4, 5, 6], 1)); // 0
console.log(linearSearch([1, 2, 3, 4, 5, 6], 3)); // 2
console.log(linearSearch([1, 2, 3, 4, 5, 6], 5)); // 4
console.log(linearSearch([1, 2, 3, 4, 5, 6], 6)); // 5
console.log(linearSearch([1, 2, 3, 4, 5, 6], -1)); // -1
console.log(linearSearch([1, 2, 3, 4, 5, 6], 0)); // -1
console.log(linearSearch([1, 2, 3, 4, 5, 6], 7)); // -1
----------------------------------------------------------
array 가 현재 6개 짜리라서 6으로 주면 안된다. 어레이.렝스 줘야 한다. 
순회하면서 target 랑 같은지 봐야한다
인덱스를 나타내는게 i 다.
포문을 돌면서 싹다 찾았는데 못찾았어. 그럼 어케 하지? = 포문을 통과 못햇다.
리턴은 함수내부에서 단 한번만 해야 한다.
우리가 let 뭘 리턴해야 하는거지? 인덱스를 리턴해야 한다.
껄쩍지근한건 렝스다. i < 어레이.렝스 <- 여기서(i) 여기까지가(렝스) 몇번 돌거같냐? 

function linearSearch(array, target)
let index -1;
const length = array.length;

for (let i = 0; i < array.length; i++) {
    if (array(i) === target) index = i;
}
    return index;
```

==>  이거 문제 풀기





예습 :  16, 17



