# 순수 함수와 비순수 함수

## 순수 함수

*<u>"부수 효과가 없는 함수"</u>*

순수함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다. <br>즉, 매개변수를 통해 함수내부로 전달된 인수에게만 의존하여 반환값을 만드는 함수를 순수함수라고 한다.

```js
var count = 0;
function increase(n) {
return ++n;
}
count = increase(count);
console.log(count); // 1
----------------------------
① count라는 변수에 undefined가 할당되었다가 초기화된다.
② count라는 변수는 새로운 메모리공간에 0 값이 할당된 곳을 가리키게 된다. 
③ 또 다른 메모리공간에 빈 객체가 생성되었다가 그 곳에 객체의 내용이 생성된다.
④ increase라는 함수의 이름이 가리키고 있는 메모리공간은 이미 객체가 생성된 곳의 메모리 주소가 채워져있다.(참조값)
⑤ 함수가 실행이 되어 1이라는 값이 반환된다. 
⑥ 반환된 1이라는 값은 또 다른 새로운 메모리 공간에 채워져서 count값으로 재할당되어,count는 결국 1이라는 값을 가리키게 된다. -> 1 이라는 결과값 도출

count = increase(count);
console.log(count); //2
--------------------------
① 위에서 도출된 count의 1 이라는 값이 다시 매개변수에 할당된다.  
② 함수가 실행이 되어 2라는 값이 반환된다. 
③ 반환된 2이라는 값은 또 다른 새로운 메모리 공간에 채워져서 count값으로 재할당되어,count는 결국 2이라는 값을 가리키게 된다. -> 2 이라는 결과값 도출
```



## 비순수 함수

*<u>"부수 효과가 있는 함수"</u>*

비순수 함수는 함수 외부 상태에 따라 반환값이 달라진다.<br>또한, 비순수 함수는 함수 내부에서 외부 상태(var count = 0;)를 직접 참조하면 외부 상태에 의존하게 되어 반환값이 변할 수 있고, 외부 상태도 변경할 수 있다.  

```js
var count = 0;
function increase() {
return ++count;
}
count = increase();
console.log(count); // 1
----------------------------
① count라는 변수에 undefined가 할당되었다가 초기화된다.
② count라는 변수는 새로운 메모리공간에 0 값이 할당된 곳을 가리키게 된다. 
③ 또 다른 메모리공간에 빈 객체가 생성되었다가 그 곳에 객체의 내용이 생성된다.
④ increase라는 함수의 이름이 가리키고 있는 메모리공간은 이미 객체가 생성된 곳의 메모리 주소가 채워져있다.(참조값)
⑤ 함수 내부에서 함수 외부에 있는 var count = 0; 라는 외부 상태를 직접 참조하는 함수가 실행이 되어 0 이라는 값에서 1이라는 값이 반환된다. 
⑥ 반환된 1이라는 값은 또 다른 새로운 메모리 공간에 채워져서 count값으로 재할당되어,count는 결국 1이라는 값을 가리키게 된다. -> 1 이라는 결과값 도출

count = increase();
console.log(count); //2
--------------------------
① 위에서 도출된 count의 1 이라는 값이 다시 매개변수에 할당된다.  
② 함수가 실행이 되어 1이었던 값은 2라는 값으로 바뀌어 반환된다. 
③ 반환된 2이라는 값은 또 다른 새로운 메모리 공간에 채워져서 count값으로 재할당되어,count는 결국 2이라는 값을 가리키게 된다. -> 2 이라는 결과값 도출
```



모든 함수가 순수 함수인게 가장 이상적이지만 항상 그렇게 되진 않는다.<br>순수 함수로 만든다면 외부 상태에 전혀 의존하지 않고 외부의 상태를 바꾸지도 않기때문에, 보다 견고한 프로그램을 만들수 있다.<br>그렇게 함수형 패러다임은 모든 함수를 순수함수로 만들어보는것을 추구하고 있지만 그렇게 만드는것이 어렵다. <br>하지만 모두 다 순수함수로 만든다면 상태를 관리하는 것이 어렵게 되므로 주의하자.

---

---



# `스코프`란?

> "<u>유효범위</u>"
>
> "JS엔진이 식별자를 찾는 규칙을 스코프라고 한다."
>
> 스코프라고 하는 문법을 통해서 식별자를 찾으러 다닌다.

스코프는 식별자와, 그리고 함수하고 관련이 있다. <br>예를 들어서, 함수의 매개변수는 함수 몸체 내부에서만 참조할수 있고, 유효하다고 누차 얘기해왔다.<br>즉, **매개변수**의 유효범위. 즉 **스코프는 함수 몸체 내부**라고도 말할 수 있는 것이다. 

```js
ex) 매개변수의 스코프는 함수 몸체 내부이다.

function add(x, y) {
console.log(x, y) 
return x + y;
}
add(2, 5);      // 2 5 
				//매개변수 x, y는 함수 몸체 내부에서만 유효하여, 참조 가능하다.
-----------------
console.log(x, y) // ReferenceError
				 // 매개변수 x, y 는 함수 외부 영역에서는 참조할수 없다. 
```

---

또한, var 키워드로 선언한 변수는 같은 스코프 내에서 중복 선언이 허용되며, 함수 내부만 지역으로 인정한다. 	그 외의 키워드로 선언한 변수(let이나 cont)는 코드블록도 스코프로 인정한다.  														  -> 중복 선언이 되어져도 에러를 발생시키지 않는다. 하지만 값의 재할당으로 인해서 값이 바뀔뿐 아니라. ES6 부터는 let이나 const 는 에러를 발생시킨다.

```js
function foo () {
var x = 1;
var x = 2;
console.log(x);
}
foo();
---------------------
// 위 코드는 함수 몸체 내부안에 있는 변수 x 는 하나의 스코프 안에서 동일한 변수를 중복 사용한 상황이다. 중복 사용하여도 에러는 안나지만 값의 재할당으로 인해서 값이 바뀐다. 
```

---

위에서 언급했듯이, JS엔진이 스코프에서 식별자를 찾아다니는데, 하위 스코프에서 상위 스코프로 즉, 아래에서 위로 찾아다니는 모습의 자료구조를 보고 "단방향 링크"라고 한다. 

- 단방향 링크 : 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조가 가능하지만, 하위 스코프에서 유효햔 변수를 상위 스코프에서 참조 할수 없다.



## 전역 스코프 

- 전역 스코프 내의 전역 변수는 어디서든 참조할 수 있다.

- <u>함수 몸체 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언되었다 하더라도 모두 전역 변수이다.</u>
- **<u>함수 객체가 전역 스코프에서 만들어질때, 런타임 이전에 식별자를 선언하고, 함수 객체를 만들고 할당까지 끝마친다.</u>** 

## 지역 스코프

함수  몸체 내부의 영역을 지역 스코프라고 하며 변수 자신의 지역 스코프와 하위 지역 스코프에서 유효하다. 

## (전역 스코프& 지역 스코프 )스코프 정리

"렉시컬 스코프"

![캡쳐96](https://user-images.githubusercontent.com/62126380/81477010-ffce4000-924f-11ea-93de-e7a671de16fb.PNG) 



```js
var x = 1;
function foo (){
    var x = 10;
    bar ();
}
function bar (){
    console.log(x);
}
foo();
bar();
--------------------------------
// 전역 스코프 안의 변수와 지역 스코프 안의 변수가 동일한 이름의 식별자이지만 다른 식별자이다. 스코프가 다른 변수는 서로 다른 식별자이다.
// 1. 전역 스코프: 전역 스코프에 전역 변수로 x 와 foo 와 bar 가 만들어지고, 각각 값은 undefined, 함수 객체 2개가 만들어진다. 
// 2. 런타임이 실행되면서 변수 x의 값은 1 로 재할당이 되며 foo 함수가 호출이 된다.
// 3. foo 함수를 호출하려면 foo함수를 찾아야 하는데, 보니까 foo 함수는 전역 스코프에 있다. 스코프 내에 변수가 있으면 호출이 가능하므로 foo 함수의 지역 스코프가 만들어진다.
// 4. 지역 스코프: foo의 지역 스코프 내에서 x 가 undefined로 할당되었다가 초기화가 되고 10 이 재할당되어진다. 그리고 bar 함수가 호출이 된다.
// 5. bar 함수를 호출하려면 bar 함수를 찾아야 하는데, 찾아보니까 bar 함수는 지역 스코프에 없다. 그래서 상위 스코프로 찾으러 가보니까 젼역 스코프에 있었다. 스코프 내에 변수가 있으면 호출이 가능하므로 bar 함수의 지역 스코프가 만들어진다.
// 6. bar 함수의 지역 스코프를 보니 변수 선언이 되어있지 않고 변수 x 를 출력하라는 console.log만 찍혀있다. 그래서 변수 x 를 보니까 같은 지역 스코프에 없어서 상위 스코프인 전역 스코프를 보니까 변수 1로 값이 할당된 x 가 있다. 

// 결과값 1 1 이란 값이 도출된다.
```

- 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.

- **<u>함수를 어디서 호출했는지 가 아니라 함수를 어디서 정의했는지에 따라서 상위 스코프를 결정한다.</u>**

- JS엔진은 식별자는 스코프 체인에서 찾고, 프로퍼티는 프로퍼티 체인에서 찾는다. 스코프 체인과 프로퍼티 체인 두개가 같이 협력하면서 코드가 실행되어진다. 
- 식별자가 등록이 되면 어딘가에 기억을 해야 하는데, 이때 <u>자료구조</u>를 만들어서 기억을 한다. 그 자료구조를 "실행 컨텍스트" 라고 한다. 실행 컨텍스트에 식별자가 등록이 될때 스코프를 구분해서 등록이 된다. 

---

---



# 전역변수의 문제점

<p style="color:red";> 들어가기에 앞서...</p>

> 변수 호이스팅이나 함수 호이스팅은 스코프를 단위로 동작한다.<br>즉, 호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작한다.

---

전역 변수의 무분별한 사용은 위험하다. 

1. <u>전역변수의 생명주기가 길기 때문이다.</u>

   변수는 생성되고 값을 할당받고 언젠가 짜부러진다. 이렇듯 전역 변수는 생명주기가 있는데, 언제 소멸되느냐를 말한다면 전역 변수는 윈도우가 살아있으면 그때 소멸이 된다. 즉, 윈도우 창을 닫지 않으면 소멸되지 않는다는건데, 이렇게 생명주기가 길게 되면 메모리도 많이 쓰게 되고, 변수의 상태를 변경할 수 있는 시간도 길고, 전역변수는 모든 함수가 참조할수 있기 때문에 상태를 변경할 기회도 많다. 

   -> 변수의 변경이 많이 될 확률이 높아지면 추적도 어려워진다. 이는 에러 발생의 원인이다.

2. <u>var 키워드로 선언한 전역 변수는 전역 객체의 프로터티가 되기 때문이다.</u>

   전역 변수의 생명 주이가 전역 객체의 생명 주기와 일치한다는 말인데, 이렇게 되면 위에서 언급한것처럼 메모리 소모와 추적의 어려움이 있다. 

3.  <u>전역 변수는 어디에서나 참조가 가능하기 때문이다.("암묵적 결합")</u>

   이도 위에서 언급했다. 전역 변수는 코드 어디에서나 참조가 가능한데, 이를 "암묵적 결합"이라고 한다. <br>암묵적 결합이 생기면 변수의 스코프(유효 범위)도 넓어지고, 그렇게 되면 코드의 가독성은 나빠지게 된다.  	함수는 작게 만들어야 한다. 한 함수에서 많은 일을 하게 하지 말고 스코프를 좁게 만들어야 좋다. 

4. <u>전역 변수는 스코프 체인 상에서 종점에 존재하기 때문이다.</u>

   전역 변수는 스코프에서 식별자를 찾을때 가장 마지막에 찾아지는 변수다. 즉, 전역 변수를 스코프 내에서 찾는 속도가 느리다는 것이다. 

5. <u>네임 스페이스가 오염되기 때문이다.</u>

   "네임 스페이스"란, 이름들이(식별자들)이 기억되어지는 공간을 말한다.<br>JS파일을 여러개 만든다 해도 JS는 하나의 전역 스코프를 공유한다. 즉, 파일이 분리되어있다 해도 하나의 전역 스코프를 공유함으로써 이름이 중복될 가능성이 크며, 그로 인해 이름이 충돌될 가능성도 높다. 

   JS에서 var 키워드는 중복 선언이 허용되는 만큼, 이름이 충돌된 가능성이 높아진다는 것이다. 그렇게 되면 예기치 않은 일들이 발생할 가능성도 높아진다. 

-> 그렇기 때문에 지역 변수를 써야 한다. 

### 지역변수를 써야하는 이유는?

1. <u>지역 변수의 생명주기가 전역 변수의 생명 주기보다 짧기 때문이다.</u>

   지역 변수는 함수가 호출되어야 생성이 되고, 소멸은 함수가 종료가 되면 그때 소멸이 된다. 즉, 윈도우창을 닫지 않으면 계속 살아있는 전역 변수들보다는 생명주기가 짧은 것이다. 그렇게 되면 메모리 소모도, 추적의 어려움도 적어진다.

2. <u>지역변수는 함수가 호출되기 이전에는 생성되지 않기 때문이다.</u>

   위에서 언급한것처럼, 지역 변수는 함수가 호출되어야 생성이 된다. 즉, 지역 변수의 생명 주기는 함수의 생명주기와 일치한다. 

   -> 따라서 지역변수는 금새 태어났다가 금새 죽는다. 

3. <u>지역변수는 지역에서만 참조할수 있기 때문이다.</u>

   지역변수는 지역에서만 참조할수 있기 때문에, 변경이 되는 가능성이 적다.<br>그래서 지역변수가 전역변수보다 훨씬 안전하다. ![캡쳐97](https://user-images.githubusercontent.com/62126380/81494616-3b671980-92e5-11ea-9b2d-c2a6f4267eb6.PNG) 

   ​				└> 지역변수의 생명주기는 전역변수의 생명주기보다 짧다. 



## 전역 변수 사용 억제 방법

전역 변수를 반드시 사용해야 하는 이유가 없다면 지역 변수를 사용해야 한다. <br>그러면 이렇게 전역 변수를 자제하고 다른 방법을 쓸수 있는 것들이 뭐가 있을까?

1. <u>즉시 실행 함수을 사용한다.</u>

   즉시 실행 함수는 함수 정의와 동시에 호출되면서, 단 한번만 호출이 된다. 즉, 모든 코드를 즉시 실행 함수로 만든다면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. 이렇게 지역변수로 만드는것이다.

2. <u>전역에 네임 스페이스 객체를 만든다.</u>

   네임 스페이스 객체안에 또 다른 동일한 네임 스페이스 객체를 프로퍼티로 추가하여 구조를 계층적으로 만드는것이다. 이렇게 하면 식별자 충돌은 막을수 있지만 네임 스페이스 객체 자체가 전역 변수에 할당되므로 별로다. 

   -> 전역 변수를 빈 객체로 하나만 만들고 동일한 네임 스페이스 객체를 프로퍼티로 추가

   ```js
   네임 스페이스 객체 안에 동일하지만 다른 네임 스페이스 객체를 프로퍼티로 추가 
   
   ex 1)
   var MYAPP = {};
   MYAPP.name = 'Lee';    // 동일한 네임 스페이스 객체를 프로퍼티로 추가
   console.log(MYAPP.name);
   
   ex 2)
   var MYAPP = {};
   MYAPP.person = {    // 동일한 네임 스페이스 객체를 프로퍼티로 추가
       name: 'Lee',
       address: 'Seoul'
   };
   console.log(MYAPP.person.name);
   ```

3. <u>모듈 패턴</u> <- 이건 클로저를 알아야 한다. 

4. <u>ES6 모듈을 사용한다</u>

   원래 JS에너 모듈을 지원하지 않았는데, ES6 부터 지원하기 시작했다. 하지만 아직 현 단계에서는 불안해서 아직 현업에서 대중적으로 사용하고 있지는 않다.

   script 태구에 type="module" 이란 어트리뷰트를 추가하면 모듈사용을 할수 있다. <br>모듈 파일의 확장자는 "mjs"를 권장한다. 

   ---

   ---



# let, const 와 블록 레벨 스코프





# 



1. 변수 중복 선언 허용

2. 함수 레벨 스코프 :블록 레벨을 지원하지 않는다

    바 키워드로 선언.... 다 전역변수다. 

3.  변수 호이스팅이 발생한다

   선언하고 씁시다.



## let 키워드

변수 중복 선언하면 에러난다. 같은 이름으로 선언하면 에러난다.

렛과 컨스트는 블록 레벨을 지원한다. 이때는 지역변수다. 포문에 변수선언문을 렛으로 선언하면 어디를 지역으로 보나? 포문의 ..... 

![image-20200501162854593](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501162854593.png) 

두 푸는 다른 애다.

그렇다면 호이스팅은 어떨까? 결론적으로는 호이스팅이 발생하긴 하지만 발생 안하는것처럼 동작한다.

![image-20200501162934331](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501162934331.png) 

여기서 바 하면 언디파인드다. 할당이 안되있으니까. = 1 해도 언디파인드다. 

그러면 렛은? 레퍼런스 에러난다. 위 코드만 보면 호이스팅 안일어나네~  할수 있지만 호이스팅 일어나지만 안일어나는것처럼 보인다. 

![image-20200501163035356](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200501163035356.png) 

만약에 위 코드에서 호이스팅이 안일어나면 푸는 1이 나와야 한다. 런타임 이전에 변수가 선언되어져야 하는데...  초기화 하기 전까지는 푸에 억세스 못한다. 이게 바로 호이스팅 한다는 거다. 

템퍼러리 데드존 : 일시적 사각지대

언디파인드가 절대 안나온다. 참조 자체가 안된다. 그러면 위코드의 두번째 푸는 초기화가 어케 될꺼 같아? 일단 푸가 등록이 되긴 한다. 특별한 조치를 취한거 같아. 뭐냐면 접근했을때 에러를 발생시킨다고. 그러면 값은 뭘까? 값은 모른다. 그 값으로 평가되면 에러를 발생시킨다고 되어잇다.

모든 식별자를 만드는 .... 전부 호이스팅을 하는데 언디파인드로 초기화되는건 바 키워드가 유일.

함수 선언문은 먼저 식별자가 만들어지고 .... 

렛 컨스트로 선언한 변수는 스코프에 변수가 해당되어지는 스코프에 가장 선두부터 선언문에 도달할때까지 일시적 사각지대에 빠져서 참조할수 없다.



## 전역 객체와 let

브라우저 환경에서는 프론트엔드는 윈도우, 셀프 여러가지 이름이 있지만 우리는 윈도우라고 하면 된다.

글로벌 디스라고도 한다. 

예를 들어서 윈도우 창을 들여다보자. 어떻게 생긴애인지. 



# const 키워드

컨스트는 컨스턴트의 줄임말이다.

컨스턴트는 상수에 대해서만 쓰여야 할거 같은 느낌이다.

상수는? 수학의 상수는 변하지 않는 수. 한번 고정되면 고정된 값에서 변하지 않는 수.

자스에서 상수는 조금 다르다.

재할당을 선언과 동시에 이루어져야한다.

변수에 컨스트가 붙으면 재할당이 금지된 변수다 라는 뜻이다. 그이상 그이하의 뜻이 없다.

즉 객체를 할당했을때 객체를  고칠수 있다. 원시값일때는 못바꾼다. 그러면 우리가 컨스트로 원시값을 할당하면 재할당이 안되잖아? 그때 상수라고 할수 있다. 왜냐면 절대 못바꾸니까. 그때 컨스트를 렛으로 바꾸면 재할당 할수 있다. 



만약에 바 키워드 쓸거면 싹다 바 쓰자. 바도 쓰고 컨스트도 쓰고 하면 안된다. 

---

배열은 렝스 프로퍼티가 있고 객체는 렝스 프로퍼티가 없다. 

아규먼트는 왜 렝스가 잇었지? 걔네는 특별히 유사배열 프로퍼티라서 잇는 것이다. 

```
const arr = [];
const arr = [1]; // 렝스는 요소릐 길이를 나타내기때문에 1 . 순서는 0번이다. 
-----------------
const arr = [1, 2, 3];  
console.log(arr.length);   // 렝스 3 나온다.
-------------------------

for (let i =0; i< arr.length; i++){     // 0 1 2 해서 3번 돌것이다.
console.log(arr[i]);
}
```



---

 선형검색 

선형 : [1, 2, 3] -> 1차원 배열

여기서 2 가 있냐, 있으면 2의 인덱스를 출력. // 1 



```javascript
function linearSearch(array, target) {

}

console.log(linearSearch([1, 2, 3, 4, 5, 6], 1)); // 0
console.log(linearSearch([1, 2, 3, 4, 5, 6], 3)); // 2
console.log(linearSearch([1, 2, 3, 4, 5, 6], 5)); // 4
console.log(linearSearch([1, 2, 3, 4, 5, 6], 6)); // 5
console.log(linearSearch([1, 2, 3, 4, 5, 6], -1)); // -1
console.log(linearSearch([1, 2, 3, 4, 5, 6], 0)); // -1
console.log(linearSearch([1, 2, 3, 4, 5, 6], 7)); // -1
----------------------------------------------------------
array 가 현재 6개 짜리라서 6으로 주면 안된다. 어레이.렝스 줘야 한다. 
순회하면서 target 랑 같은지 봐야한다
인덱스를 나타내는게 i 다.
포문을 돌면서 싹다 찾았는데 못찾았어. 그럼 어케 하지? = 포문을 통과 못햇다.
리턴은 함수내부에서 단 한번만 해야 한다.
우리가 let 뭘 리턴해야 하는거지? 인덱스를 리턴해야 한다.
껄쩍지근한건 렝스다. i < 어레이.렝스 <- 여기서(i) 여기까지가(렝스) 몇번 돌거같냐? 

function linearSearch(array, target)
let index -1;
const length = array.length;

for (let i = 0; i < array.length; i++) {
    if (array(i) === target) index = i;
}
    return index;
```

==>  이거 문제 풀기





예습 :  16, 17



