# 객체란(변경 가능)

JS는 원시타입을 제외하고 나머지 값들은 모두 객체이다.

자스는 패러다임이 멀티패러다임.

우리가 회사에 가면 객체지향적 요소, 함수지향적 요소, 절차 지향적 요소도 있을것이다. 

그럼 객체가 뭘까?

우리 실생활에서 객체란 말 쓰냐? 객체(오브젝트).  객체의 반대말은 주체(서브젝트). 

프로그래밍 언어에서 주체는 프로그래머이다. 프로그램을 만드는 사람이 주체고, 그 밖의 영역은 다 객체이다. 

프로그래머가 인지할수 있는 모든 개념적 사물적 다 객체다. 



우리가 예를 들어서 사람을 설명하려면. 사람도 객체다. 이마리라는 사람 김규민이라는 사람. 내가 겪었던 사람은 다 두개다. 근데 입은 하나다 팔은 두개다 등 특징, 속성을 나열한다.  특징, 속성이 너무 많다. 

근데 우리가 이걸 코딩의 세상에서 속성을 나열하려면, 코딩에서 관심이 있는 대상만 나열하면 된다. 

모든걸 나열할 필요가 없다. 정하기 나름인데, 

person = {

(사람의 이름에 관심이 있다)name = 'Lee'

​												age = 20

}

관심이 있는 대상을 나열.하면 된다. 

객체는 0 개 이상의 프로퍼티들의 집합이다. 

0개 이상의 프로퍼티의 집합이며 프로퍼티는 키(key)와 값(value)으로 구성된다.

프로퍼티를 설명하면 우리가 관심이 있는 데이터. 'Lee'  를 설명하고 있는 키. 

name: 프로퍼티 키 (키를 가지고 문을 따면 값이 나온다. )

'Lee' : 프로퍼티 값

왜 프로퍼티 키가 있을까? 얘를 어케 접근할건데? 이름이 있어야, 아~ 얘한테 접근할수 있구나

근데 이름이 없어도 접근할수 있는 구조가 있다. 하나의 .... 자료구조다. 

이름이 없어도 접근가능: 배열. 

[1, 2] : 배열은 값을 순서(인덱스: 0부터 시작)로 찾는다.

객체는 프로퍼티 키로 찾는다. 

왜 어떤애는 이름으로 찾고, 어떤애는 순서로 찾을까? 

식별자(펄슨) 에 값을 할당하네? { }에는 값으로 평가될수 있는 표현식. 값이 올 문맥이니까 { } 얘는 값이다. 왜 중괄호로 객체를 묶었을까? 여러개의 값을 하나의 값처럼 쓰고 싶어서 그런것이다. 

중괄호 안에 들어온 애들은 어떤 애들일까? 관련있는 애들끼리 묶은거다. 

즉, 중괄호 포함, 중괄호 내용을 값이라고 한다. 객체 리터럴. 값을 만들어내는 표기법. 얘를 해석해서 값을 만들어줄건데 객체라는 값을 만들어줄것이다. 

객체를 만들어라. 라고 명령하는 것이다. 저 식은. 



원시타입은 변경 불가능인데 객체타입은 변경 가능하다. 객체는 패스 바이 래퍼런스다. 

자스에서 말하는 값이란, 7개의 타입이 다 올수 잇다. 객체도 올수도 있다. 행동을 나타내는 함수도 가져올수 있다. 값들은 다 데이터인데, 이것들은 바뀔수 있다. 변한다는 전제하에 현재 객체의 상태를 나타낸다. 이러한 데이터를 변경하거나 참조할수 있는 능력을  var counter  라면 counter 가 갖고 있다. 

현재 넘이 0 이다 : 언제든지 바뀔수 있다는 걸 레포하는 것이다. 즉, 값이란 상태를 나타내고 잇다. 

근데 상태를 메소드가 바꿀수가 있다. 메소드를 왜 중괄호 안에 갖다 놧을까?

중괄호 밖에 있으면 남남이기 때문에 프로퍼티를 바꿀수 있는 권한을 메소드한테만 주는 거다. 

객체의 경우에는 함수를 메소드 라고 부른다. 프로퍼티 값으로 함수가 온것이다. 상태를 나타내는 데이터가 프로퍼티가. 어떤 상태? 객체지향이라는 것은 우리가 일상생활에서... 방법론이다. 메소드는 자기의 자산을(프로퍼티를) 컨트롤하는것이다. 



프로퍼티 : 객체의 상태를 나타내는 값.(명사)

메소드 : 프로퍼티(상태 데이터)를 참조하고 조작할수 있는 동작(동사)

자료구조는 값들로만 이루어진다. 값과 행위가 하나의 세트로 이루어지고 있다.  메소드도 값이다.  

다른 언어는 객체를 만드는 방법이 하나다. 자바는 기본적으로 클래스로 만든다. 

공장에서 찍어내는 그 틀을 클래스라고 한다. (틀, 템플릿)붕어빵 틀이 함수고, 붕어빵은 인스턴스다. 

근데 자스는 클래스가 없어도 리터럴로 만들수 있다는 장점이 있다. 

근데 아까 보니까 자스에는 클래스 문법이랑 비스무리 한게 있다. 근데 강사는 별로다. 



객체를 만드는 방법

- 객체 리터럴로 객체 만든다
- 오브젝트 생성자 함수
- 생성자 함수
- 오브젝트 메소드
- 클래스



이름지을때 프로퍼티는 명사로 지은다. 

... 동사로 짓는다. 또는 동시 + 목적어. 

이름을 이상하게 지으면 코드가 싸보인다. 

```javascript
var person = {
  name: 'Lee',
  sayHello: function () {
    console.log(`Hello! My name is ${this.name}.`);
  }
};

console.log(typeof person); // object
console.log(person); // {name: "Lee", sayHello: ƒ}
```

여기 메소더 안에서 this 를 쓰면 자기자신을 가리킨다.

this.name 이라는건 'Lee' 를 가리킨다. 디스는 프로퍼티를 참조하기 위한 매커니즘이다. 

디스가 없으면 식별자로 인식된다.  



얘는 왜 중괄호 뒤에 세미콜론을 불였을까? 문이 종결되었기 때문에 붙히는 거다. 

{ } 단독으로 쓰면 전부 코드블록이라고 한다. 

프로퍼티 키로 쓸수 있는 것은... 프로퍼니는 원래 문자열이다. 

식별자 네이밍 규칙을 지키지 않으면 에러가 난다. 근데 프로퍼티키는 식별자 네이밍 규칙을 지키지 않아도 된다. 근데 규칙을 지키지 않으면 굉장히 귀찮아진다. 지켜주면 편하다. 

```javascript
var person = {
  // 프로퍼티 키는 name, 프로퍼티 값은 'Lee'
  name: 'Lee',
  // 프로퍼티 키는 age, 프로퍼티 값은 20
  age: 20
};
```

네이밍 규칙을 지킨 코드다.

따옴표를 생략한것처럼 보일까? 매번 넣으면 귀찮으니까...  네이밍 규칙을 지키면 따옴표 생략 가능하다.

그래서 그냥 네이밍 규칙 지키자.

자스에서 쓸수 있는 빈문자열을 제외한 모든 문자열과 심볼을 갖고 있다. 

프로퍼티는 문자열이기 때문에 따옴표를 붙여줘야 하는데 생략할수 있다. 그 얘기는 식별자 네이밍 규칙을 준수하지 않은 이름은 따옴표를 붙혀줘야 한다. 

케밥케이스로 되어있는 식별자 : 식별자 네이밍 규칙 준수하지 않은 이름이라서 따옴표로 묶어줘야 한다.

쉼표는 중간에 붙여줘야 하는데 마지막에 안붙여줘도 된다. 



프로퍼티 키를 동적으로 만들수도 잇다. 



프로퍼티 키를 빈문자로 만들수도 잇다. 프로퍼티 키도 식별자 네이밍 규칙을 준수하시기 바랍니다. '

```javascript
var foo = {
  0: 1,
  1: 2,
  2: 3
};

console.log(foo); // {0: 1, 1: 2, 2: 3}


 0: 1,
  1: 2,
  2: 3

문자열 0 , 문자열 1, 문자열2
```

식별자 네이밍 규칙에 예약어 쓰지마세요.

만약에 프로퍼티 중복되면 덮어써버리게 된다. 먼저 선언한게 나중 선언한거를 덮어써버린다.



## 메소드

프로퍼티의 값이 함수인 프로퍼티를 메소드라고 한다.

프로퍼티에 접근 하는 방법은 어떻게 하느냐인데. 한번 해볼까?

var person = {name; 'Lee'};

-> person. name ==> 이게 참조다. 

여기서 가운데 쩜은 연산자이다. 요 케이스는 쩜을 붙혀서 쓴다. 쩜을 프로터티 접근 연산자라고 하고 마침표 연산자라고 부른다. 마침표 연산자 좌항에는 객체가 와야 하고 우측에는 프로터피 키가 와야 한다. 

 아 띄어쓰기가 중요하구나~

존재하지 않는 프로퍼티 키에 접근하면 언디파인드 값이 나온다 ->  이런 경우의 코드 물어보기.

그럼 어케 접근하면 될까. 반드시 대괄호로 접근해야 한다. 대괄호 안에 프로퍼티 키를 써주는데, 케밥케이스로 넣으면 연산자 - 로 이해하게 된다. // 에러가 나게 된다. -> 따옴표 빼먹으면 안된다. 따옴표 쓴다해도 띄어쓰기 하면 안된다. 

식별자 네이밍 규칙에 준수하지 않는 프로퍼티 키를 쓰면 접근할때 마침표 연산자로 접근할수 없고 대괄호 연산자로 접근해야 하는데 대괄호 안에 따옴표가 붙은 문자열을 넣어줘야 한다.,

객체에 존재하지 않는 프로퍼티에 접근하면 언디파인드 값이 나온다. 

![image-20200428151847043](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200428151847043.png)

위 코드에서 1 : 10 이거 문법에 맞냐? 문자열로 암묵적 타입변환이 일어난다. 

1: 10 값에는 어케 접근해야 할까? -> console.log(prerson.1) 이거 안된다. 이거 하면 에러난다. 

person 뒤에 문자열이 와야 하는데 숫자 1 이 와서 에러난다. 

그럼 '1' 로 하면 되나? 안된다. 왜냐면 문법이다. person[1]은 된다. 따옴표띤건데 왜 되? 따옴표 붙여햐 할거 같지 않아? ['1'] 이렇게, -> 둘다 맞다. [1]로 쓰면 내부적으로 문자열로 봐준다. 

배열의 요소에 접근하는 느낌이지? 따라서 예를 들어서 

문자열이 하나 잇다고 하자 (아이패드 보자 )

문자열, 숫자, 불리언 을 다 대괄호 안에 쓰면 다 객체가 된다. [1] 이란건 프로퍼티 키다. 

그 객체의 1이란 거에 프로퍼티 키가 있다는 뜻이네?\

프로퍼티를 숫자로 쓰면....

console.log(person[1]) 이렇게 써야 한다. 



프로퍼티 값의 갱신이 중요하다.

```구ㅡㅓ브
var person = {
  name: 'Lee'
};

// person 객체에 name 프로퍼티가 존재하므로 name 프로퍼티의 값이 갱신된다.
person.name = 'Kim';

console.log(person);  // {name: "Kim"}
```

'Lee' 를 바꿔주고 싶은거다. 

객체는 재할당 없이도 값을 바꿀수 있다 : 변경 가능하다는 뜻이다. 

원시값을 가지고 있는 변수는 재할당을 안한다고 하면 변수의 값이 안바뀐다는것이 보장된다. 

근데 객체는 재할당을 안한다고 해도 객체가 바뀔 가능성이 있다. 

그래서 원시값이 더 안정적이다. 값이 바뀌는 것이 신뢰성이 없는거냐? 값이 바뀌면 우리가 값이 바뀌엇다는걸 알아채야 한다. 값이 안바뀌는게 프로그램에 안정적이다. 근데 왜 객체는 원시값처럼 동작을 안할까? 메모리 컴퍼런스 때문이다. 그렇게 설계 되엇기 때문에. 그래서 우리가 객체 쓸때 얘가 바뀌엇는지 알아채리기 어렵다 : 이걸 상태 변경을 추적하기가 어렵다고 한다. 



객체를 원시값처럼 쓰려고 한다 : 변경 불가능 한 값처럼 쓰려고 한다는 뜻이다. 어떻게하면 그렇게 될까? 객체 내용이 10개 있는데 내용중에 하나라도 바꿀 일이 있으면 재할당을 한다. 재할당을 하려면 기존에 바뀌기 전꺼를 카피를 해서 새로 만들어서... 만들때 비용이 많이 드는데 그걸 참고 바꾸기도 한다. 왜냐면 원시값이 좋으니까. 

```
var person = {
  name: 'Lee'
};

// person 객체에는 age 프로퍼티가 존재하지 않는다.
// 따라서 person 객체에 age 프로퍼티가 동적으로 생성되고 값이 할당된다.
person.age = 20;

console.log(person); // {name: "Lee", age: 20}
```

프로퍼티를 동적으로 생성할수 도 있다. 

만들어졌다. 과거이다. 만들어진 다음에 프로퍼티를 추가한다. 



삭제할수도 있을까? 삭제는 프로퍼티를 삭제한다는 얘기다. 삭제할때는 딜리트 연산자를 써줘야 한다. 

그전에 프로퍼티를 삭제할 경우가 뭘까? 왜 삭제하려고 하나? 객체를 만들었어. 만들었더니 프로퍼티가 있어. 근데 굳이 왜 삭제할까? 필요없어서? 그럼 왜 만들었나? 딜리트 연산자는 안쓰는 것을 추천한다. 

지우면 뭐가 나쁜까? 안정성이 떨어지는 거다. 있었는데 지웟는데 다른 사람은 필요할수도 있다. 그래서 지우지 말고 냅두자. 



예를 들어서 프로퍼티 값이 오는 위치에 변수 표현식을 줄수 있을까? 줄수 있다. 왜 있나? 

![image-20200428153703254](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200428153703254.png) 

위처럼 값으로 평가될수 있으니까. 그니까 줄수 있다. 

x : 프로퍼티 키 

x : 값

우연히도 두개 이름이 같다. 이럴때는 중첩인데, 프로퍼티 키와 프로퍼티 값은 쌍으로 이뤄지니까 

x,y 이라는건 x : y 라는 뜻이다. (아래처럼)

![image-20200428153823814](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200428153823814.png) 



### 메소드 축약 표현 

- 아이패드 보기
- 

# 원시값과 객체의 비교

데이터타입에 살펴봤듯이 데이터 타입은 총 2가지다. 원시타입과 객체타입(참조타입).

다른 언어는 어떨까? 다른 언어도 두개로 나눌까? 대부분의 언어가 객체타입이 있고 원시타입이 있다. 

자스가 발명해낸게 아니라는 거다. 

원시값을 변수에 할당하면 실제 값이 저장되고, 객체를 변수에 할당하면 참조값이라는게 저장된다. 

원시값을 가지고 잇는 값을 변수에 할당하면 원본에 값 자체가 .... 복사되어지고 ... 할당하면 참조값이 정장되어서 전달되어진다. 



## 원시값

원시타입의 값은 변경이 불가능하다.

원시값은 리드 온니하다는 말이다. 리드 온니하다고 하면 읽기전용이라는 뜻이다. 바꾸지는 못한다. 

근데 우리가 헷갈리는건 변경 불가능하다느 뜻을 값과 변수를 분리해서 생각해야 한다. 

값이 뭐엿죠? 표현식이 평가되어져서 생성되지거나 참조되지는거. 메모리에 저장되어지는 것. 

메모리에 저장되어지지 않는것은 값이 아닌가?

우리가 1 이라고 브이에스코드에 쓰면 이건 값이냐? 값 아니다. 엄밀히 따지면 리터럴이다. 이 리터럴이 자스엔지 읽어들여서(메모리로 불러들여서) 값을 만들어야 한ㄴ데 어떤값을 만들어야 하는데 십진수를 1로 주면서 너 이걸로 숫자를 만들어 하면 이에 대응하는ㄴ 2ㅅ진수로 만들어서 메모리에 저장한다. 이게 값이다. 

그럼 변수는 뭘까? 값은 변수이냐? 아니다. 변수는 하나의 값을 저장하기 위해서 확보한 메모리 공간 그 자체다. 

변경이 불가능하다는 건 값에 대한 얘기다. 변수의 값이 변경된다고 한적 없다. 변수의 값이 변경이 안되나요?

재할당을 하면 변수는 값을 바꿀수 있습니다. 만약에 못바꾸면 변수라고 안하고 상수라고 한다. 

이때 값이 바뀌었냐, 하면 바뀐게 아니다. 변경 가능하다고 하면 따라가면 변수 값이 아니라 메모리주소가 나온다. 객체는 변경 가능한 값이잖아. 변경을 어케 할건데? 

```javascript
ex) 변경 어케 할건데?
var o ={};
o,x =1;
delete o,x
o ={ } ==> 이건 재할당이다. 재할당을 하면 주소값이 바뀐다. 
```

변경 가능하다는 것은 메모리 주소 변경 없이 값을 바꾸는 것이다. 원시값은 ... 반드시 재할당을 해야 한다. 객체는 재할당 없이도 값 자체를 바꿀수 있다. 라는 차이가 있다. 

변수에 할당한 값을 재할당을 안한다고 하면 한번 할당한 값은 결코 바뀔일이 없다. 하지만 객체의 경우는 재할당을 안하겠다고 약속을 하자. 그래도 바뀔 가능성이 있다. 그래서 원시값은 재할당을 안한다고 신뢰성이 굉장히 높은거다. 근데 객체는 굉장히 잘 바뀔 확률이 높다. 그래서 값을 추적하는것이 어렵다. 



그러면 왜 그런식으로 설계했을까?

객체는 프로퍼티가 여러개있을수도 있잖아. 100개일수도 있고 1000개 일수도 있다. 

그러면 확률적으로 따졌을때 객체가 원시보다 훨씬 크다. 숫자 하나가 클까 함수가 클까, 함수가 훨씬 크다. 

만약에 객체가 원시값처럼 동작해야 한다면, 값을 바꾸었을때 변경 불가능하다고 하면 새로운 메모리 공간을 만들어야 한다.  바뀔때마다 만들어야 한다. -> 이렇게 안하는 이유는 메모리에 대한 부담이 있다. 

불변객체를 만든다. (원시값처럼 불변값을 만든다.)-> 이러면 객체가 바꼈는지 안바꼈는지 알아차리기가 쉽다. 어케? 주소가 바뀌면 무조건 바뀐것이다. 

재귀. 이걸 무한반복해야 한다. 퍼포먼스가 굉장히 비효율적이다. 

- 딥카피 : 이걸 하려면 굉장히 퍼포먼스가 필요한 행위다.

- 쉘로우 카피: 딥카피의 반대말

원시값은 변경할수 없다(리드 온니하다)

그래서 원시값은 불변성을 갖는다. 문자열은 굉장히 재밌는거다. 문자열이라는건 자스에서는 원시값이다. 다른 언어에서는 원시값일 수가 없다. 원시값은 메모리를 생성할때 바이트 수가 정해져잇다. 

문자 타입이 잇다.  ['a,'b','c'] 자스에서 문자열이 원시값이라는건 굉장히 독특한것이다. 



 ### 값에 의한 전달

![image-20200428163302664](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200428163302664.png) 

저 두개의 80은 다른 값이다. 

원시값은 이런식으로 원시값을 할당한 변수를 어떠한 값에 준다해도 다른쪽에 영향을 주지 않는다. 

신뢰성이 보장된다는 것이다. 

객체를 만드는것은 원시값을 만드는것보다 훨씬 어렵다. 

**... 두번 찾아가는 거다** -> 이거 다시 자세히 듣기. 주소로 가서 찾아갔더니 주소값이 나오느냐, 값이 나오느냐. 객체를 여러명이 공유해서 쓰려고 한다. 두개의 식별자가 하나의 값을 가리키는 것이다. -> 이건 부작용이다. 메모리 공간은 객체가 많이 차지하지만 부작용이 있지만 이렇게 쓰는 것이다. 

그러면 프로그래머들에게 이런 상황이 발생한다는것을 잘 알고 있어야 한다. 이런 상황이 싫으니까 원시값처럼 쓰려고 하는거다. 

```javascript
var person1 = {
name: 'Lee'
};

var person2 ={
name: 'Lee'
};

console.log(person1 === person2); //
console.log(person1.name === person2.name); //

```





# 함수

만드는 방법이 4개가 있다. 

function add (매개변수) { }

매개: 이어준다. 뭐와 뭐를? 함수 바깥에 있는 값과 함수 안에 있는 변수와 연결해주는 것이다. 

함수 바깥에 있는거를 안에 있는 함수로 붓는거다. 

어떤 기계가 있는데 두개의 재료를 더하는 것만 전문적으로 하는 기계가 있는데, 외부에 있는 재료를 

안에 있는 재료를 넣어야 하는데 투입구가 있을거잖아, 그 투입구에다가 재료를 넣어주는거다,'

넣어주면 그 재료를 받아서 정해진 자기 일을 하는거다. 

function add (x, y) { 

return x + y;

} // 함수정의

add (1, 2) //함수호출. 1, 2 는 인수. 

console.log(x);

함수호출을 하면 1, 2 값 2개를 위의 괄호 안의 엑스와 와이(매개변수)에게 전달된다(할당된다). 

리턴이란 것은 뒤에 있는 표현식을 평가해서 함수 바깥으로 튕겨내야 한다.

섞은 재료를 만들엇으면 함수 바깥으로 튕겨내는것. 

원래는 (var x , var y  ) 라고 쓰고 싶었던것이다. 

기계는 호출문이 실행되야 1번 동작한다. 

함수호출문은 표현식이다. 무슨 값으로 평가된다? 반환문으로 평가된다.

function add (x, y) { 

return x + y;

} 

var result = add (1, 2)  

console.log(result); // 3

add : 함수이름

함수 이름은 함수몸체(코드블럭)안에서만 유효하다. 라는 문법이 있다. 

함수 이름으로 함수를 호출할수 없다. 그럼 뒤의 add 는 암묵적으로 함수 이름을 가지고 식별자를 만든것이다. 언제 만들었을까? (펑션~{} //함수 선언문) 이라고 하는데, .... 위치를 가리킨다.   

선언문은 런타임 이전에 실행된다. 함수 선언문도 런타임 이전에 실행된다.

var result = add (1, 2)  

console.log(result); 

function add (x, y) { 

return x + y;

} 

----> 이것도 잘 작동한다. 변수는 호이스팅한다고 했지. 함수 호이스팅이랑 다르다. 함수 호이스팅은..

호출까지 가능해. 정의 전에 호출할수 있다는 얘기네? 이건 부작용이야. 안좋은거야. 호이스팅을 이용하면 안되고 정의하고 호출하는 순서를 지키도록 하자. 



화살표 함수는 일반적으로....

화살표 함수는 굉장히 중요하다. 콜백 함수로 쓰인다. 

[ 1,2,3,4,5].filter (인수에 함수를 준다.)





 



