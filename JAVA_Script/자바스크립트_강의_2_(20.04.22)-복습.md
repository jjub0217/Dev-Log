## 변수문법

- 컴퓨터는 코드를 위에서 아래로 순차적으로 실행한다.

- 명령은 value(값), operator(연산자), expresstion(표현식), comment(주석)으로 구성되며 세미콜론(;)으로 '문'을 끝마친다. 

##### 예시1

![캡쳐51](https://user-images.githubusercontent.com/62126380/80062371-8acfea80-856e-11ea-9ff9-9a1e54934f68.png) 

``` 
var result ; 

변수 선언만 하고, 값을 할당하지 않은 상태 라서 -> undefined 값이 도출
----------------------------------------------------------------
var result ;
result = 10 + 20 ;

변수 선언도 하고, 변수에 값도 할당한 상태 -> 정상 작동
```

##### 예시2

![캡쳐52](https://user-images.githubusercontent.com/62126380/80063263-80165500-8570-11ea-88b6-892dc699f08a.png) 

```
result = 10 + 20 ;

변수 선언을 안한 상태에 값을 할당했는데 왜 에러가 안나오죠?  
-> 친절한 JS씨라서 "너 선언하는거 까먹었지...? 어휴.. 내가 알아서 출력해줄게" 하고 자동으로 결과값을 도출해줌.  -> 정상 작동
------------------------------------------------------------------------------
①result = 10 + 20 ;
 var ②result ;

①result 랑 ②result 은 다른 result 다. 
왜냐? 친절한 JS씨가 "너 선언하는거 까먹었지...? 어휴.. 내가 알아서 출력해줄게" 하고 자동으로 ①result 값을 벌써 출력을 이미 다 해줬는데 또 ②result 를 선언한다. 이건 중복이다. 그래서 ①result 값을 지워버리고 다른 ②result 값이 새로 생겨버린 상태라서
-> undefined 값이 도출 
```



## 레퍼런스 에러(참조 에러)

<p style="color:red";> 들어가기에 앞서...</p>

1. 변수 참조( "cosole.log(~)" ): 변수의 값을 가지고 와서 출력해달라는 명령

   ```
   ex)
   var result ;
   console.log(result);
   ----------------------
   선언한 변수 "result" 값을 출력해줘!!!
   -> 결과 : 할당한 값이 없으므로 undefined 값 도출
   ```

---

레퍼런스 에러 : 선언된적이 없는 변수를 참조하려고 할때 발생하는 에러

##### 예시1 (레퍼런스 에러 발생)

```
var result = 10 + 20 ;
console.log(score)
------------------------
"result" 라는 변수를 선언했는데, 참조한 변수는 "score" 이란 변수라서 레퍼런스 에러 발생
```

![캡쳐53](https://user-images.githubusercontent.com/62126380/80066296-a0491280-8576-11ea-8a51-caebc85666ea.PNG) 

##### 예시2(레퍼런스 에러 X)

``` 
1. var result = 10 + 20 ;
   console.log(result) ;
-----------------------------
"result" 라는 변수를 선언 + 변수에 값을 할당 + 참조한 변수 "result"로, 선언한 변수를 참조
-> 에러 없이 값이 3으로 정상 도출

2. console.log(result) ;
   var result = 10 + 20 ;
-----------------------------
-> 결과 : undefined값 도출(레퍼런스 에러X)

위 코드는 변수 호이스팅으로 인해(호이스팅: 아래 설명 참고) 변수 선언문부터 읽히고, 
그 다음에 콘솔로그가 읽힌다.(아래처럼) 
var result ;
console.log(result);
근데 이 상태는 아직 "result"값이 할당되어있지 않은 상태라서 undefined 값이 도출된다.
그 후에 result = 10 + 20 ; 이란 "문"이 읽히는데, 이 "문"에는 어떠한 행위를 해달라는
명령어가 없기때문에 실행되는 것은 아무것도 없다. 그래서 결국 결과값으로 undefined값이 
도출되는 것이다.
제대로된 결과값을 도출하려면 아래처럼 코딩하면 된다.

console.log(result);
var result = 10 + 20 ;
console.log(result);
*"값의 재할당"과 관련있는 코드이니 아래 "값의 재할당"부분도 참고하자.
```



## 변수 호이스팅

- 런타임(run time) : 코드들이 위에서 아래로 순차적으로 읽히는 과정

- 변수 호이스팅 : 다른 언어들과 다르게, JS엔진은 런타임 이전에 <u>**변수 선언문**</u>이 다른 코드들보다 제일 먼저 평가되어 <u>**제일 먼저 실행**</u>되는 것  
- 변수 호이스팅 발생 이유 : 런타임 이전에 변수 선언을 처리, 초기화를 하기 때문이다. 

##### 예시1

![캡쳐54](https://user-images.githubusercontent.com/62126380/80074138-b14c5080-8583-11ea-9c64-82ce3b4d5b45.PNG) 

```
결과:

★ console.log(score) ;
☆ var result ;
-----------------------------
1. ☆ 코드 평가 -> 2. ★ 코드 실행 -> 레퍼런스 에러는 아니지만 undefinde값이 할당.
```

1. 코드 평가 : JS엔진은 다른언어와 다른점이 있는데, 코드를 순차적으로 읽어내려가서 실행을 하기 이전에 <br>실행을 하가 위해  코드평가가 먼저 이루어진다.
2. 코드 실행 : JS엔진은 코드 평가 과정에서 변수선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 코드에서 먼저 찾아서 변수 선언문을 제일 먼저 실행한다.

위 코드처럼 변수 참조가 먼저 되고 변수 선언이 그 다음으로 되어도 JS엔진은 실상 위 예시로는 ☆->★ 순서로     코드를 해석한다. 
위 코드의 현재 상태는 변수 선언 다음에 변수 참조가 이루어진 상태인데, 현 상태는 아직 변수값에 값이 할당되어
있지 않은 상태라서 undefined 값이 할당되어 지는 것이다. 



## 값의 할당

&#128205; &#128205; 제일 먼저 변수 호이스팅을 유의하자.

##### 예시1

![image-20200423190742998](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200423190742998.png) 

```
① console.log(score);
② var score = 80 ;
③ console.log(score);
---------------------------
-> 결과 : 80 값을 도출
```

① : 변수 score의 값을 출력해줘! -> 아직 변수 선언도 안하고, 값을 할당하지도 않았기 때문에 **undefined값 도출**

①,② : JS엔진이 ② 가 1줄로 보이지만 두줄로 해석한 후, 변수 호이스팅이 실행된다.

실상, 아래 이미지처럼 실행되어 **undefined 값 도출**

![캡쳐55](https://user-images.githubusercontent.com/62126380/80091542-35aacd80-859c-11ea-96be-e34e0017510a.PNG) 

①,②,③ : undefined 값이 도출된 상황이지만 이미 변수 선언 완료 + 값의 할당도 완료되어서 <br>				**정상적인 80이란 값이 도출**

---

##  값의 재할당

- 기존에 할당이 되어져있는 변수에 다른 값을 다시 할당하는 행위
- 가급적이면, 왠만해서는 재할당을 안하는게 좋다. 
- 재할당을 할수 없는(재할당이 금지된) 변수는 변수라고 하지 않고 상수(const)라고 한다.
  - 재할당이 금지되기때문에 처음값을 바꿀 방법은 객체타입의 경우에만 있다.

##### 예시1

![캡쳐57](https://user-images.githubusercontent.com/62126380/80106335-b1b10f80-85b4-11ea-961b-3724ed0a2991.PNG) 

![캡쳐58](https://user-images.githubusercontent.com/62126380/80107358-ef626800-85b5-11ea-8688-d809c7d08c48.PNG) 

```
① 변수 선언으로 인해 변수 "score"가 가리키고 있던 undefined 값은
② "80"이란 값을 할당함으로 인해 폐지(해방)되어 메모리가 해제 되고
③ "90"이란 값을 재할당함으로 인해 "80"이란 값이 저장되었던것도 폐지(해방)가 되어 메모리가 해제 된다.
```

==> 폐지(해방)되어 메모리가 해제가 된 값들은 가비지 컬렉터(garbage collector)가 메모리들을 훑다가<br>"어~? 이 메모리셀의 값은 더이상 필요없네?? 어떠한 변수도 이 메모리셀의 값을 가리키고 있지 않네??" <br> "그럼 이제 이 메모리(ex: undefined) 공간 써도 되~ 얘도(ex:80) 써도 되! 하지만 얘는(ex: "90") 쓰면 안되~!!"라고 재사용해도 되는 쓰레기값에 대해 판단한다.   

가비지 컬렉터가 메모리셀 공간영역의 재사용에 대해 판단을 하고, 재사용이 가능하다면 그 셀에는 다른 값들로  채워질수 있다. 

하지만 여기서 유의해야 할 점은 위의 이미지대로, 값의 할당과 값의 재할당이 이뤄지면 값으로 채워졌던<br> 메모리셀 의 값들이 지워지고 거기에 **<u>새로운 값들이 할당되는것이 아니라, 새로운 다른 메모리셀에 값이 엎어져서 채워지는 것이다.</u>** 

---

# 표현식

## 값

- 변수에 저장할수 있는것 

- 모든 값은 데이터 타입을 갖고있다. 

- 메모리에 저장되어지는 것( 메모리에 저장되어지기때문에 그 값은 결국 모두 2진수이다.)

- 표현식이 이게 뭔지 해석하는 ''코드 평가 단계'를 거쳐서 생성된 값 또는 결과물

  ``` 
  ex)
  var x = 10 + 20 ;
  x = 10 + 20 ;
  var y = x;
  ------------------
  10 ==> 메모리에 저장되어지는 값이기 때문에 값
  10 + 20 ; ==> 표현식이면서 값
  x  ==> 표현식이면서, 결국엔 "30" 이란 값으로 평가되어져서 결과물을 생성하기때문에 값
  ------------------------------
  * "10 + 20 ;" : 결국에는 코드 평가 단계를 거쳐서 "30" 이란 값으로 평가되어진다. -> 그러므로 이는 표현식이면서 값이 된다. (10 + 20 ; 와 30 은 동치)
  ```

- 문을 보면 컴터가 해석을 할건데, 표현식이면 평가를 하는거고, 실행문이면 실행을 하는것이다. 







result = 10 + 20 ;

메모리 공간안에 값이 저장되잖아. 10 + 20 이 저장될까, 30이 저장될까? 

변수라는 메모리 공간에 10 + 20 이라는 식은 저장할수 없다.

30이 저장되어지는 행위가 10 + 20 보다 먼저 행해져야 한다.

= 의 의미는 확보만 해놓은 상황.  

메모리 공간안에 값을 집어넣는게 할당이라고 한다. 

10 + 20 이 평가(계산)되어진 결과가 메모리 공간안에 들어가지게 된다. 

30 이란 숫자가 들어가지게 된다. 



var result : 변수 선언이라고 하는데. 메모리 공간을 확보한다 + 초기화를 한다. 

result = 10 + 20 



var result = 10 + 20 ;

-> 이거 2줄로 보여야 함. 

var result ;

result = 10 + 20 

-> 이렇게~

메모리공간에 빈 사용가능한 공간을 OS로부터 할당받아서 그 영역을 확보하는 행위부터 해야 할거 아냐~? 몇 바이트 확보해야 하지? 이게 애매한거야. 그래서 브랜드씨는 어떤값이 올지 모른다. 그래서 무조건 언디파인드라는 값이 들어갈만큼만 확보하자. 그리고 암묵적으로 언디파인드를 할당해주자. 





---

## 표현식과 문

개념을 이해한다는 것은 바로 용어를 정확히 이해하고 설명할수 있는것이다. 

값이 될수 있는것은 전부 표현식이다. 

### 표현식

값으로 평가될수 없는 것은 표현식이 아니다 

">" x

<- 1

기본적으로 위에 쓴것을 평가한다. 

; 으로 끝나는 것들을 문이라고 한다. 

">" x === 1

<- true

">" var x = 1 === undefined

<- undefind

- 값이 위치하는 곳에 표현식인 문이.....



if (false) {

  console.log('Hi');

}

// 만약에 () 안의 값이 참이면 밑에 코드를 실행하겟다. 거짓이면 실행 안하겟다. 

// 근데 위에는 참이니까 실행이 될것이다. 

var x : 표현식이 아닌 문이다. 

 

var x 

0 은 false 다. 

표현식은 값이 올수 잇는 곳에는 쓸수 잇다. 

표현식인지 아닌지 알수 잇으려면,  변수에 할당해보고,  에러가 안나면 오른쪽에 온게 표현식의 문이다. 





### 리터럴

- 기호다. 

- 예를 들어 코드에 10 라고 쓰면 십진수 10 이다. 라고 자스 엔진하고 개발자가 약속을 한거다. 

- 10을 코드에 썼을때, main.js 라는 파일을 만들고 거기에 쓴 상태에서 세입 눌르면 그냥 그건 순수한 텍스트 자스파일일뿐이다. 그 파일을 자스엔진이 메모리를 읽어들여서 해석를 하면,  10을 십진수 10이라고 해석한다. 우리는 여기에 너무 익숙해져서 해석할 필요없지만 프로그램은 기호로 해석할건데, 십진수 10으로 해석해서, 거기에 맞는 2진수를 만들어서 메모리에 저장할거다.  

- 기호를 리터럴이라고 한다. 

  - 1(아라비아 숫자), true, 'a', [ ] . { }

    [ ] : 배열 리터럴 

    { } : 객체 리터럴(객체를 만들어줄게. 할때 쓰이는 리터럴이다)

    funtion( ){ } : 함수라는 리터럴

    /a/gr : 정규 표현식이라는 리터럴

  리터럴: 사람이 이해할수 있는 문자.  또는 약속된 기호를 사용해서 값을 생성하는 표기 방법이다. 

  이렇게 표기하면 값을 만들어달라고 자스엔진한테 부탁하는 것이다. 

- 값을 만들어내는 표기방법 

- 리터럴은 표현식이다. 

- 알아차리는것 = 파싱이라는 뜻  = 데이터 타입을 변환하는 것. 

- 여러개의 리터럴과 연산자 

- var x = 1 ;

  x 

  x : 1이란 값으로 평가되기 때문에 이것도 표현식이다(식별자 표현식)

  1 +2 : 연산자 표현식

![image-20200422164805338](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200422164805338.png)

리터럴은 표기법이다. 

리터럴도 값으로 평가할수 있기 때문에 표현식이다. 

100   을 실행(평가)하면 100을 표현한다. // 정수 리터럴

자스세계에서는 숫자가 두가지다. 소수가 없는 정수, 소수가 잇는것을 부동 소수점형 숫자 두가지가 잇다. 

자스는 모든 소수점을 부동 소수점으로 한다. 

10. 5 // 부동 소수점 리터럴

리터럴은 표기법만 다를뿐 값을 만들어내는 건 다양하다. 



문자열 리터럴 :

- 문자들의 열이다. 
- 1개만 잇는건 문자라고 하는데 여러개가 있을때는 문자열이라고 한다. 
- 원시값으로 제공한다. 
- 문자열은 반드시 "" 가 붙어야 한다. 

불리언 리터럴 (2개뿐) :

true 

false 

객체 리터럴 

배열 리터럴

함수 리터럴





---

뒤에 세미콜론을 붙혀서 문의 종류를 알린다. 

프로그램이라는건 문들의 집합체다. (한줄한줄씩 실행된다.  그 한줄한줄이 문이다. )

문들을 순서에 맞게 나열한다는 것이다. 



10 : 문이자 표현식

'hello' : 표현식

 sum : 값으로 평가되기때문에 표현식인 문

arr[1] 두번째 요소를 참조한다는 뜻 : 이것도 표현식인 문이다. 



----> 값으로 평가되는 건 다 표현식이다. 



var x = sum = 10 ;

--> 이거 3줄이다. x 가 언디파인드 할당된 상태이고 x 에다가 sum = 10 이 할당되엇음. 

순서는 sum = 10 ; 이 먼저 실행되는것이다. 그걸 평가한것이 x 가 되는것이다. 

변수에다가 두개의 값을 할당한것인데 ----> 이거 쓰지말자. 



 (   ) ! == (  )    : " 같지않다"  연산이 되어지는 연산이 두개가 필요하다. 같지 않다면, 트루로 평가, 같으면 false로 평가됨.    -> 이것도 표현식인 문이다. 









### 문

프로그램을 구성하는 기본단위이자 최소 실행 단위이다. 

![image-20200422174402786](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200422174402786.png)

0 개의 이상의 토큰들로 이루어져 있다. 

아무내용 없는 문도 문이다. 

= 연산자, 할당 연산자

"+" 산수 연산자

문을 명령문이라고도 한다. 

1. 선언문

   변수가 선언되고 

2. 할당문

   

3. 함수 선언문

4. 조건문

5. 반복문



var x = 10 ;   : 표현식이 아닌 문

x = 10 ; : 표현식인 문



값이 없는 평가는 없다. 

---



10 이란것을 2진수로 바꿔서 컴터가 기억할것이다. 

그럴려면 어디에 기억하면 되지? 방이 하나가 아니고 메모리는 1바이트 단위로 데이터를 기억한다. 

데이터의 최소 기억단위는 1바이트이다. 데이터로서 의미를 갖기 위해서는 최소 8비트가 필요하다. 

 

숫자마다 기억할수 있는 용량을 달리 가져갈까? 그렇지 않고, 숫자라는 것은 반드시 몇바이트라고 정해져있다.  

1도 8바이트, 10억도 8바이트를 필요한다. 

--> 데이터 타입 



변수하고 데이터 타입, 스코프 는 세트다. 



"리터럴 3  : 코드 평가단계 관련해서 우성님이 질문한거 물어보기"



예습 : 6번 7번 

---







var score = 100 ;

=> 쓰레기값을 안주려고 100 이란 값을 할당 

