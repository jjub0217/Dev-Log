## 변수문법

- 컴퓨터는 코드를 위에서 아래로 순차적으로 실행한다.

- 명령은 value(값), operator(연산자), expresstion(표현식), comment(주석)으로 구성되며 세미콜론(;)으로 '문'을 끝마친다. 

##### 예시1

![캡쳐51](https://user-images.githubusercontent.com/62126380/80062371-8acfea80-856e-11ea-9ff9-9a1e54934f68.png) 

``` 
var result ; 

변수 선언만 하고, 값을 할당하지 않은 상태 라서 -> undefined 값이 도출
----------------------------------------------------------------
var result ;
result = 10 + 20 ;

변수 선언도 하고, 변수에 값도 할당한 상태 -> 정상 작동
```

##### 예시2

![캡쳐52](https://user-images.githubusercontent.com/62126380/80063263-80165500-8570-11ea-88b6-892dc699f08a.png) 

```
result = 10 + 20 ;

변수 선언을 안한 상태에 값을 할당했는데 왜 에러가 안나오죠?  
-> 친절한 JS씨라서 "너 선언하는거 까먹었지...? 어휴.. 내가 알아서 출력해줄게" 하고 자동으로 결과값을 도출해줌.  -> 정상 작동
------------------------------------------------------------------------------
①result = 10 + 20 ;
 var ②result ;

①result 랑 ②result 은 다른 result 다. 
왜냐? 친절한 JS씨가 "너 선언하는거 까먹었지...? 어휴.. 내가 알아서 출력해줄게" 하고 자동으로 ①result 값을 벌써 출력을 이미 다 해줬는데 또 ②result 를 선언한다. 이건 중복이다. 그래서 ①result 값을 지워버리고 다른 ②result 값이 새로 생겨버린 상태라서
-> undefined 값이 도출 
```



## 레퍼런스 에러(참조 에러)

<p style="color:red";> 들어가기에 앞서...</p>

1. 변수 참조( "cosole.log(~)" ): 변수의 값을 가지고 와서 출력해달라는 명령

   ```
   ex)
   var result ;
   console.log(result);
   ----------------------
   선언한 변수 "result" 값을 출력해줘!!!
   -> 결과 : 할당한 값이 없으므로 undefined 값 도출
   ```

---

레퍼런스 에러 : 선언된적이 없는 변수를 참조하려고 할때 발생하는 에러

##### 예시1 (레퍼런스 에러 발생)

```
var result = 10 + 20 ;
console.log(score)
------------------------
"result" 라는 변수를 선언했는데, 참조한 변수는 "score" 이란 변수라서 레퍼런스 에러 발생
```

![캡쳐53](https://user-images.githubusercontent.com/62126380/80066296-a0491280-8576-11ea-8a51-caebc85666ea.PNG) 

##### 예시2(레퍼런스 에러 X)

``` 
1. var result = 10 + 20 ;
   console.log(result) ;
-----------------------------
"result" 라는 변수를 선언 + 변수에 값을 할당 + 참조한 변수 "result"로, 선언한 변수를 참조
-> 에러 없이 값이 3으로 정상 도출

2. console.log(result) ;
   var result = 10 + 20 ;
-----------------------------
-> 결과 : undefined값 도출(레퍼런스 에러X)

위 코드는 변수 호이스팅으로 인해(호이스팅: 아래 설명 참고) 변수 선언문부터 읽히고, 
그 다음에 콘솔로그가 읽힌다.(아래처럼) 
var result ;
console.log(result);
근데 이 상태는 아직 "result"값이 할당되어있지 않은 상태라서 undefined 값이 도출된다.
그 후에 result = 10 + 20 ; 이란 "문"이 읽히는데, 이 "문"에는 어떠한 행위를 해달라는
명령어가 없기때문에 실행되는 것은 아무것도 없다. 그래서 결국 결과값으로 undefined값이 
도출되는 것이다.
제대로된 결과값을 도출하려면 아래처럼 코딩하면 된다.

console.log(result);
var result = 10 + 20 ;
console.log(result);
*"값의 재할당"과 관련있는 코드이니 아래 "값의 재할당"부분도 참고하자.
```



## 변수 호이스팅

- 런타임(run time) : 코드들이 위에서 아래로 순차적으로 읽히는 과정

- 변수 호이스팅 : 다른 언어들과 다르게, JS엔진은 런타임 이전에 <u>**변수 선언문**</u>이 다른 코드들보다 제일 먼저 평가되어 <u>**제일 먼저 실행**</u>되는 것  

##### 예시1

![캡쳐54](https://user-images.githubusercontent.com/62126380/80074138-b14c5080-8583-11ea-9c64-82ce3b4d5b45.PNG) 

```
결과:

★ console.log(score) ;
☆ var result ;
-----------------------------
1. ☆ 코드 평가 -> 2. ★ 코드 실행 -> 레퍼런스 에러는 아니지만 undefinde값이 할당.
```

1. 코드 평가 : JS엔진은 다른언어와 다른점이 있는데, 코드를 순차적으로 읽어내려가서 실행을 하기 이전에 <br>실행을 하가 위해  코드평가가 먼저 이루어진다.
2. 코드 실행 : JS엔진은 코드 평가 과정에서 변수선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 코드에서 먼저 찾아서 변수 선언문을 제일 먼저 실행한다.

위 코드처럼 변수 참조가 먼저 되고 변수 선언이 그 다음으로 되어도 JS엔진은 실상 위 예시로는 ☆->★ 순서로     코드를 해석한다. 
위 코드의 현재 상태는 변수 선언 다음에 변수 참조가 이루어진 상태인데, 현 상태는 아직 변수값에 값이 할당되어
있지 않은 상태라서 undefined 값이 할당되어 지는 것이다. 



## 값의 할당

&#128205; &#128205; 제일 먼저 변수 호이스팅을 유의하자.

##### 예시1

![image-20200423190742998](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200423190742998.png) 

```
① console.log(score);
② var score = 80 ;
③ console.log(score);
---------------------------
-> 결과 : 80 값을 도출
```

① : 변수 score의 값을 출력해줘! -> 아직 변수 선언도 안하고, 값을 할당하지도 않았기 때문에 **undefined값 도출**

①,② : JS엔진이 ② 가 1줄로 보이지만 두줄로 해석한 후, 변수 호이스팅이 실행된다.

실상, 아래 이미지처럼 실행되어 **undefined 값 도출**

![캡쳐55](https://user-images.githubusercontent.com/62126380/80091542-35aacd80-859c-11ea-96be-e34e0017510a.PNG) 

①,②,③ : undefined 값이 도출된 상황이지만 이미 변수 선언 완료 + 값의 할당도 완료되어서 <br>				**정상적인 80이란 값이 도출**

---

#### 값의 재할당

가비지 컬렉터가 훑다가 어? 얘 더이상 필요없네? 라고 판단하는데, 그 판단기준은 어떠한 변수이름도 이 값을 가리키고 있지 않을때. 가비지가 쓱 훑다가 어? 얘는  안 가리키고 있네? 어떠한 변수도 얘를 가리키고 있지 않는다는 건 개발자가 재사용하지 않겠다는 의사표현을 한것이다.  

그러면 가비지 컬렉터가 어, 이제 다른 애들이 써도 되~ 한다. 어? 이것도 이제 다른 애들이 써도 되, 얘도 

아깐 보고 있엇지만 지금 안보고 잇으니까 써도 되. 하지만 30은 쓰면 안되. 

이걸 가비지 컬렉터가 지우는게 아니라 그냥 읽는건데 다른 애가 변수선언을 하면 해방이 되었으니까 걔는 데이터 사이즈가 크다면 새로운 값을 할당 치게 된다. 다시 엎어써버리게 되는거라서 지울 필요가 없다.  

---> 할당의 매커니즘 



무조건 언디파인드가 들어가고 할당이 들어오면 할당값이 들어가는것이다. (번거롭게 두번 일하는 건데.. 실상은 재할당이다. )



재할당에 대한 느낌이 어떠냐? 재할당은 왠만해선 안해야 하는것이다. 

가급적이면 재할당을 안하는게 좋다. 왜일까? 자스의 약점중에 하나가 타입이 없는것이다. 그 얘기 무엇이냐면 문자, 숫자 등 교차해서 할당할수 잇다. 그러면 나중에 문제가 생긴다

var num =1 ;

num = 'xyz'

num = ture ;

나중에 num + 10 식으로 쓸건데, 그때 의도치 않게 num = 'xyz' 가 들어가면 수치계산이 안되고 문자화된다. 

-> 변수가 많아지면 오류가 많아진다. 바로 이런 타입의 문제, 오류가 많아진다. 

그래서 데이터 타입을 지키는게 중요하다. 



const : 상수라는 컨스터. 재할당이 금지된다. 

값은 데이터 타입을 반드시 갖고 잇는데 크게 두가지로 나뉜다. 

두가지로 나누는 이유는 두가지가 성격이 무지하게 다르기 때문에 나누었다. 

1. 원시값 (프리미티브 타입) : 변경 불가능(immutable)

   숫자는 원시값이다. 

   예시> 

   var x = 1 ;

   x = 10 ;

   1  이 저장되었다. 10이 저장되었다. 

   undefind 라는게 원시값으로 한번 자리를 잡앗는데 얘는 노터치이다. 한번 자리 잡은 원시값은 주소를 바꾸지 않는한 변경할수 있는 방법이 업다 . 이런것을 원시값이라고 한다. 

   재할당을 통해서만 값을 교체할수 있다(변경하는게 아니라 교체)

   undefind 값을 바꿀수 없다. 

   새로운 공간을 만들어서 포인팅을 바꾼다.

   가비지 콜렉터가 써도되는지 판단하는게 시간이 걸린다.  

2. 객체(오브젝트 타입, 참조타입) : 변경가능(mutable)

   재할당을 하지않아도 값이 바뀔수 잇다는 뜻이다. 

   재할당을 하면 메모리주소가 반드시 바뀐다. 

   재할당없이도 값을 바꿀수 있다. 그렇게 때문에 값의 변경을 추적하기가 어렵다. 

   자신이 바꼇는지 안바꼈는지가 불명확함

==> 성능의 차이는 없다.

 









# 표현식(추가하기)





result = 10 + 20 ;

메모리 공간안에 값이 저장되잖아. 10 + 20 이 저장될까, 30이 저장될까? 

변수라는 메모리 공간에 10 + 20 이라는 식은 저장할수 없다.

30이 저장되어지는 행위가 10 + 20 보다 먼저 행해져야 한다.

= 의 의미는 확보만 해놓은 상황.  

메모리 공간안에 값을 집어넣는게 할당이라고 한다. 

10 + 20 이 평가(계산)되어진 결과가 메모리 공간안에 들어가지게 된다. 

30 이란 숫자가 들어가지게 된다. 



var result : 변수 선언이라고 하는데. 메모리 공간을 확보한다 + 초기화를 한다. 

result = 10 + 20 



var result = 10 + 20 ;

-> 이거 2줄로 보여야 함. 

var result ;

result = 10 + 20 

-> 이렇게~

메모리공간에 빈 사용가능한 공간을 OS로부터 할당받아서 그 영역을 확보하는 행위부터 해야 할거 아냐~? 몇 바이트 확보해야 하지? 이게 애매한거야. 그래서 브랜드씨는 어떤값이 올지 모른다. 그래서 무조건 언디파인드라는 값이 들어갈만큼만 확보하자. 그리고 암묵적으로 언디파인드를 할당해주자. 





---

#### 식별자 네이밍 규칙  (이거 복습내용에 추가하기)

식별자들은 이름을 지을때 규칙이 있다. 

식별자는 특수문자를 제외한 문자, 숫자, _ , 달러 기호를 포함할수 있다

단 식별자는 특수문자를 제외한 문자, _ , 달러 기호로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다. 

예약어는 식별자로 사용할수 없다(대부분의 키워드는 예약어이다. )

쉼표로 구분해서 하나의 문에서 여러개 한번에 선언할수 있지만 비추다. 

처음에 숫자가 오면 안된다.

영어 외의 언어로 써도 되지만 비추다. 

---

신택스 : 문법 이란 뜻이다. 

신택스에러 : 문법에러. 

var first-name :  -   는 데쉬기호가 아니라 마이너스 기호로 읽히기 때문에 신택스 에러다.

두개의 단어를 합한걸 식별자 이름으로 할때는 카멜케이스로 해야 한다. 

가독성이 좋은 코드를 만드는게 최고다. 

var x = 3 ; // x  가 의미하는 바가 뭔지 모른다   NNNNNNNOOOOOO

var score = 100 ; // score가 점수를 의미하는걸 알수 있다.   YYYYYYYEEEEESSSSS

성능보다 가독성 좋은 코드가 더 좋다.  

성능을 고치려면 코드를 고치기보다 씨피유와 메모리를 교체하는게 좋다. 근데 이렇게도 해결이 안된다면? 코드에 손대는건 최후의 수단. 그것도 안되면 백엔드에서 손대야 함. 

성능은 알고리즘 풀때만 중요하다. 실무에서는 가독성이 중요하다. 

가독성을 가장 높이는 건 이름을 잘 짓는것이다. 

JS  에서 왠만하면 카멜케이스로 쓰자. (변수 쓸때)

생성자 함수, 클래스 : 파스칼 케이스 쓰자

변수이름 앞에 타입을 쓸때 헝가리언케이스가 쓰이기도 한다. 





---





#### 값의 교환

- 알고리즘이다.

- 변수를 하나 만들어서 잠깐이라도 기억해놔야 한다. 

---

---

## 표현식과 문

개념을 이해한다는 것은 바로 용어를 정확히 이해하고 설명할수 있는것이다. 

값이 될수 있는것은 전부 표현식이다. 

### 값(value)

- 가치
- 변수에 저장할수 있는것이다. 그런데,  10 + 20 값이 되지만 자스 코드로 평가(예를 들어서 시험지가있고, 시험을 풀었음. 시험지는 종이일뿐인데 빨간펜으로 평가를 했어.  그러면 점수가 나와. 그럼 시험지는 점수가 됨)해서 값이 된다. 30 이란 값은 메모리 공간에 들어감. 
  - 10 + 20 은 결국 값으로 평가된다. 
  - 10 + 20 은 30 이 된다. (평가를 거쳐서) 10 + 20 과 30 은 동치이기 때문에 10 + 20 은 값이 될수 잇다. 
  - 값으로 평가 될수 있는것 : 표현식  
  - 값은 표현식의 결과물이다. 
  - 메로리에 들어가는 것이 값이다. (결국 다 2진수. )
- 표현식이 평가되어 생성된 결과물 (ex: "30")
- 값을 찾으려고 평가하는 것이다. 
- 평가의 결과는 결국 값으로 나타내는것
- 평가는 이게 뭔지 읽어주는 것. 
- 문을 보면 컴터가 해석하는데 표현식이면 평가를 하는거고, 실행문이면 실행을 하는것이다. 

vat x = 10 ;

10 : 값이면서...  표현식 10이란 값으로 평가된다. 

x = 10 +20 ;

10 + 20 : 값이면서 표현식임. 30이란 값으로 평가된다. 

var y = x ;

x 도 값이다. 30이란 값으로 평가된다.



var a = 'a를 나타내는 아스키코드 값'

var b = 42(b의 아스키코드 값)

a를 끌어올때 문자로 분석할건지, 코드로 분석할건지 데이터 타입으로....

숫자는 무조건 기본으로 십진수로 해석한다. 



변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 



### 리터럴

- 기호다. 

- 기호인데, 자스엔진하고 개발자하고 서로 알고 있는 약속을 한거다. 

- 예를 들어 코드에 10 라고 쓰면 십진수 10 이다 자스 엔진하고 개발자가 약속을 한거다. 

- 10을 코드에 썼을때 쓴 상태에서 세입 눌르면 그냥 그건 순수한 텍스트 자스파일일뿐이다. 그 파일을 자스엔진이 읽어들여서 해석할때는 10을 십진수 10이라고 해석한다. 거기에 맞는 2진수를 만들어서 메모리에 저장할거다.  

- 기호를 리터럴이라고 한다. 

  - 1(아라비아 숫자), true, 'a', [ ] . { }

    [ ] : 배열 리터럴 

    { } : 객체 리터럴(객체를 만들어줄게. 할때 쓰이는 리터럴이다)

    funtion( ){ } : 함수라는 리터럴

    /a/gr : 정규 표현식이라는 리터럴

  리터럴: 사람이 이해할수 있는 문자.  또는 약속된 기호를 사용해서 값을 생성하는 표기 방법이다. 

  이렇게 표기하면 값을 만들어달라고 자스엔진한테 부탁하는 것이다. 

- 값을 만들어내는 표기방법 

- 리터럴은 표현식이다. 

- 알아차리는것 = 파싱이라는 뜻  = 데이터 타입을 변환하는 것. 

- 여러개의 리터럴과 연산자 

- var x = 1 ;

  x 

  x : 1이란 값으로 평가되기 때문에 이것도 표현식이다(식별자 표현식)

  1 +2 : 연산자 표현식

![image-20200422164805338](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200422164805338.png)

리터럴은 표기법이다. 

리터럴도 값으로 평가할수 있기 때문에 표현식이다. 

100   을 실행(평가)하면 100을 표현한다. // 정수 리터럴

자스세계에서는 숫자가 두가지다. 소수가 없는 정수, 소수가 잇는것을 부동 소수점형 숫자 두가지가 잇다. 

자스는 모든 소수점을 부동 소수점으로 한다. 

10. 5 // 부동 소수점 리터럴

리터럴은 표기법만 다를뿐 값을 만들어내는 건 다양하다. 



문자열 리터럴 :

- 문자들의 열이다. 
- 1개만 잇는건 문자라고 하는데 여러개가 있을때는 문자열이라고 한다. 
- 원시값으로 제공한다. 
- 문자열은 반드시 "" 가 붙어야 한다. 

불리언 리터럴 (2개뿐) :

true 

false 

객체 리터럴 

배열 리터럴

함수 리터럴



---

### 표현식

값으로 평가될수 없는 것은 표현식이 아니다 

">" x

<- 1

기본적으로 위에 쓴것을 평가한다. 

; 으로 끝나는 것들을 문이라고 한다. 

">" x === 1

<- true

">" var x = 1 === undefined

<- undefind

- 값이 위치하는 곳에 표현식인 문이.....



if (false) {

  console.log('Hi');

}

// 만약에 () 안의 값이 참이면 밑에 코드를 실행하겟다. 거짓이면 실행 안하겟다. 

// 근데 위에는 참이니까 실행이 될것이다. 

var x : 표현식이 아닌 문이다. 

 

var x 

0 은 false 다. 

표현식은 값이 올수 잇는 곳에는 쓸수 잇다. 

표현식인지 아닌지 알수 잇으려면,  변수에 할당해보고,  에러가 안나면 오른쪽에 온게 표현식의 문이다. 



---

뒤에 세미콜론을 붙혀서 문의 종류를 알린다. 

프로그램이라는건 문들의 집합체다. (한줄한줄씩 실행된다.  그 한줄한줄이 문이다. )

문들을 순서에 맞게 나열한다는 것이다. 



10 : 문이자 표현식

'hello' : 표현식

 sum : 값으로 평가되기때문에 표현식인 문

arr[1] 두번째 요소를 참조한다는 뜻 : 이것도 표현식인 문이다. 



----> 값으로 평가되는 건 다 표현식이다. 



var x = sum = 10 ;

--> 이거 3줄이다. x 가 언디파인드 할당된 상태이고 x 에다가 sum = 10 이 할당되엇음. 

순서는 sum = 10 ; 이 먼저 실행되는것이다. 그걸 평가한것이 x 가 되는것이다. 

변수에다가 두개의 값을 할당한것인데 ----> 이거 쓰지말자. 



 (   ) ! == (  )    : " 같지않다"  연산이 되어지는 연산이 두개가 필요하다. 같지 않다면, 트루로 평가, 같으면 false로 평가됨.    -> 이것도 표현식인 문이다. 









### 문

프로그램을 구성하는 기본단위이자 최소 실행 단위이다. 

![image-20200422174402786](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200422174402786.png)

0 개의 이상의 토큰들로 이루어져 있다. 

아무내용 없는 문도 문이다. 

= 연산자, 할당 연산자

"+" 산수 연산자

문을 명령문이라고도 한다. 

1. 선언문

   변수가 선언되고 

2. 할당문

   

3. 함수 선언문

4. 조건문

5. 반복문



var x = 10 ;   : 표현식이 아닌 문

x = 10 ; : 표현식인 문



값이 없는 평가는 없다. 

### 데이터 타입

10 이란것을 2진수로 바꿔서 컴터가 기억할것이다. 

그럴려면 어디에 기억하면 되지? 방이 하나가 아니고 메모리는 1바이트 단위로 데이터를 기억한다. 

데이터의 최소 기억단위는 1바이트이다. 데이터로서 의미를 갖기 위해서는 최소 8비트가 필요하다. 

 

숫자마다 기억할수 있는 용량을 달리 가져갈까? 그렇지 않고, 숫자라는 것은 반드시 몇바이트라고 정해져있다.  

1도 8바이트, 10억도 8바이트를 필요한다. 

--> 데이터 타입 



변수하고 데이터 타입, 스코프 는 세트다. 



"리터럴 3  : 코드 평가단계 관련해서 우성님이 질문한거 물어보기"



예습 : 6번 7번 

---







var score = 100 ;

=> 쓰레기값을 안주려고 100 이란 값을 할당 

