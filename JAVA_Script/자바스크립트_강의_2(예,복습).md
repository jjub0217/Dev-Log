# 변수

<p style="color:red";> 들어가기에 앞서...</p>

1. <u>**bit는 지수 즉, 제곱을 뜻하며 2진수가 표현할수 있는 최소의 단위다.**</u>

``` ex
ex)
1bit : 2의 1승. 2개의 경우의 수를 나타낼수 있다 (0 또는 1)
2bit : 2의 2승. 4개의 경우의 수를 나타낼수 있다 (00, 01, 10, 11)
8bit : 2의 8승. 256개의 경우의 수를 나타낼수 있다. 
```

2. <u>**변수는 에러발생의 근본 원인이다.**</u>

   변수가 많을수록 기억해야 할 사항이 많아지는것이므로, 오류 발생 확률이 커진다. 

   ∴ 변수는 적을수록 좋다. 

---

## 변수란 무엇인가?

- <u>**하나의 값을 저장하기 위해 확보한 메모리 공간 자체**</u> <br>변수를 선언하면 메모리 공간의 영역을 확보하면 다른 애가 그 영역을 못쓴다. 

"변수는 값을 저장하기 위한 `상자`다." -> 바보같은 설명임....<br>(근데 왜= 이런식으로 설명할까? 그렇게 설명해줘야 이해하기 쉽다고 함)

```  
상자 = 메모리 (개발자들에게 메모리는 상당히 중요한 요소임)
```

##### 예시

``` javascript
<script> 
10 + 20 = 30
</script>    <- 자바스크립트 코딩하게 된다면?
```

![캡처43](https://user-images.githubusercontent.com/62126380/79992090-02116a00-84ee-11ea-9816-05e63e0692a2.PNG) 

 

- 식별자 : 하나의 값을 저장하기 위해 확보한 메모리 공간(노란색 칸) 또는 메모리 공간을 식별할수 있는 이름을 가리킨다. 

- 메모리 주소 : 0 ~ 메모리 크기만큼 정수로 표현

- 연산은 CPU가 함. 

- 값이 저장될 메모리셀의 주소는 코드가 실행이 될때, 메모리의 상황에 따라 OS가 임의로 결정한다. 

  따라서 똑같은 컴퓨터로 똑같은 코드를 실행해도, 코드가 실행될때마다 해당 메모리셀의 주소는 매번 변경이 된다.  



"30" 이란 값을 한번만 쓴다고 하면 이 과정에서 끝내도 되지만, 재사용을 하려면 해당 "30"이라고 저장한 값을 다시 읽어들여서 사용해야 한다.  

--> 이때 재 사용하기 위해 **"변수"** 라는 것을 이용한다.

``` 
변수

"30" 이란 값을 재사용하려면 "30"이란 값을 도출해낸 메모리셀의 주소를 알아야 한다.
하지만 메모리셀에 저장되었지만, 연산하여 만들어낸 값은 재사용을 할수 없기 때문에 저장을 시켜야 한다.
10 + 20 의 결과값이 있는 곳을 기억해라 고 컴퓨터에게 명령을 해야하는데 
이때 사용되는것이 "변수"다.
```



## 변수를 왜 사용해야 할까?

- **<u>변수를 사용한다는 것은 메모리를 쓴다는 것이다.</u>** 

어떠한 변수가 어떠한 메모리의 공간영역을 예약하고 확보하여 사용을 한다고 하면, 그 영역에는 다른 변수가 침범을 하지 못한다. 

그렇게 사용하지 못하는 영역이 많아질수록 렉이 걸리는 것이다. 

그래서 변수는 영역을 점유하고 있으면 안되고, 메모리의 공간영역을 확보했다면 그 영역을 빨리 사용하고 빨리 해방을 시켜야 한다. ( 변수는 생명주기가 짧아야 한다.)

- <u>**인간은 언제나 실수를 한다. 그래서 변수를 쓴다.**</u>

메모리셀에 값이 저장된 주소는 매번 바뀌기 때문에 알수가 없다. 

저장된 값을 재사용하려면 값이 저장된 주소에 직접 접근을 해서 값을 꺼내오면 될것 같은데, 인간은 언제나 실수를 하지.... *<- 엉뚱한 주소값을 가져올수 있잖아....컴터 주기지마.. 소중한 내 컴터... 내 데이터.. 내 코딩..*

JS 엔진도 우리에게 매번 바뀌는 메모리셀의 저장된 주소를 알려주지 않기 때문에  해당 주소에 접근할수 없어서 수정 및 변경을 할수가 없기 때문에 변수를 쓴다. 

- **<u>변수를 만들때에는 그 변수에 할당되어져있는 값(ex: "30")을 재사용하겠다는 의미가 있다.</u>** 

##### 예시

``` javascript
var a = 10 + 20 ; => 방의 주소 위치를 기억하라고 명령한 상태(사람을 위한 표현)
----------------
JS 엔진을 위한 표현
var a ; 
a = 10 + 20 ;
```

<p style="color:red";>var <span style="color:green";>a <span style="color:black";>= <span style="color:blue";>
    10 +20 ; <span style="color:black";>

![캡처45](https://user-images.githubusercontent.com/62126380/79983970-7b578f80-84e3-11ea-9680-92429ec6a3e6.PNG) 

==> 변수선언과 변수값이 주어지면(=변수값이 할당이 되면) 값(ex:"30")이 있는 곳에는 언제든지 <br>		접속할수 있으므로 재사용이 가능하다.  

==> 위 예시로는 재사용 할수 있는 값은 오로지 "30" 뿐이다. 

​		10 과 20 에도 변수에 값을 할당해야 재사용 할수 있다. 



### 식별자

![캡처48](https://user-images.githubusercontent.com/62126380/79992279-3c7b0700-84ee-11ea-90f9-725deebe7224.PNG) ![캡쳐56](https://user-images.githubusercontent.com/62126380/80098484-eff40200-85a7-11ea-8aa2-875d61cc3e47.PNG)

- 하나의 값을 저장하기 위해 확보한 메모리 공간 (노란색 칸) 또는 메모리 공간을 식별 할 수 있는 이름

- 식별자는 고유해야 한다.(스코프 내에서 고유해야 한다.)

- 함수의 이름도 식별자이다.

- 선언하는 애들은 다 식별자구나~ 라고 생각하면 된다. 

  ``` javascript
  10 + 20 = 30
  ---------
  " 10 + 20 " 란 글자랑 "30" 이란 글자가 똑같지 생기지 않다. 
  하지만 식이 계산된다면 왼쪽과 오른쪽이 결국 같아진다. 
  이때 "같아진다" 라는 뜻을 "동치"라고 한다. 
  
  위 이미지로 말하자면 
  "result" 변수이름, 또는 식별자가 노란색칸을 가리키고 있다. 
  즉, "result" 라는 식별자와 노란색칸(메모리)는 동치다. 
  하여, 퉁쳐서 식별자는 고로 변수 라고 부를 수도 잇다. 
  ```

- 식별자는 어떤 값(ex:"30)이 저장되어있는 메모리 주소를 기억(저장)해야 한다.

- 식별자는 값(ex:"30")이 저장되어있는 메모리 주소와 연결관계가 있으므로, 해당 연결 정보도 저장되어야 한다.

  ===> 식별자는 메모리주소에 붙인 이름이라고 할수 있다. 

- 변수 이름, 즉 식별자는 가독성을 높여주는 효과를 준다.



## 식별자 네이밍 규칙

- 식별자의 이름을 지을때 규칙이 있다. 

  - 사용할수 있는 특수문자( 2개 ) :  "_" , "$"

  - 알파벳으로 시작하는 이름

  - 숫자로 식별자의 이름이 시작되면 안된다.

  - 식별자의 이름 중간에는 문자, 숫자, "_" , "$" 모두 사용할수 있다.  

  - SyntaxError(문법에러)를 주의하자.

  - `예약어`는 식별자로 사용할 수 없다.

    ```javascript
    예약어: 프로그래밍 언어에서 사용되고 있는 언어
    
    await / break / case / catch / class / const / continue / debugger / default / delete / do / else / enum 
    / export / extends / false / finally / for / function / if 
  / implements* / import / in / Instanceof / interface* / let* / new 
    / null / package* / private* / protected* / public* / return / super 
  / static* / switch / this / throw / true / try / typeof / var / void 
    / while / with / yield*
    ```
  
  - 쉼표로 구분해서 하나의 문에서  여러개 한번에 선언할수 있지만 비추다. 

    ```javascript
  ex)
    var person, $elem, _name, first_name, val1;
    ```
  
  - 영어 외의 언어로 써도 되지만 비추다. 

    ```javascript
  ex) 
    var 이름, なまえ;
    ```
  
  - 두 단어를 쓸때는 스네이크케이스, 카멜케이스, 파스칼케이스, 헝가리언케이스, 전부 소문자, 전부 대문자만  사용 
  
    ```javascript
    var first_name;
    var firstName;
    var firstname;
  var FIRSTNAME;
    var FirstName;(파스칼 케이스)
  var strFirstName;(헝가리언케이스)
    var $elem = $('.myclass') (제이쿼리)
    ```
  
  - 가독성 좋게, 명확한 의미로, 쉽게 이해할 수 있도록 이름을 지어야 한다.
  
    ```javascript
  var x = 3; ==> 명확한 의미 NG
    var d;  ==> 명확한 의미 NG
    var score = 100; ==> "100 이란 값이 점수를 뜻하는구나" OK
    var elapsedTimeIndays; ==> 경과시간,단위,날짜의 명확한의미 OK
    ```
  
    

## 변수 선언

<p style="color:red";> 들어가기에 앞서...</p>

1. JS 가 아닌 다른 언어들은 변수를 선언하면 반드시 초기화를 해야 한다. (이것은 약속이다.)

2. JS 는 인터프리터 언어라서 <u>**변수에 값을 할당하지 않으면**</u> 일반적으로는 오류가 발생하지만, JS를 만든 우리 브랜든 아이크씨는 친절한 분이시라 **<u>암묵적으로 오류가 나지 않게 JS를 만들어주셨다</u>** *<- 오 할렐루야*
3. 메모리셀에 한번 저장되었던 값을 초기화하지 않고 안 치운다면 값은 지워지지 않고 그대로 남는다.<br>이때 쓰였던 메모리셀은 <u>**무의미한 값(=쓰레기 값)**</u>을 가지게 되는것인데 이런 상황을 "초기화 하지 않은상황"이라고 할수있다.<br>하지만 JS는 친절한 언어이기때문에, <u>**초기화 하지 않아도 암묵적으로 초기화를 시켜준다**</u>. *<-THANKS JS*
4. **<u>변수를 사용하려면 반드시 선언이 필요하다.</u>**
5. <u>**변수를 선언할 때**</u>는 var,let,const,function, class... 같은 <u>**키워드(명령어)를 사용**</u>한다. 

---

### 변수 선언이란?

##### 예시1

JS엔진은 사람이 보기 편하게 만든 한줄 코드 " `var result` = 10 + 20 ; "을 두줄로 해석한다. 

![캡처49-1](https://user-images.githubusercontent.com/62126380/80062249-3e84aa80-856e-11ea-866d-5de314f30a74.PNG) 

- 변수를 생성하는 것

- 값을 저장하기 위한 메모리 공간을 확보하고 식별자와 확보된 메모리 공간의 주소를 연결하여 값을 저장할수 있도록 준비하는 것

- **<u>하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름</u>**

- 변수 선언단계 (변수 선언만 했을때의 상태)

  - 선언 단계 : 변수 이름(ex:"result")을 등록하여 JS엔진에 변수의 존재를 알린다

  - `초기화 단계` : 값을 저장하기 위한 메모리공간을 확보하고 변수 "result"에  암묵적으로 undefined를      할당한다.   

    - 쓰레기값이 나오는걸 방지하기 위해서 undefined 값을 할당하는 것이다.

    ===> 두 단계가 한방에 이루어진다. 

  ``` 
  초기화 단계
  
  1. 변수 선언 후 값을 할당하지 않으면 `undefined`라는 쓰레기값 만큼만 공간이 확보가 
     되어지는데 몇byte가 확보될지 모르니까 일단 무조건 암묵적으로 undefined 값이 
     들어갈만큼만 확보한 후에, undefined값이 할당되고 메모리셀이 초기화 된다.
  2. var 키워드로 변수는 선언이후 어떠한 값도 할당하지 않아도 undefined라는 값을 가진다.
  3. undefined값은 JS엔진 회사마다 byte 값이 다 다르기때문에 표준이 없으므로 
     undefined값의 크기는 모른다. 
  ```

  ##### 예시2

  ```javascript
  var result ;
  console.log(result);
  ----------------------
  변수를 선언만 했지, 변수에 값을 할당하지 않은 상태에 변수값을 참조한 상태이다.
  -> undefined 값(쓰레기값)이 나온 상태.
  ```

  ![캡처50](https://user-images.githubusercontent.com/62126380/80004386-37718400-84fd-11ea-87f9-a4b9fe7a96ff.PNG) 



## 변수문법

- 컴퓨터는 코드를 위에서 아래로 순차적으로 실행한다.

- 명령은 value(값), operator(연산자), expresstion(표현식), comment(주석)으로 구성되며 세미콜론(;)으로 '문'을 끝마친다. 

##### 예시1

![캡쳐51](https://user-images.githubusercontent.com/62126380/80062371-8acfea80-856e-11ea-9ff9-9a1e54934f68.png) 

``` javascript
var result ; 

변수 선언만 하고, 값을 할당하지 않은 상태 라서 -> undefined 값이 도출
----------------------------------------------------------------
var result ;
result = 10 + 20 ;

변수 선언도 하고, 변수에 값도 할당한 상태 -> 정상 작동
```

##### 예시2

![캡쳐52](https://user-images.githubusercontent.com/62126380/80063263-80165500-8570-11ea-88b6-892dc699f08a.png) 

```javascript
result = 10 + 20 ;

변수 선언을 안한 상태에 값을 할당했는데 왜 에러가 안나오죠?  
-> 친절한 JS씨라서 "너 선언하는거 까먹었지...? 어휴.. 내가 알아서 출력해줄게" 하고 자동으로 결과값을 도출해줌.  -> 정상 작동
------------------------------------------------------------------------------
①result = 10 + 20 ;
 var ②result ;

①result 랑 ②result 은 다른 result 다. 
왜냐? 친절한 JS씨가 "너 선언하는거 까먹었지...? 어휴.. 내가 알아서 출력해줄게" 하고 자동으로 ①result 값을 
벌써 출력을 이미 다 해줬는데 또 ②result 를 선언한다. 이건 중복이다. 
그래서 ①result 값을 지워버리고 다른 ②result 값이 새로 생겨버린 상태라서
-> undefined 값이 도출 
```



## 레퍼런스 에러(참조 에러)

<p style="color:red";> 들어가기에 앞서...</p>

1. 변수 참조( "cosole.log(~)" ): 변수의 값을 가지고 와서 출력해달라는 명령

   ```javascript
   ex)
   var result ;
   console.log(result);
   ----------------------
   선언한 변수 "result" 값을 출력해줘!!!
   -> 결과 : 할당한 값이 없으므로 undefined 값 도출
   ```

---

레퍼런스 에러 : 선언된적이 없는 변수를 참조하려고 할때 발생하는 에러

##### 예시1 (레퍼런스 에러 발생)

```javascript
var result = 10 + 20 ;
console.log(score)
------------------------
"result" 라는 변수를 선언했는데, 참조한 변수는 "score" 이란 변수라서 레퍼런스 에러 발생
```

![캡쳐53](https://user-images.githubusercontent.com/62126380/80066296-a0491280-8576-11ea-8a51-caebc85666ea.PNG) 

##### 예시2(레퍼런스 에러 X)

``` javascript
1. var result = 10 + 20 ;
   console.log(result) ;
-----------------------------
"result" 라는 변수를 선언 + 변수에 값을 할당 + 참조한 변수 "result"로, 선언한 변수를 참조
-> 에러 없이 값이 3으로 정상 도출

2. console.log(result) ;
   var result = 10 + 20 ;
-----------------------------
-> 결과 : undefined값 도출(레퍼런스 에러X)

위 코드는 변수 호이스팅으로 인해(호이스팅: 아래 설명 참고) 변수 선언문부터 읽히고, 
그 다음에 콘솔로그가 읽힌다.(아래처럼) 
var result ;
console.log(result);
근데 이 상태는 아직 "result"값이 할당되어있지 않은 상태라서 undefined 값이 도출된다.
그 후에 result = 10 + 20 ; 이란 "문"이 읽히는데, 이 "문"에는 어떠한 행위를 해달라는
명령어가 없기때문에 실행되는 것은 아무것도 없다. 그래서 결국 결과값으로 undefined값이 
도출되는 것이다.
제대로된 결과값을 도출하려면 아래처럼 코딩하면 된다.

console.log(result);
var result = 10 + 20 ;
console.log(result);
*"값의 재할당"과 관련있는 코드이니 아래 "값의 재할당"부분도 참고하자.
```



## 변수 호이스팅

- 런타임(run time) : 코드들이 위에서 아래로 순차적으로 읽히는 과정

- 변수 호이스팅 : 다른 언어들과 다르게, JS엔진은 런타임 이전에 <u>**변수 선언문**</u>이 다른 코드들보다 제일 먼저 평가되어 <u>**제일 먼저 실행**</u>되는 것  
- 변수 호이스팅 발생 이유 : 런타임 이전에 변수 선언을 처리, 초기화를 하기 때문이다. 

##### 예시1

![캡쳐54](https://user-images.githubusercontent.com/62126380/80074138-b14c5080-8583-11ea-9c64-82ce3b4d5b45.PNG) 

```javascript
결과:

★ console.log(score) ;
☆ var result ;
-----------------------------
1. ☆ 코드 평가 -> 2. ★ 코드 실행 -> 레퍼런스 에러는 아니지만 undefinde값이 할당.
```

1. 코드 평가 : JS엔진은 다른언어와 다른점이 있는데, 코드를 순차적으로 읽어내려가서 실행을 하기 이전에 <br>실행을 하가 위해  코드평가가 먼저 이루어진다.
2. 코드 실행 : JS엔진은 코드 평가 과정에서 변수선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 코드에서 먼저 찾아서 변수 선언문을 제일 먼저 실행한다.

위 코드처럼 변수 참조가 먼저 되고 변수 선언이 그 다음으로 되어도 JS엔진은 실상 위 예시로는 ☆->★ 순서로     코드를 해석한다. 
위 코드의 현재 상태는 변수 선언 다음에 변수 참조가 이루어진 상태인데, 현 상태는 아직 변수값에 값이 할당되어
있지 않은 상태라서 undefined 값이 할당되어 지는 것이다. 



## 값의 할당

&#128205; &#128205; 제일 먼저 변수 호이스팅을 유의하자.

##### 예시1

![캡쳐107](https://user-images.githubusercontent.com/62126380/81918580-9f554f00-9611-11ea-934c-701934022ee8.PNG)  

```javascript
① console.log(score);
② var score = 80 ;
③ console.log(score);
---------------------------
-> 결과 : 80 값을 도출
```

① : 변수 score의 값을 출력해줘! -> 아직 변수 선언도 안하고, 값을 할당하지도 않았기 때문에 **undefined값 도출**

①,② : JS엔진이 ② 가 1줄로 보이지만 두줄로 해석한 후, 변수 호이스팅이 실행된다.

실상, 아래 이미지처럼 실행되어 **undefined 값 도출**

![캡쳐55](https://user-images.githubusercontent.com/62126380/80091542-35aacd80-859c-11ea-96be-e34e0017510a.PNG) 

①,②,③ : undefined 값이 도출된 상황이지만 이미 변수 선언 완료 + 값의 할당도 완료되어서 <br>				**정상적인 80이란 값이 도출**

---

##  값의 재할당

- 기존에 할당이 되어져있는 변수에 다른 값을 다시 할당하는 행위
- 가급적이면, 왠만해서는 재할당을 안하는게 좋다. 
- 재할당을 하면 반드시 메모리 주소가 바뀌는거라서, 새로운 공간을 만들어서 포인팅을 바꾼다. 
- 재할당을 할수 없는(재할당이 금지된) 변수는 변수라고 하지 않고 상수(const)라고 한다.
  - 재할당이 금지되기때문에 처음값을 바꿀 방법은 객체타입의 경우에만 있다.

##### 예시1

![캡쳐57](https://user-images.githubusercontent.com/62126380/80106335-b1b10f80-85b4-11ea-961b-3724ed0a2991.PNG) 

![캡쳐58](https://user-images.githubusercontent.com/62126380/80107358-ef626800-85b5-11ea-8688-d809c7d08c48.PNG) 

```js
① 변수 선언으로 인해 변수 "score"가 가리키고 있던 undefined 값은
② "80"이란 값을 할당함으로 인해 폐지(해방)되어 메모리가 해제 되고
③ "90"이란 값을 재할당함으로 인해 "80"이란 값이 저장되었던것도 폐지(해방)가 되어 메모리가 해제 된다.
```

==> 폐지(해방)되어 메모리가 해제가 된 값들은 가비지 컬렉터(garbage collector)가 메모리들을 훑다가<br>"어~? 이 메모리셀의 값은 더이상 필요없네?? 어떠한 변수도 이 메모리셀의 값을 가리키고 있지 않네??" <br> "그럼 이제 이 메모리(ex: undefined) 공간 써도 되~ 얘도(ex:80) 써도 되! 하지만 얘는(ex: "90") 쓰면 안되~!!"라고 재사용해도 되는 쓰레기값에 대해 판단한다.   

가비지 컬렉터가 메모리셀 공간영역의 재사용에 대해 판단을 하고, 재사용이 가능하다면 그 셀에는 다른 값들로  채워질수 있다. 

하지만 여기서 유의해야 할 점은 위의 이미지대로, 값의 할당과 값의 재할당이 이뤄지면 값으로 채워졌던<br> 메모리셀 의 값들이 지워지고 거기에 **<u>새로운 값들이 할당되는것이 아니라, 새로운 다른 메모리셀에 값이 엎어져서 채워지는 것이다.</u>** 



## 값의 교환

값을 교환(교체)하는 방법을 알아보자

예시) 변수 x 의 값과 변수 y 의 값을 바꿔라.

![캡쳐62](https://user-images.githubusercontent.com/62126380/80273633-e6d17500-870e-11ea-8f28-62db495ac371.PNG) 

해석) console.log( x, y )  -> ( 2, 1)

![캡쳐63](https://user-images.githubusercontent.com/62126380/80275359-a62c2880-871b-11ea-81b0-a50dc85a716d.PNG) 

---

# 표현식과 문

<p style="color:red";> 들어가기에 앞서...</p>

표현식이란?

1. 평가되어 값이 되어지는 것.

2. 값으로 평가될 수 있는 문.
3. 표현식이 평가되면 새로운 값을 생성하거나 기존의 값을 참조한다. 

---

## 값

- 평가 : JS엔진이 코드를 실행해서 결과물인 값을 도출하는 과정
- 표현식이 이게 뭔지 해석하는 ''코드 평가 단계'를 거쳐서 생성된 값 또는 결과물이 메모리에 저장되어지는 최소단위이다.
- 문을 보면 컴터가 해석을 할건데, 표현식이면 평가를 하는거고, 실행문이면 실행을 하는것이다. 

![캡쳐64](https://user-images.githubusercontent.com/62126380/80275782-75012780-871e-11ea-8de5-9fb7ceb68ebb.PNG) 

``` javascript
ex)
var x = 10 + 20 ;
x = 10 + 20 ;
------------------
10 ==> 숫자 리터럴
20 ==> 숫자 리터럴
10 + 20 ; ==> JS엔진에 의해 평가되어져서 연산자 표현식이면서 값 ( 10 + 20 ; 와 "30"은 동치)
x  ==> 식별자 표현식이면서, 결국엔 "30" 이란 값으로 평가되어져서 결과물을 생성하기때문에 값
------------------------------
```

---

### 리터럴( 기호 )

- 사람이 이해할수 있는 문자 또는 약속된 기호를 사용하여 **<u>값을 생성하는(만들어내는) 표기방법</u>**

- JS엔진에 의해서 평가되어질 코드 

- 값을 생성하기 위해 미리 약속한 표기법

- 코드에 맞는 기호를 값으로 만들어내는 것

  ![캡쳐59](https://user-images.githubusercontent.com/62126380/80170481-025f5180-8623-11ea-992d-1dfe5353a730.PNG)

  ``` ex
  개발자가 코드에 3 이라는 숫자 리터럴을 쓰면, 이건 숫자 십진수의 10 이다. 라고 JS엔진하고
  개발자가 서로 알고있는 약속을 하는것이다.
  -> JS엔진은 3 을 십진수 3으로 해석해서 메모리에는 2진수의 값으로 저장한다.
  ```

- ![캡쳐60](https://user-images.githubusercontent.com/62126380/80172179-494f4600-8627-11ea-9fd9-c5b19da03f6b.PNG) 

  ```  
  리터럴 : 값으로 평가될수 있다. 평가되면 리터럴은 결국 값이 된다.
  표현식 : 평가되어 값이 되어지는 것
  ==> 리터럴 = 표현식 (동치의 개념으로 리터럴과 표현식은 같다.)
  ```

- 리터럴의 종류(데이터 타입)

  - `원시타입 (기본형, 기본자료형)`

    ``` html
    원시타입(프리미티브 타입) :
    변경 불가능한 테이터 타입이다. (변경 불가능(immutable))
    ```

    - 숫자 리터럴 

      - JS에서는 정수(소수점 없는 숫자), 실수 구분없이 전부 실수(`부동 소숫점`)로 처리한다. 

        ```
        ① 숫자 리터털(숫자 타입):
          배정밀도 64비트 부동소수점 형식을 따른다.
        ② 정수로 표시되는 수 끼리 연산하더라도 실수로 표시한다.
        ```

      - 저장할때 2진수로 저장되었다가 꺼내올때는 데이터 타입의 10진수로 변환해서 꺼내져서 가지고 옴

      - 계산하기 위해 쓰이는 리터럴이다. 
        - 정수 리터럴 ( Infinity / -Infinity : 양의 무한대 / 음의 무한대)
        
        - 부동 소숫점 리터럴
        
        - 2진수 리터럴 (0b 로 시작하는 숫자)
        
        - 8진수 리터럴 (0o 로 시작하는 숫자)
        
        - 16진수 리터럴 (0x 로 시작하는 숫자)
        
        - `NaN` : 산술 연산 불가(계산을 하려했는데, 계산을 못했을 때 나타나는 값)
        
          ```javascript
          ex)
          'x' * 10  // NaN
          1 + undefined // NaN
          -----------------
          'x' 문자열로 계산하려 했기 때문에 NaN 이란 결과값이 도출된다.
        웬만하면 에러를 안내려고 하기 때문에, NaN이란 어거지 값을 도출한다.
          ```
          
      
    - 문자열 리터럴 ( ' ' , " " , `` ) = string
    
      - ```
        개발자 : " 나 이제 문자열 타입의 값을 할당할건데.. 뭐라고 보기 쉽게 구분하지..? 
      그래!! 그럴땐 "string" 이란 식별자를 쓰자!
    ```
    
    - ```javascript
        var string = '오세진';
        var string = "오세진";
        var string = `오세진`;
        var string = "'오세진'";
    var string = '"오세진"';
        ```
    
      - 기록과 누군가에게 읽히기 위해, 출력하기 위해 쓰이는 리터럴이다. <br> <- *함수를 통해서도 문자열을 만들수 있지만 뻘짓이야. 하지마라~*
    
      - 따옴표들과 백틱으로 값을 감싸지 않으면, JS엔진은 식별자와 같은것으로 해석한다.
    
      - JS엔진은 문자 리터럴을 만나면 문자열에 해당 하는 **<u>유니코드로 변환해서 2진수로 저장</u>**한다. 

        > JAVA script : UTF16 
  >
        > JAVA script는 16bit(2byte)로 표현하는 유니코드체계를 사용한다.

      - 1개만 있는건 "문자" 라고 하지만, 여러개가 있을 때는 "문자열(`0개` 이상의 문자들의 집합)"이라고 한다. 하지만 JS엔진은 전부 "문자열"이라고 해석한다. 
  
        ```
      ㅅ' ' : 빈 문자열
        ```

      - " ' ' " 와 ' " " ' 은 똑같이 문자열로 해석한다.
  
        - 템플릿 리터럴 : ``(백틱)을 사용하여 문자열을 표기하는 방법.
    
          ```javascript
      - ''(백틱)을 이용해서 문자열을 표기하는 방법
          - 템플릿 리터럴에서는 개행(Enter키)이 허용, 인식이 가능하다. 
      => 일반적인 ''(작은 따옴표)로는 개행(Enter키)이 허용, 인식이 되지 않기 때문에 Syntax error가 난다. 
          => 그렇다면 일반적인 ''을 사용해서 개행을 나타내려면 어떻게 하면 될까?
      --------> ∴ 멀티라인 문자열을 사용하면 된다. 
          ```
    
          ```javascript
          ex) 
          var template = `<ul>
          <li><a href="#">Home</a><li>
          </ul>`;
        console.log(tamplate);
          /*
          <ul>
          	<li>
          		<a href="#">Home</a>
          	</li>
          </ul>
        */
          ```
    
          - 멀티라인 문자열(= 개행 문자열) : ( \n, \r 을 사용)
    
            ```javascript
            \n : 라인피드(LF, Line feed)
            \r : 캐리지리턴(CR, Carriage Return)
        ------------------------------------
            ex)
          var tamplate = '<ul>\n\t<li><a href="#">Home</a></li>\n</ul>';
            console.log(tamplate);
            /*
            <ul>
            	<li>
            		<a href="#">Home</a>
            	</li>
            </ul>
          */
            ```
    
          - 표현식 삽입
    
          - 피연산자 중 하나 이상이 문자열일 경우 문자열 연결 연산자로 동작한다.
            - 표현식을 삽입할 때, `${ }`으로 감싸면 감싼 내용은 강제 문자열로 해석된다.
    
        ```javascript
            작은 따옴표를 사용했을 경우
          ex1)
            
            var first = 'Se-jin';
          var last = 'OH'
            console.log('My name is ' + first + ' ' + last + '.');
            // My name is OH Se-jin
            
            ex2)
            var x = 1 + 2;
            console.log('1 +2 = ${1 + 2}');
          // 1 +2 = ${1 + 2} ===> 작은 따옴표 안에서의 표현식 삽입은 사용할수 없다. 그냥 문자열로 해석이 된다. 
            ```
    
            ```javascript
            백틱과 표현식 삽입 기호("${ }")를 사용했을 경우
            ex1)
            
            var first = 'Se-jin';
          var last = 'OH'
            console.log(`My name is ${first} &{last}.`);
            // My name is OH Se-jin
            
            ex2)
            
            var x = 1 + 2
            console.log(`1 + 2 = ${1 + 2}`);
          // 1 + 2 + 3 
            ```
    
    - 불리언 리터럴 ( 예약어 )
    
      - JS엔진이 불리언 리터럴을 만나면, 논리적 참인지 논리적 거짓이란 불리언 값을 생성한다.
      - 조건문 같이 참과 거짓으로 구분되는 조건을 줘서 구분하고 싶을때 쓰임
    - true

  - false
    
  - null  리터럴 ( null ) 
  
    - 의도적으로 값이 없음(값의 부재)를 나타내는 값이다. 
  
      - 문들의 집합을 여러번 재사용하고 싶을 때 사용한다. 
  
        ![캡쳐67](https://user-images.githubusercontent.com/62126380/80311379-52543900-881a-11ea-98aa-0901e1c02b48.PNG) 
  
        ``` 
        "무슨 이유에서든지 이 변수는 값이 없어~ 알았지~???" 라고 쓰고 싶을때 사용
        ```
      ```
      
      ```
  
    - undefined 리터럴 ( undefined )
  
      ```
      우리가 undefined 값을 만들면 안되~! 만들어서도 안되. 
      이건 암묵적 초기화를 위한 값이야. JS엔진이 쓸라고 지가 만드는 값이니까
      우리가 만들면 안된다. 애초에 이거를 개발자가 쓰는 의도는.. 당췌 모르는거야.
      이걸 만드는 개발자는 이상한 개발자야. 
      ```
    ```
    
    ```
  
  - `객체 타입`
  
    ``` html
    객체타입(오브젝트 타입) :
    - 변경 가능한 테이터 타입이다. (변경 가능(mutable))
    - 재할당을 하지 않아도 값을 바꿀수 있다. 그렇기 때문에 값의 변경을 추적하기가 어렵다.
    ```
      - 객체 리터럴
        - `{ }` 를 쓴다. 
        - 객체 리터럴은 평가되어져서 객체를 만들게 된다. JS엔진은 그 객체를 기호로 만들어낸다. 
        - ex) {name: 'Lee', address: 'Seoul'}
      - 배열 리터럴
        - `[ ]` 을 쓴다. 
          - 배열 리터럴은 평가되어져서 배열을 만들게 된다. JS엔진은 그 배열을 기호로 만들어낸다.
    
      - 함수 리터럴
        - function( ) { }
        - JS엔진이 이거를 함수라는 값으로 만들어냄
      - 정규표현식 리터럴



## 표현식

- **<u>값으로 평가될수 있는 문</u>**

- 표현식이 평가되면 새로운 값을 생성하거나 기존의 값을 참조한다. 

- 문의 일부일수도 있고, 그 자체로 문이 될수도 있다. 

- 표현식인 문인지 아닌지 구별하려면, 직접 변수에 할당해보면 된다.(`undefined (완료값)`이 출력되면 표현식이 아닌 문이다. ) 

  ```javascript
  var x = "~~~~~~"
  -------------------
  "~~~~~~"  에 직접 할당해보고 syntax 에러가 안나면 해당 식은 표현식 OK.
  						   syntax 에러(undefined)가 나면 해당 식은 표현식 NO.
                             	 - 이때 도출되는 undefined 값은 완료값이라고 한다.  
                               - 완료값은 변수에 할당할수도 없고, 참조할수도 없다.
                               - 크롬 개발자도구가 출력해주는 값이다. 
  ```

  ![캡쳐65](https://user-images.githubusercontent.com/62126380/80302898-c32e2d80-87e7-11ea-80af-9f6effecba12.PNG) 

- 표현식의 종류

  - 리터럴 표현식

  - 식별자 표현식

    ex) sum

    ​	  person.nam ("person" : 객체 / "name" :객체의 프로퍼티)

    ​	 arr[1]

  - 연산자 표현식

    ex) 10 + 20 

    ​	  sum = 10 

    ​	  sum !=== 10

  - 함수,메소드 호출 표현식:  함수를 호출하면 '반환'값을 호출해준다. 호출하면 값으로 평가된다. 

    ex) square( )

    ​	  person.getName( )

    ```javascript
    var x = 10 + 20 ;
    ------------------
    x : ① 식별자 표현식
    	② 값
        ③ 리터럴
    10 : ① 숫자 리터럴
    	 ③ 값
    10 + 20 : ① 연산자 표현식
    	 	  ② 값
         	  ③ 리터럴 (값으로 평가 될수 있음)
    x = 10 + 20 ; : ① 변수 할당문
    			    ② 연산자 표현식 (값으로 평가 될수 있음)
                    ③ 값
    x !== 30; : (x 값이 30이 맞으면 true값이 도출될것이고, 틀리면 false값이 도출될것이다.)
    			① 연산자 표현식 (값으로 평가 될수 있음)
    			-> 결과값 : true
    ```

    

## 문 (명령문)

<p style="color:red";> 들어가기에 앞서...</p>

1. `{ }`으로 묶은 내용들은, `{ }`까지 포함해서 '코드블럭' 이라고 한다.
2. JS엔진은 소스 코드를 해석할때, 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 ASI(세미콜론 자동삽입 기능)이 암묵적으로 수행되지만, 제대로 수행되지 못하는 경우가 있으니 그냥 붙여주기로 하자. *<- 브랜든 아이크씨는 붙이지 말자고 하는데 TC39가 붙이자고 하고 있으니까 우리도 붙여주기로 하자. JS 창시자의 의견이 묵살당하고 있는 이 업계의 현실... 불쌍한 브랜든씨...* 

토큰 

- 문법적인 의미를 가지며, 문법적으로 더이상 나눌 수 없는 코드의 기본요소.
- "문에 있는 하나하나의 요소"

문 

- 컴퓨터에게 내리는 명령이기 때문에 "명령문"이라고도 한다. 
- 문이 실행이 되면 명령이 실행되고 무슨 일이 일어나게 된다. 

---



![캡쳐65](https://user-images.githubusercontent.com/62126380/80301041-7b55d900-87dc-11ea-9fb0-cea169a092d5.jpg)



- 프로그램은 구성하는 기본 단위이자 최소 실행 단위.

  우리가 작성한 코드들이 한줄한줄 실행되는데 그 한줄한줄 실행되는 단위.

- 문들은 0개 이상의 토큰들로 이루어져있다.

- 문은 세미콜론 ( ; ) 으로 끝나야 한다. 

  0개 이상의 문을 묶은 코드블럭 뒤에는 세미콜론을 붙이지 않는다. 

- 토큰들이 갖고 있는 의미들을 JS엔진이 해석한다. 

- 명령문이 실행이 되면 변수가 선언되고, 3 이란 숫자가 만들어지고, 할당이 이루어진다. 

- 문의 종류

  - 변수 선언문 : 선언문이 실행되면 변수가 선언된다.

  - 할당문(표현식 문) : 할당문이 실행되면 변수에 값이 할당된다.

  - 함수 선언문 : 함수 선언문이 실행되면 함수가 생성된다. 

    ```javascript
    ex)
    function foo ( ) { }
    ```

  - 조건문 : 조건문이 실행되면 코드블럭이 실행될지 안될지를 결정.

    - 값으로 평가할수 없는 표현식이 아닌 문이다. 

    ```javascript
    ex) 
    if (x > 1) { console.log(x); }
    --------------------------------
    : `( x >1 )` 이 조건에 부합이 되면 `console.log(x)`이 실행될것이고, 부합하지 않으면 실행되지 않는다. 
    ```

  - 반복문 : 조건을 따라서 반복을 할건지 안할건지 결정.

    ```javascript
    ex)
     for (var i = 0; i < 2; i++) { console.log(i); }
    --------------------------------------------------
    `(var i = 0; i < 2; i++)` 이란 반복문의 조건에 의해서,  `console.log(i); ` 이 반복될것인지 아닌지를 결정.
    ```