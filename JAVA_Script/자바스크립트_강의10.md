생성자함수는 항상 쌍으로 돈다. 

넘버 생성자함수는 언제 만들어질까? 생성자 함수도 호출될 가능성이 있으므로 프로토타입 객체와 쌍으로 만들어진다. 

객체 생성 방법

.... 1. 

2. 빌트인 생성자 함수...

   로 알아보았다. 

리터럴이 최고 중요한 방법이다. 

리터럴로 만드는 최고의 방법이... 

```js
const obj = { };
```

위 코드의 객체는 누가 만들었습니까? 라고 누구한테 물어보냐. 에크마스크립트 사양서한테 물어본다.

에크마스크립트 사양서에는 이렇게 나와있다. 

객체 리터럴이 생성되면... 이렇게 하세요. 라고 나와잇음

return  오브젝트 크리에이트(%오브젝트프로토타입%)

오브젝트 크리에이트: 의사표현...의 함수다.

.... 인수를 함수화한다.

오브젝트가 객체를 생성한건 아닌데, 상속구조를 갖기 위해서.... 치자. 라고 한다. 

그러면 객체 리터럴뿐아니라 .... 또 뭐가 있었지?

[ ] 이것도 있고

function ( ) { } 이것도 있다. 

프로토타입 메소드는 일반적으로 인스턴스로 호출한다.

객체를 얼리는 방법.

객체지향에 캡슐화 라는 게 있다. 캡슐이라고 하면 일반적으로 알약인에. 안에 있는 내용을 외부로 유출시키고 싶지 않은것이다. 그래서 클래스기반 객체지향 언어들은 다 캡슐화가 된다. 

캡슐화가 된다는 얘기는 프로퍼티에 키워드를 적어주면, 프라이빗 이라고 적어주면 이 프로퍼티는 이 객체 내부에서만 참조할수 있다. 

즉시실행함수는 런타임에 들어가자마자 정의되어지고 실행된다.

함수는 종료되면 죽는거다. 그럼 지역변수는 언제 죽나? 함수가 죽을때 죽는다.

함수를 호출해야 함수가 생성된다.

변수는 함수가 종료되면 죽는다. 선언처리하면 식별자는 등록된다. 스코프라는 객체에 등록된다. 스코프라는 객체를 나타낸다. 

내부슬롯 [[인바이러먼트]] : 자신의 상위 스코프

렉시컬 스코프 : 상위 스코프를 결정하는 방식 상의 스코프를 결정하는 방법 : 동적 스코프, 정적 스코프

상위 스코프를 인바이러먼트로 인해 기억한다.

자스에서 캡슐화 가능하다. 클로저로 구현이 가능하다.

## 오버라이딩

오버라이딩 : 덮어쓴다고 한다.

![image-20200508153107178](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200508153107178.png) 

![image-20200508153224989](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200508153224989.png) 

미.세이헬로우 하면 맨 밑에 세이헬로를 찾는다.

## 프로토타입의 교체

인스턴스 오브 : instance of (이항 연산자)

ㅁ instance of O : ㅁ 이 O 의 인스턴스인가 라고 물어보는거다.

ㅁ에는 객체가 온다. ㅁ 는 생성자 함수다. 

인스턴스 오브는 우변의 생성자 함수의 프로토타입에 바인딩된 객체.가 좌변의 객체의 포토토타입 체인 상에 존재하면 트루로 평가되고 그렇지 않은 경우에는 풜스로 평가된다.

## 직접 상속

![image-20200508161213048](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200508161213048.png)

우리가 나중에 함수를 만들때 이런 경우가 있으수도 있다. 

매개변수를 순서를 어떠케 해야 할까? 앞에 있는게 필수여애 하고 뒤에 있는게 옵션이어야 함. 

위 코드뜻은 객체를.생성한다 라는 뜻이다. 프로토 타입을 지정하면서 생성한다. 라는 뜻이다.

객체 생성 방식

1.객체 리터럴에 의한 생성

2.오브젝트 객체에 의한 생성

3.생성자 함수에 의한 생성



## 정적 프로퍼티/메소드

떡밥을 많이 깔아놓음

## 프로퍼티 존재 확인

in : 객체 내에 프로퍼티가 있는지 없는기 확인하는것이다.

![image-20200508164334685](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200508164334685.png) 

![image-20200508164422796](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200508164422796.png) 

인: 상속관계를 고려한다. 

hasOwn : 상속관례를 고려하지 않는다.

## 포 인문

![image-20200508165158101](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200508165158101.png) 

여기서 컨티뉴는....

브레이크 랑 컨티뉴의 차이.

배열: 객체. 프로퍼티를 가질 수 있다. 

객체의 프로퍼티만 나열할때만 포인문을 쓰자. 

## 오브젝트 키스

...

# 빌트인 객체

표준 빌트인 객체: 스탠다드 빌트인 오브젝트 . 

이 빌트인은 우리가 만든게 아니고 자스엔진이 기본적으로 만드는것이다.

노드에서도 구현이 되고 브라우저에 있는 자스엔진에도 구현이 되어있는 것들이다.

표준 빌트인 객체: 전역객체에 프로퍼티로 존재한다.

호스트 객체: 환경에 따라 다르다. 예를 들어서 우리 틀라이언트 사이드에서 얘기하면 ... 브라우저에서 동작하는 자스라고 한다. 브라우저에 얘네는 기본적으로 올라가있고 얘네 외에 많은 객체들이 올라가있다. 

돔: 에치티에멜 씨에에스 에 도 연관이 있다. 

웹스토리지: 기본적으로 스토리지라는 탭이 있을것이다. 이런걸 관리하는 API다. 

## 표준 빌트인 객체

보통 대부분 생성자 함수이다. 

아닌것들은 정적 메소드다. 그리고 프로토타입 메소드도 있다. 

## 전역 객체

글로벌디스로 전역객체를 가리키는 식별자로 통일하자.





























