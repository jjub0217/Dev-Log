# 변수

<p style="color:red";> 들어가기에 앞서...</p>

1. <u>**bit는 지수 즉, 제곱을 뜻하며 2진수가 표현할수 있는 최소의 단위다.**</u>

``` ex
ex)
1bit : 2의 1승. 2개의 경우의 수를 나타낼수 있다 (0 또는 1)
2bit : 2의 2승. 4개의 경우의 수를 나타낼수 있다 (00, 01, 10, 11)
8bit : 2의 8승. 256개의 경우의 수를 나타낼수 있다. 
```

2. <u>**변수는 에러발생의 근본 원인이다.**</u>

   변수가 많을수록 기억해야 할 사항이 많아지는것이므로, 오류 발생 확률이 커진다. 

   ∴ 변수는 적을수록 좋다. 

---

## 변수란 무엇인가?

- <u>**하나의 값을 저장하기 위해 확보한 메모리 공간 자체**</u> <br>변수를 선언하면 메모리 공간의 영역을 확보하면 다른 애가 그 영역을 못쓴다. 

"변수는 값을 저장하기 위한 `상자`다." -> 바보같은 설명임....<br>(근데 왜= 이런식으로 설명할까? 그렇게 설명해줘야 이해하기 쉽다고 함)

```  
상자 = 메모리 (개발자들에게 메모리는 상당히 중요한 요소임)
```

##### 예시

``` javascript
<script> 
10 + 20 = 30
</script>    <- 자바스크립트 코딩하게 된다면?
```

![캡처43](https://user-images.githubusercontent.com/62126380/79992090-02116a00-84ee-11ea-9816-05e63e0692a2.PNG) 

 

- 식별자 : 하나의 값을 저장하기 위해 확보한 메모리 공간(노란색 칸) 또는 메모리 공간을 식별할수 있는 이름을 가리킨다. 

- 메모리 주소 : 0 ~ 메모리 크기만큼 정수로 표현

- 연산은 CPU가 함. 

- 값이 저장될 메모리셀의 주소는 코드가 실행이 될때, 메모리의 상황에 따라 OS가 임의로 결정한다. 

  따라서 똑같은 컴퓨터로 똑같은 코드를 실행해도, 코드가 실행될때마다 해당 메모리셀의 주소는 매번 변경이 된다.  



"30" 이란 값을 한번만 쓴다고 하면 이 과정에서 끝내도 되지만, 재사용을 하려면 해당 "30"이라고 저장한 값을 다시 읽어들여서 사용해야 한다.  

--> 이때 재 사용하기 위해 **"변수"** 라는 것을 이용한다.

``` 
변수

"30" 이란 값을 재사용하려면 "30"이란 값을 도출해낸 메모리셀의 주소를 알아야 한다.
하지만 메모리셀에 저장되었지만, 연산하여 만들어낸 값은 재사용을 할수 없기 때문에 저장을 시켜야 한다.
10 + 20 의 결과값이 있는 곳을 기억해라 고 컴퓨터에게 명령을 해야하는데 
이때 사용되는것이 "변수"다.
```



## 변수를 왜 사용해야 할까?

- **<u>변수를 사용한다는 것은 메모리를 쓴다는 것이다.</u>** 

어떠한 변수가 어떠한 메모리의 공간영역을 예약하고 확보하여 사용을 한다고 하면, 그 영역에는 다른 변수가 침범을 하지 못한다. 

그렇게 사용하지 못하는 영역이 많아질수록 렉이 걸리는 것이다. 

그래서 변수는 영역을 점유하고 있으면 안되고, 메모리의 공간영역을 확보했다면 그 영역을 빨리 사용하고 빨리 해방을 시켜야 한다. ( 변수는 생명주기가 짧아야 한다.)

- <u>**인간은 언제나 실수를 한다. 그래서 변수를 쓴다.**</u>

메모리셀에 값이 저장된 주소는 매번 바뀌기 때문에 알수가 없다. 

저장된 값을 재사용하려면 값이 저장된 주소에 직접 접근을 해서 값을 꺼내오면 될것 같은데, 인간은 언제나 실수를 하지.... *<- 엉뚱한 주소값을 가져올수 있잖아....컴터 주기지마.. 소중한 내 컴터... 내 데이터.. 내 코딩..*

JS 엔진도 우리에게 매번 바뀌는 메모리셀의 저장된 주소를 알려주지 않기 때문에  해당 주소에 접근할수 없어서 수정 및 변경을 할수가 없기 때문에 변수를 쓴다. 

- **<u>변수를 만들때에는 그 변수에 할당되어져있는 값(ex: "30")을 재사용하겠다는 의미가 있다.</u>** 

##### 예시

``` javascript
var a = 10 + 20 ; => 방의 주소 위치를 기억하라고 명령한 상태(사람을 위한 표현)
----------------
JS 엔진을 위한 표현
var a ; 
a = 10 + 20 ;
```

<p style="color:red";>var <span style="color:green";>a <span style="color:black";>= <span style="color:blue";>
    10 +20 ; <span style="color:black";>

![캡처45](https://user-images.githubusercontent.com/62126380/79983970-7b578f80-84e3-11ea-9680-92429ec6a3e6.PNG) 

==> 변수선언과 변수값이 주어지면(=변수값이 할당이 되면) 값(ex:"30")이 있는 곳에는 언제든지 <br>		접속할수 있으므로 재사용이 가능하다.  

==> 위 예시로는 재사용 할수 있는 값은 오로지 "30" 뿐이다. 

​		10 과 20 에도 변수에 값을 할당해야 재사용 할수 있다. 



### 식별자

![캡처48](https://user-images.githubusercontent.com/62126380/79992279-3c7b0700-84ee-11ea-90f9-725deebe7224.PNG) ![캡쳐56](https://user-images.githubusercontent.com/62126380/80098484-eff40200-85a7-11ea-8aa2-875d61cc3e47.PNG)

- 하나의 값을 저장하기 위해 확보한 메모리 공간 (노란색 칸) 또는 메모리 공간을 식별 할 수 있는 이름

- 식별자는 고유해야 한다.(스코프 내에서 고유해야 한다.)

- 함수의 이름도 식별자이다.

- 선언하는 애들은 다 식별자구나~ 라고 생각하면 된다. 

  ``` js
  10 + 20 = 30
  ---------
  /* " 10 + 20 " 란 글자랑 "30" 이란 글자가 똑같지 생기지 않다. 
   하지만 식이 계산된다면 왼쪽과 오른쪽이 결국 같아진다. 
  이때 "같아진다" 라는 뜻을 "동치"라고 한다. 
  
  위 이미지로 말하자면 
  "result" 변수이름, 또는 식별자가 노란색칸을 가리키고 있다. 
  즉, "result" 라는 식별자와 노란색칸(메모리)는 동치다. 
  하여, 퉁쳐서 식별자는 고로 변수 라고 부를 수도 잇다. */
  ```

- 식별자는 어떤 값(ex:"30")이 저장되어있는 메모리 주소를 기억(저장)해야 한다.

- 식별자는 값(ex:"30")이 저장되어있는 메모리 주소와 연결관계가 있으므로, 해당 연결 정보도 저장되어야 한다.

  ===> 식별자는 메모리주소에 붙인 이름이라고 할수 있다. 

- 변수 이름, 즉 식별자는 가독성을 높여주는 효과를 준다.



## 식별자 네이밍 규칙

- 식별자의 이름을 지을때 규칙이 있다. 

  - 사용할수 있는 특수문자( 2개 ) :  "_" , "$"

  - 알파벳으로 시작하는 이름

  - 숫자로 식별자의 이름이 시작되면 안된다.

  - 식별자의 이름 중간에는 문자, 숫자, "_" , "$" 모두 사용할수 있다.  

  - SyntaxError(문법에러)를 주의하자.

  - `예약어`는 식별자로 사용할 수 없다.

    ```js
    예약어: 프로그래밍 언어에서 사용되고 있는 언어
    
    await / break / case / catch / class / const / continue / debugger / default / delete / do / else / enum 
    / export / extends / false / finally / for / function / if / implements* / import / in / Instanceof 
  / interface* / let* / new / null / package* / private* / protected* / public* / return / super 
    / static* / switch / this / throw / true / try / typeof / var / void / while / with / yield*
  ```
  
- 쉼표로 구분해서 하나의 문에서  여러개 한번에 선언할수 있지만 비추다. 
  
    ```js
    ex)
    var person, $elem, _name, first_name, val1;
    ```
  
- 영어 외의 언어로 써도 되지만 비추다. 
  
    ```js
    ex) 
    var 이름, なまえ;
    ```
  
- 두 단어를 쓸때는 스네이크케이스, 카멜케이스, 파스칼케이스, 헝가리언케이스, 전부 소문자, 전부 대문자만  사용 
  
    ```js
    var first_name;
    var firstName;
    var firstname;
    var FIRSTNAME;
    var FirstName;(파스칼 케이스)
    var strFirstName;(헝가리언케이스)
    var $elem = $('.myclass') (제이쿼리)
    ```
  
- 가독성 좋게, 명확한 의미로, 쉽게 이해할 수 있도록 이름을 지어야 한다.
  
    ```js
    var x = 3; ==> 명확한 의미 NG
    var d;  ==> 명확한 의미 NG
    var score = 100; ==> "100 이란 값이 점수를 뜻하는구나" OK
    var elapsedTimeIndays; ==> 경과시간,단위,날짜의 명확한의미 OK
    ```
  
    

## 변수 선언

<p style="color:red";> 들어가기에 앞서...</p>

1. JS 가 아닌 다른 언어들은 변수를 선언하면 반드시 초기화를 해야 한다. (이것은 약속이다.)

2. JS 는 인터프리터 언어라서 <u>**변수에 값을 할당하지 않으면**</u> 일반적으로는 오류가 발생하지만, JS를 만든 우리 브랜든 아이크씨는 친절한 분이시라 **<u>암묵적으로 오류가 나지 않게 JS를 만들어주셨다</u>** *<- 오 할렐루야*
3. 메모리셀에 한번 저장되었던 값을 초기화하지 않고 안 치운다면 값은 지워지지 않고 그대로 남는다.<br>이때 쓰였던 메모리셀은 <u>**무의미한 값(=쓰레기 값)**</u>을 가지게 되는것인데 이런 상황을 "초기화 하지 않은상황"이라고 할수있다.<br>하지만 JS는 친절한 언어이기때문에, <u>**초기화 하지 않아도 암묵적으로 초기화를 시켜준다**</u>. *<-THANKS JS*
4. **<u>변수를 사용하려면 반드시 선언이 필요하다.</u>**
5. <u>**변수를 선언할 때**</u>는 var,let,const,function, class... 같은 <u>**키워드(명령어)를 사용**</u>한다. 

---

### 변수 선언이란?

##### 예시1

JS엔진은 사람이 보기 편하게 만든 한줄 코드 " `var result` = 10 + 20 ; "을 두줄로 해석한다. 

![캡처49-1](https://user-images.githubusercontent.com/62126380/80062249-3e84aa80-856e-11ea-866d-5de314f30a74.PNG) 

- 변수를 생성하는 것

- 값을 저장하기 위한 메모리 공간을 확보하고 식별자와 확보된 메모리 공간의 주소를 연결하여 값을 저장할수 있도록 준비하는 것

- **<u>하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름</u>**

- 변수 선언단계 (변수 선언만 했을때의 상태)

  - 선언 단계 : 변수 이름(ex:"result")을 등록하여 JS엔진에 변수의 존재를 알린다

  - `초기화 단계` : 값을 저장하기 위한 메모리공간을 확보하고 변수 "result"에  암묵적으로 undefined를      할당한다.   

    - 쓰레기값이 나오는걸 방지하기 위해서 undefined 값을 할당하는 것이다.

    ===> 두 단계가 한방에 이루어진다. 

  ``` 
  초기화 단계
  
  1. 변수 선언 후 값을 할당하지 않으면 `undefined`라는 쓰레기값 만큼만 공간이 확보가 
     되어지는데 몇byte가 확보될지 모르니까 일단 무조건 암묵적으로 undefined 값이 
     들어갈만큼만 확보한 후에, undefined값이 할당되고 메모리셀이 초기화 된다.
  2. var 키워드로 변수는 선언이후 어떠한 값도 할당하지 않아도 undefined라는 값을 가진다.
  3. undefined값은 JS엔진 회사마다 byte 값이 다 다르기때문에 표준이 없으므로 
     undefined값의 크기는 모른다. 
  ```

  ##### 예시2

  ```javascript
  var result ;
  console.log(result);
  ----------------------
  변수를 선언만 했지, 변수에 값을 할당하지 않은 상태에 변수값을 참조한 상태이다.
  -> undefined 값(쓰레기값)이 나온 상태.
  ```

  ![캡처50](https://user-images.githubusercontent.com/62126380/80004386-37718400-84fd-11ea-87f9-a4b9fe7a96ff.PNG) 



## 변수문법

- 컴퓨터는 코드를 위에서 아래로 순차적으로 실행한다.

- 명령은 value(값), operator(연산자), expresstion(표현식), comment(주석)으로 구성되며 세미콜론(;)으로 '문'을 끝마친다. 

##### 예시1

![캡쳐51](https://user-images.githubusercontent.com/62126380/80062371-8acfea80-856e-11ea-9ff9-9a1e54934f68.png) 

``` javascript
var result ; 

변수 선언만 하고, 값을 할당하지 않은 상태 라서 -> undefined 값이 도출
----------------------------------------------------------------
var result ;
result = 10 + 20 ;

변수 선언도 하고, 변수에 값도 할당한 상태 -> 정상 작동
```

##### 예시2

![캡쳐52](https://user-images.githubusercontent.com/62126380/80063263-80165500-8570-11ea-88b6-892dc699f08a.png) 

```javascript
result = 10 + 20 ;

변수 선언을 안한 상태에 값을 할당했는데 왜 에러가 안나오죠?  
-> 친절한 JS씨라서 "너 선언하는거 까먹었지...? 어휴.. 내가 알아서 출력해줄게" 하고 자동으로 결과값을 도출해줌.  -> 정상 작동
------------------------------------------------------------------------------
①result = 10 + 20 ;
 var ②result ;

①result 랑 ②result 은 다른 result 다. 
왜냐? 친절한 JS씨가 "너 선언하는거 까먹었지...? 어휴.. 내가 알아서 출력해줄게" 하고 자동으로 ①result 값을 
벌써 출력을 이미 다 해줬는데 또 ②result 를 선언한다. 이건 중복이다. 
그래서 ①result 값을 지워버리고 다른 ②result 값이 새로 생겨버린 상태라서
-> undefined 값이 도출 
```



## 레퍼런스 에러(참조 에러)

<p style="color:red";> 들어가기에 앞서...</p>

1. 변수 참조( "cosole.log(~)" ): 변수의 값을 가지고 와서 출력해달라는 명령

   ```javascript
   ex)
   var result ;
   console.log(result);
   ----------------------
   선언한 변수 "result" 값을 출력해줘!!!
   -> 결과 : 할당한 값이 없으므로 undefined 값 도출
   ```

---

레퍼런스 에러 : 선언된적이 없는 변수를 참조하려고 할때 발생하는 에러

##### 예시1 (레퍼런스 에러 발생)

```javascript
var result = 10 + 20 ;
console.log(score)
------------------------
"result" 라는 변수를 선언했는데, 참조한 변수는 "score" 이란 변수라서 레퍼런스 에러 발생
```

![캡쳐53](https://user-images.githubusercontent.com/62126380/80066296-a0491280-8576-11ea-8a51-caebc85666ea.PNG) 

##### 예시2(레퍼런스 에러 X)

``` javascript
1. var result = 10 + 20 ;
   console.log(result) ;
-----------------------------
"result" 라는 변수를 선언 + 변수에 값을 할당 + 참조한 변수 "result"로, 선언한 변수를 참조
-> 에러 없이 값이 3으로 정상 도출

2. console.log(result) ;
   var result = 10 + 20 ;
-----------------------------
-> 결과 : undefined값 도출(레퍼런스 에러X)

위 코드는 변수 호이스팅으로 인해(호이스팅: 아래 설명 참고) 변수 선언문부터 읽히고, 
그 다음에 콘솔로그가 읽힌다.(아래처럼) 
var result ;
console.log(result);
근데 이 상태는 아직 "result"값이 할당되어있지 않은 상태라서 undefined 값이 도출된다.
그 후에 result = 10 + 20 ; 이란 "문"이 읽히는데, 이 "문"에는 어떠한 행위를 해달라는
명령어가 없기때문에 실행되는 것은 아무것도 없다. 그래서 결국 결과값으로 undefined값이 
도출되는 것이다.
제대로된 결과값을 도출하려면 아래처럼 코딩하면 된다.

console.log(result);
var result = 10 + 20 ;
console.log(result);
*"값의 재할당"과 관련있는 코드이니 아래 "값의 재할당"부분도 참고하자.
```



## 변수 호이스팅

- 런타임(run time) : 코드들이 위에서 아래로 순차적으로 읽히는 과정

- 변수 호이스팅 : 다른 언어들과 다르게, JS엔진은 런타임 이전에 <u>**변수 선언문**</u>이 다른 코드들보다 제일 먼저 평가되어 <u>**제일 먼저 실행**</u>되는 것  
- 변수 호이스팅 발생 이유 : 런타임 이전에 변수 선언을 처리, 초기화를 하기 때문이다. 

##### 예시1

![캡쳐54](https://user-images.githubusercontent.com/62126380/80074138-b14c5080-8583-11ea-9c64-82ce3b4d5b45.PNG) 

```javascript
결과:

★ console.log(score) ;
☆ var result ;
-----------------------------
1. ☆ 코드 평가 -> 2. ★ 코드 실행 -> 레퍼런스 에러는 아니지만 undefinde값이 할당.
```

1. 코드 평가 : JS엔진은 다른언어와 다른점이 있는데, 코드를 순차적으로 읽어내려가서 실행을 하기 이전에 <br>실행을 하가 위해  코드평가가 먼저 이루어진다.
2. 코드 실행 : JS엔진은 코드 평가 과정에서 변수선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 코드에서 먼저 찾아서 변수 선언문을 제일 먼저 실행한다.

위 코드처럼 변수 참조가 먼저 되고 변수 선언이 그 다음으로 되어도 JS엔진은 실상 위 예시로는 ☆->★ 순서로     코드를 해석한다. 
위 코드의 현재 상태는 변수 선언 다음에 변수 참조가 이루어진 상태인데, 현 상태는 아직 변수값에 값이 할당되어
있지 않은 상태라서 undefined 값이 할당되어 지는 것이다. 



## 값의 할당

&#128205; &#128205; 제일 먼저 변수 호이스팅을 유의하자.

##### 예시1

![캡쳐107](https://user-images.githubusercontent.com/62126380/81918580-9f554f00-9611-11ea-934c-701934022ee8.PNG)  

```javascript
① console.log(score);
② var score = 80 ;
③ console.log(score);
---------------------------
-> 결과 : 80 값을 도출
```

① : 변수 score의 값을 출력해줘! -> 아직 변수 선언도 안하고, 값을 할당하지도 않았기 때문에 **undefined값 도출**

①,② : JS엔진이 ② 가 1줄로 보이지만 두줄로 해석한 후, 변수 호이스팅이 실행된다.

실상, 아래 이미지처럼 실행되어 **undefined 값 도출**

![캡쳐55](https://user-images.githubusercontent.com/62126380/80091542-35aacd80-859c-11ea-96be-e34e0017510a.PNG) 

①,②,③ : undefined 값이 도출된 상황이지만 이미 변수 선언 완료 + 값의 할당도 완료되어서 <br>				**정상적인 80이란 값이 도출**

---

##  값의 재할당

- 기존에 할당이 되어져있는 변수에 다른 값을 다시 할당하는 행위
- 가급적이면, 왠만해서는 재할당을 안하는게 좋다. 
- 재할당을 하면 반드시 메모리 주소가 바뀌는거라서, 새로운 공간을 만들어서 포인팅을 바꾼다. 
- 재할당을 할수 없는(재할당이 금지된) 변수는 변수라고 하지 않고 상수(const)라고 한다.
  - 재할당이 금지되기때문에 처음값을 바꿀 방법은 객체타입의 경우에만 있다.

##### 예시1

![캡쳐57](https://user-images.githubusercontent.com/62126380/80106335-b1b10f80-85b4-11ea-961b-3724ed0a2991.PNG) 

![캡쳐58](https://user-images.githubusercontent.com/62126380/80107358-ef626800-85b5-11ea-8688-d809c7d08c48.PNG) 

```js
① 변수 선언으로 인해 변수 "score"가 가리키고 있던 undefined 값은
② "80"이란 값을 할당함으로 인해 폐지(해방)되어 메모리가 해제 되고
③ "90"이란 값을 재할당함으로 인해 "80"이란 값이 저장되었던것도 폐지(해방)가 되어 메모리가 해제 된다.
```

==> 폐지(해방)되어 메모리가 해제가 된 값들은 가비지 컬렉터(garbage collector)가 메모리들을 훑다가<br>"어~? 이 메모리셀의 값은 더이상 필요없네?? 어떠한 변수도 이 메모리셀의 값을 가리키고 있지 않네??" <br> "그럼 이제 이 메모리(ex: undefined) 공간 써도 되~ 얘도(ex:80) 써도 되! 하지만 얘는(ex: "90") 쓰면 안되~!!"라고 재사용해도 되는 쓰레기값에 대해 판단한다.   

가비지 컬렉터가 메모리셀 공간영역의 재사용에 대해 판단을 하고, 재사용이 가능하다면 그 셀에는 다른 값들로  채워질수 있다. 

하지만 여기서 유의해야 할 점은 위의 이미지대로, 값의 할당과 값의 재할당이 이뤄지면 값으로 채워졌던<br> 메모리셀 의 값들이 지워지고 거기에 **<u>새로운 값들이 할당되는것이 아니라, 새로운 다른 메모리셀에 값이 엎어져서 채워지는 것이다.</u>** 



## 값의 교환

값을 교환(교체)하는 방법을 알아보자

예시) 변수 x 의 값과 변수 y 의 값을 바꿔라.

![캡쳐62](https://user-images.githubusercontent.com/62126380/80273633-e6d17500-870e-11ea-8f28-62db495ac371.PNG) 

해석) console.log( x, y )  -> ( 2, 1)

![캡쳐63](https://user-images.githubusercontent.com/62126380/80275359-a62c2880-871b-11ea-81b0-a50dc85a716d.PNG) 


