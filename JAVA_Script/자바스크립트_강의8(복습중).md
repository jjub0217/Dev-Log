# 프로퍼티 어트리뷰트

- 내부 슬롯 
  - JS의 엔진을 구현하는 알고리즘을 설명하기 위해 ECMAScript에서 사용하는 의사 프로퍼티이다.
  - 감춰진 프로퍼티  라고 말할 수도 있다.
- 내부 메소드 : JS의 엔진을 구현하는 알고리즘을 설명하기 위해 ECMAScript에서 사용하는 의사 메소드이다. 

내부 슬롯과 내부 메소드는 [[ ]] 으로 감싸서 나타낸다.

----------

내부 슬롯과 내부 메소드는 원래 외부로 공개된 객체의 프로퍼티와 메소드가 아니다. 그래서 직접적으로 접근하거나 호출 할 수 있는 방법이 없지만, 간접적으로는 접근할 수 있다. 

1. [[prototype]] 이란 내부 슬롯에는 원래 직접적으로 접근하는것은 불가능하지만, _ _ prototype _ _이라는 것으로 간접적으로 접근이 가능하다.

   ```js
   const o ={};
   
   o. [[prototype]] // SyntaxError <- [[prototype]]이라는 내부 슬롯에 직접적으로 접근했더니 에러가 났다.
   o.__protot__ // object.prototype <- [[prototypr]] 이라는 내부 슬롯에 __proto__ 라는 것을 사용하여 
   간접적으로 점근한 상태이다. 에러가 안난걸 보니 정상적으로 동작하는것이다.
   ```

2. Object.getOwnPropertyDescript 라는 메소드를 사용하여 `프로퍼티 어트리뷰트` 라는 내부슬롯에 간접적으로 접근이 가능하며, 접근을 하면 프로퍼티 디스크립터 객체를 반환한다.

   - Object.getOwnPropertyDescript 라는 메소드를 호출하면, 첫번째 매개변수에는 객체의 참조를 전달하고, 두번째 매개변수에는 프로퍼티 키를 문자열로 전달한다.

   > __프로퍼티 어트리뷰트__(=내부 슬롯)
   >
   > 프로퍼티의 상태를 나타내는 것이다. 
   >
   > ① [[value]] : 프로퍼티의 값을 나타낸다.
   >
   > ② [[writable]] : 값의 갱신이 가능한지 여부를 나타낸다.(value 의 값을 쓸수 있느냐?)
   >
   > ③ [[enumerable]] : 열거가 가능한지 여부를 나타낸다.
   >
   > - for in 문으로 열거
   > - object 라는 객체의 keys로 열거 <br>(객체의 keys : 프로퍼티의 키들을 뽑아서 배열로 리턴해준다.)

   >④ [[configurable]] : 재정의가 가능한지 여부를 나타낸다.

   > > __프로퍼티 디스크립터 객체__
   > >
   > > 프로퍼티 어트리뷰트들을 모은 객체

   ```js
   const person = {
       name: 'Lee'
   };
   console.log(object.getOwnPropertyDescriptor(person,'name');
   // {value: "Lee", writable: true, enumerable: true, configurable: true}
   // value: "Lee" <- 프로퍼티의 값인 'Lee'를 문자열로 반환했다.
   // writable: true < 
               
   ```

   

   





프로퍼티라는게 단순하지는 않단 얘기다. 자스엔진 내부에서는 프로퍼티가 어떻게 관리되고 잇다는거지?

프로퍼티 자체가 객체다. 내부 슬롯이 있잖아. 내부 슬롯을 프로퍼티 키라고 생각하면 된다. .... 하나의 객체로 다뤄진다. 그 ... 집합체를 객체라고 한다. 



우리가 자스엔진을 만든다고 생각해봐라. 어떤 자료구조를 만들어야 하잖아. 지금까지 살펴본건 데이터 프로퍼티다. 

프로퍼티 처럼 생긴 함수.

예를 들어서 

![image-20200504142710215](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504142710215.png) 

데이터 프로퍼티 : 벨류가 있는 놈이다. 근데 접근자 프로퍼티는 벨류가 없고, 벨류 대신 겟 이란 애랑 셋 이라는 애가 있다. 겟 셋 다 프로퍼티 어트리뷰트인데 둘다 함수를 가지고 있다. 



겟셋 없다고 생각하면 fullName 이 똑같다. 겟셋 두개가 게터세터이다. 

프로퍼티는 두가지 용도로 쓴다. 참조할때 쓴다. 프로퍼티로 값을 참조할수 잇나? 어케 참조하나? 펄슨.펄스트 네임 . 이건 참조다. 가지고 오는거다. 즉. 겟하는 것이다.

펄슨.펄트스 네임 = 어쩌고 이게 셋이다. 

접근자 프로퍼티는 .... 만들어준다. 

접근자 프로퍼티는 4개의 어트리뷰트를 갖고 잇다.

1. 겟 : 게터는 결국 리턴이 반드시 있어야 한다
2. 셋 : 리턴이 반드시 없어햐 한다.
3. 이뉴머러블
4. 컨피규러벌

오운(Own): 상속은 제외하고...... 것만.

 .... 프로퍼티 디스크립터 객체도 있다.

디파인 프로퍼티도, 데이터 프로퍼티를 만드는것이 가능하다는 것을 알앗고..... 만들수 잇는걸 알앗다.



## 객체 변경 방지

3가지 메소드가 있다. 

오브젝트. 프리즈

이런게 있다. 만 알고 넘어갑시다.

지금은 몰라도 됨

객체를 동결한다. 왜 객체를 얼릴까? 메소드를 통해서 객체를 얼리면 모든 프로퍼티가 리드온니가 된다.

왜 얼릴까? 원시값처럼 주소가 바뀌지 않는 상황에서... 객체를 원시값처럼 쓰고자 할때에는 오브젝트.프리즈를 통해서... 

객체를 바꾸려면 어케 해야 하나? 딥카피를 해야 한다. 객체를 새롭게 처음부터 만들어야 한다.

---



# 생성자 함수에 의한 객체 생성

다른 언어들 얘기를 좀 하면, 객체 지향언어들 얘기를 하면 그런 언어들은 기본적으로 객체를 만들때 리터럴로 만드는 방법이 없다 클래스라는걸 선정의하고 객체 만들기 전에 그 객체에 클래스라는 걸 미리 정의한다. 그 다음에 클래스를 뉴 연산자와 함께 호출한다. 그럼 객체가 만들어진다. 그 객체를 인스턴스라고 한다. 그러면 왜 그 언어들은 그런식으로 할까?

왜 자스는 객체 리터럴이란 방법을 제공할까? 이유가 있다. 그럼 여태까지 우리가 클래스라는 개념 모른다치고 객체 리터럴 쓰면서 느끼는게 있나? 객체 리터럴이 어떤 느낌이냐? 엄청 편한거다. 객체를 런타임에 만들수 있다. 클래스 함수를 미리 만들어놓고 ... 이게 클래스인데 얘네는 런타임에 만들수 없다. 



객체 리터럴은 무슨 문제점이 있지? 객체가 여러개 만들어질때 객체 리터럴이 조금 거시기 해. 왜냐면 첨부터 다 써야 하니까. 그리고 객체는 메소드 갖고 잇는데, 객체 여러개 잇을때 메소드는 거의 안바뀌지만 상태 데이터만 바뀐다. 그러면 우리가 100개의 객체 리터럴 만드는 것은 불합리하다. 

객체를 만들어내는 함수를 만드는 것이다. 그래서 그 함수를 호출하면 객체가 툭툭툭 만들어진다. 

그러면 심플하게 만들어지는것이다. 

따라서 객체는 만드는 방법이 여러개 있다.

객체 리터럴로만 만드는게 아니다.

객체 리터럴로 만드는게 있고 오브젝트 생성자 함수 로 만드는것도 있다. 



## 오브젝트 생성자 함수

아까 오브젝트. 어쩌고 저쩌고.

근데 얘는 정체가 뭐다? 함수다. 함수인데, 생성자 라는 말이 붙으면 얘의 존재 목적이 뭐냐면 객체를 만들어내는 목적을 가지고 잇는 함수다. 생성자 함수는 어케 호출하냐면 뉴 라는 연산자를 앞에 꼭 붙여줘야 한다. 문법이다. 붙여주고 안붙여주고 큰 차이가 있다. 자스는 뉴 안붙여줘도 에러가 안난다. 

![image-20200504152548503](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504152548503.png) 

오브젝트는 전역객체에 있다 전역객체는 브라우저가 켜지자마자 빌트인 객체가 주루룩 있다. 

우리가 코딩하는 시점에는 반드시 오브젝트 가 있다. 생성자 함수가 오브젝트인거 보니까 얘는 객체를 만드는 애다 . 근데 인수가 없으면 빈객체를 만든다. 빈 객체 만들고 프로퍼티 추가해주면 객체 만들수 있다. 

## 생성자 함수

![image-20200504152722348](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504152722348.png) 

플러스 빈문자열 하는게 좋다.

단항 연산자를...

느낌표를 두개 붙인다. 

스트링 앞에 뉴를 하면 문자열 객체를 만든다. 문자열도 객체가 있다는 말이다.

숫자 객체, 불리언 객체라는게 있다는 말이다. 

함수도 펑션 생성자 함수를 만들수도 있다. 이건 클로저를 안만들고 내부동작이 틀려서 쓰지 마라. 



## 생성자 함수 

### 객체 리터럴에 의한 객체 생성 방식의 문제점

![image-20200504152937725](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504152937725.png) 

원을 나타내는것이다. 

우리가 관리하고 싶은건 반지름이다. 반지름을 관리하겟다. 메소드가 하나있다. 비스무리한 객체를 또 만드려고 한다. 반지름만 다르다 

이 메소드는 뭐에 대한 행동이죠? 대부분 프로퍼티에 대한 행동이다. 얘를 조작하는 애다. 위의 객체는 고정값을 갖고 있다. 그래서 리터럴을 쓸때 고정값을 ..... 똑같은걸 써줘야 한다는 얘기다. 

프로퍼티 구좌가 똑같다면... 이게 생성자 함수라고 한다. 



멍멍개를 본적있나? 우리가 생각하는 개는 다 틀리다. 그럼 개가 뭔데? 다 틀리다. 그러면 개의이상이 있는거다. 개의 원형이 잇는거다. 예를 들어서 개는 다 다른가? 특징들이 있을거 아냐. 짓는 소리가 멍멍해야해. 그리고 색깔은 어떤 색이다. 그런것들을 미리 정할수 있을까 없을까 

예를 들어서 

털색깔 , 짓는 행동, 다리의 개수, 꼬랑지가 있다없다 트루 풜스. 그래서 걔를 클래스로 만드는거다. 

틀을 만드는것이다./ 그럼 개의 실체는 집에 있는 개일수도 있고.. 그 틀로 만들어진 실체다. 

클래스를 통해서 만들어진 애들을 인스턴스라고 한다. 

실체를 인스턴스라고 한다. 여기서 클래스라고 하는것은 클래스 기반이라고 하고 자스는 생성자 함수라고 한다. 

자 그러면 우리 사람의 이데아를 만들어보자.

생성자 함수로 만든것이다 라는걸 알리기 위해 함수 이름의 첫머리를 대문자로 한다. 

여기서 this 는 문맥에 따라서 가리키는 값이 달라진다. 그 문맥이 6가지 정도 된다. 

오늘은 3가지를 배울거다. 

생성자 함수 내부안에서의 디스는 이 생성자 함수가 만들어낼 인스턴스를 가리킨다. 

생성자 함수 내부안에서의 디스는 얘가 인스턴스를 만들거 아냐, 그 인스턴스를 가리킨다. 

미래에 만들어낼 인스턴스를 가리킨다. 디스 뒤에 프로퍼티를 쓴다. 인간세상은 다 이씨면 디스.네임 뒤에 'Lee' 라고 써야 하는 것이다. 

뉴를 붙히면 언디파인드, 띄면.....

뉴를 붙히면 생성자 함수로서 호출했다는 뜻이다. 

그러면 펄슨을 생성자 함수가 아닌 일반함수로서도 호출할수 있다는 얘기다. 



중의적인 의미를 가지고 잇으면 반드시 실수를 한다. 

실수를 하니까 방어코드가 있어야 한다. 얘가 뉴와 함께 호출되엇는지 알아차려야 한다. 

메소드는 프로퍼리를 조작하거나 동작하는 애다. 어케 접근할래?



객체 리터럴를 내부에서 쓸때 호출할때 쩜을 썻잖아. 쩜 앞에 잇는거다. 

함수몸체는 호출될때 실행된다. 호출될때마다 실행된다. 호출될때마다 만들어진다. 그니까 모든 인스턴스들은 내용이 같은 쎄이하이들을 중복소유한다. 방법은 이 함수를 펄슨의 부모에게 준다. 상속으로 한다. 부모가 저거 하나 가지고 잇으면 자식들이 다 갖는다. 



## 생성자 함수에 의한 객체 생성 방식의 장점

여러개 만들어야 한다. 몇개? 하여간 여러개. 그렇단 얘기죠. 

![image-20200504161723182](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504161723182.png) 

여기서 디스는 누굴 가리킬까요, 외우세요. 생성자 함수 내부에서 디스는 누구다? 생성자 함수가 생성할 인스턴스다. 객체 리터럴 내부에 메소드 내부에서 사용한 디스는 그 메소드를 호출할 객체다. 그 메소드가 소속한 객체가 아니고

일반함수에서 디스를 쓸수 있을까? 일반함수라는 것은 기존에 우리가 호출한거. 쓸수 있을까? 왜 있지?

원래 쓰면 안된다. 디스는 왜 쓰지? 디스는 원래 객체지향에서 의미가 있는거다.

일반함수에서 디스 왜써? 의미 없는거다. 근데 자스는 디스가 있어야 함.

일반함수에서 디스는 무조건 전역객체다. 

![image-20200504161938329](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504161938329.png) 

디스가 가리키는 값이 중요하다

우리가 함수라고 불리는 것이 일반 함수로서 호출될때가 있고 메소드로서 호출될때가 있고 생성자 함수로서 호출될때 장면이 잇다. 

![image-20200504162106833](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504162106833.png) 

위에 보면 일반함수같다. 여기서 디스는 전역객체다.

![image-20200504162204425](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504162204425.png) 

생성자 함수로서 호출했다는 것은 뉴와 함께 호출했다는 것이다.

![image-20200504162553404](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504162553404.png)

그럼 우리가 명시적으로 리턴하면 어케 될까? 그래서 어떤 객체를 리턴했다고 하면 우리가 명시적으로 리턴한 객체가 된다. 그러니까 주의해야 한다. 

원시값을 리턴하면 무시당한다.



## 내부 메소드

new : 연산자다.

얘 뒤에는, 우항에는 함수가 온다. 생성자 함수라는 문법이 있나요? 생성자 함수라는 문법을 지키면 생긴다는 식의 문법은 없다. ... 로도 될수 있다.

따라서 일반함수는 일반함수라는건 함수만드는거  몇가지? 

펑션 푸()

콘스트 푸 = 펑션() {}

위 두개는 생성자함수도, .. 도 호출할수 있다.

콘스트 푸 = ( )=> {})

위 하나는 생성자 함수로 호출 못한다.



우리가 일반적으로 메소드라는거. 객체 지향언어에서 다 메소드라고 한다.

우리가 메소드라고 통상 부르는거랑 에크마 에서 부르는 메소드는 다른거다. 

에크마에서 메소드라고 부르는 애는 단하나. 메소드 축햑형. (푸 () {}) 얘네만 문법상 메소드라고 한다.

에크마에서 메소드라고 지칭하는건 생성자 함수로 호출할수 없다. 메소드를 왜 생성자 함수로 호출하냐고~ 당연한거다. 

함수들의 종류가 있다.

생성자 함수로 호출할수 있고 없는 함수가 있다.

생성자 함수로서 호출 가능한거 함수 선언문, 함수 표현식

근데 생성자 함수로서 호출 안되는건 다 이엑스 식스 문법이다. 메소드랑 화살표함수. 

함수라는게 기본적으로 어떤 특성을 갖고 있어야 하나? 함수도 객체라매. 객체랑 함수의 차이는?

객체가 함수보다 큰 개념이다.

그러면 함수는 객체의 특성을 모두 갖고 잇을까?  싹 다 갖고 있다. 

그런데 함수만의 특징을 갖고잇다. 그 특징은 쉽게 말해서 호출할수 있다.

객체는 호출할수 없다

함수를 호출하면 함수가 내부적으로 [[call]] [[construct]] 얘네 내부 메소드다

함수 객체를 가리키는 식별자 ( )

위 두개를 호출하는거다. 내부동작이. 

어쩔때 콜, 어쩔대 콘스트럭 호출하느냐.

함수가 함수 선언문이랑 함수 표현식이 잇는데 [[콜]] [[콘스트럭트]] 둘다 가능하다. 둘다 가지고 있다. 

근데 콘스트럭트 화살표함수는 콜을 갖고잇다. 콜을 안갖고잇으면 함수가 아니다. 

근데 콘스트럭트는 있는애 가 잇고 없는 애가 있다. 없는 애를 논 컨스트럭트 , 있는애를 콘스트럭트라고 한다. 

![image-20200504163840394](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504163840394.png) 

위의 메소드는 콘스트럭트다. 뉴와 함께 호출할수 있다. 

그러면 콜 메소드도 갖고 잇고 내부에서 콘스트럭트고 갖고 있어서 함구 객체가 크다는 얘기다.

이렇게 저렇게 호출할수도 있다. 쓸데없는 기능을 갖고잇다는 얘기다. 

그래서 비효율적이다. 함수라는게 생성자, 일반 함수로도 호출할수 잇다. 이게 생성자 함수인지 일반 함수인지 파스칼케이스로 구분해서 알려줘라. 

함수를 만들때 파스칼케이스로 만들어줬는데 왜 생성자 함수로 호출 안했어? 라고 하는게 아니라 그 버튼을 만들지 말았어야지.

![image-20200504164417321](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504164417321.png) 

뉴를 안붙이는 경우 : 일반함수로 호출 한거. 그냥 일반함수 하듯이 선언문 먼저 찾는다. 



## 뉴 타겟

예를 들어서 

![image-20200504165909203](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504165909203.png) 



뉴.타겟 : 함수 객체를 가리키고 있다. 그래서 빈객체가 아니라는거다. 뉴와 함께 호출하지 않으면 언디파인드가 된다. 



![image-20200504170157078](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504170157078.png) 









방어코드가 있을까 없을까. 있다. 오브젝트도  뉴 오브젝트에서 빈객체 만들수 있었죠. 

펑션 생성자 함수도 ... 

문제는 얘네들이야.  빌트인 생성자 함수(Object, String, Number, Boolean, Function, Array, Date, RegExp, Promise 등) 얘네들. 

행동들이 일관되자 않다. 

![image-20200504170522844](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504170522844.png) 

위처럼 띄지 말고 붙여줘야 한다. 



디스를 안보는 메소드를 정적 메소드라고 한다.



예습 :  18, 19

---

---

---

# 퀴즈퀴즈

이진검색은 반드시 정렬이 되었다고 가정하고 시작.

꼭 포문으로 안해도 된다. while문 써도 된다. 

반띵반띵 해야 한다. 스타트와 엔드가 같아진다. 



1. 타겟이 6. 

2. 타겟이 배열에 요소로 존재하는지 확인
3. 존재하면 해당 인덱스를 반환
4. 존재 안하면 -1을 반환

```javascript
function binarySearch(array, target) {

}

console.log(binarySearch([1, 2, 3, 4, 5, 6], 1)); // 0
console.log(binarySearch([1, 2, 3, 4, 5, 6], 3)); // 2
console.log(binarySearch([1, 2, 3, 4, 5, 6], 5)); // 4
console.log(binarySearch([1, 2, 3, 4, 5, 6], 6)); // 5
console.log(binarySearch([1, 2, 3, 4, 5, 6], -1)); // -1
console.log(binarySearch([1, 2, 3, 4, 5, 6], 0)); // -1
console.log(binarySearch([1, 2, 3, 4, 5, 6], 7)); // -1
```

```javascript
function binarySerach(array, target) {
while (array[centerIndex] !== condition)     
}
```

































