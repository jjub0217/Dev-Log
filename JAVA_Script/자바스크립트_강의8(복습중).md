# 프로퍼티 어트리뷰트

- 내부 슬롯 
  - JS의 엔진을 구현하는 알고리즘을 설명하기 위해 ECMAScript에서 사용하는 의사 프로퍼티이다.
  - 감춰진 프로퍼티  라고 말할 수도 있다.
- 내부 메소드 : JS의 엔진을 구현하는 알고리즘을 설명하기 위해 ECMAScript에서 사용하는 의사 메소드이다. 

내부 슬롯과 내부 메소드는 [[ ]] 으로 감싸서 나타낸다.

----------

내부 슬롯과 내부 메소드는 원래 외부로 공개된 객체의 프로퍼티와 메소드가 아니다. 그래서 직접적으로 접근하거나 호출 할 수 있는 방법이 없지만, 간접적으로는 접근할 수 있다. 

1. [[prototype]] 이란 내부 슬롯에는 원래 직접적으로 접근하는것은 불가능하지만, _ _ prototype _ _이라는 것으로 간접적으로 접근이 가능하다.(모든 객체는 [[prototype]]) 이란 내부슬롯을 가지고있다)

   ```js
   const o ={};
   
   o. [[prototype]] // SyntaxError <- [[prototype]]이라는 내부 슬롯에 직접적으로 접근했더니 에러가 났다.
   o.__protot__ // object.prototype <- [[prototypr]] 이라는 내부 슬롯에 __proto__ 라는 것을 사용하여 
   간접적으로 점근한 상태이다. 에러가 안난걸 보니 정상적으로 동작하는것이다.
   ```

2. Object.getOwnPropertyDescript 라는 메소드를 사용하여 `프로퍼티 어트리뷰트` 라는 내부슬롯에 간접적으로 접근이 가능하며, 접근을 하면 프로퍼티 디스크립터 객체를 반환한다.

   - Object.getOwnPropertyDescript 라는 메소드를 호출하면, 첫번째 매개변수에는 객체의 참조를 전달하고, 두번째 매개변수에는 프로퍼티 키를 문자열로 전달한다.

   > __데이터 프로퍼티 어트리뷰트__(=내부 슬롯)
   >
   > 프로퍼티의 상태를 나타내는 것이다. 
   >
   > ① [[Value]] : 프로퍼티의 값을 나타낸다.
   >
   > - 프로퍼티 키를 통해 프로퍼티 값을 변경하면 [[Value]]에 값을 재할당한다.
   > - 프로퍼티가 업승면 프로퍼티를 동적 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다. 
   >
   > ② [[Writable]] : 값의 갱신이 가능한지, 프로퍼티 값의 변경이 가능한지 여부를 나타낸다.<br>     (Value 의 값을 쓸수 있느냐?)
   >
   > - [[Writable]] 값이 false인 경우에는 [[Value]] 의 값을 변경할수 없는 readOnly한 프로퍼티가 된다.
   > - 단, [[Writable]]이 true면 [[Value]] 의 변경과   [[Writable]]을 false로 변경이 가능하다.
   >
   > ③ [[Enumerable]] : 열거가 가능한지 여부를 나타낸다. 
   >
   > - for in 문으로 열거
   > - object 라는 객체의 keys로 열거 <br>(객체의 keys : 프로퍼티의 키들을 뽑아서 배열로 리턴해준다.)
   > - [[Enumerable]] 의 값이 false인 경우에는 for in문이나 Object.keys 메소드 등으로 열거할수 없다.
   >
   > ④ [[Configurable]] : 재정의가 가능한지 여부를 나타낸다.
   >
   > - [[Configurable]]값이 false인 경우에는, 해당 프로퍼티의 삭제, 값의 변경, 프로터피 재정의가 금지된다.
   >
   > > __프로퍼티 디스크립터 객체__
   > >
   > > 프로퍼티 어트리뷰트들을 모은 객체

   ```js
   const person = {
       name: 'Lee'
   };
   console.log(object.getOwnPropertyDescriptor(person,'name');
   // {value: "Lee", writable: true, enumerable: true, configurable: true}
   -----------------------------------------------------------------
   // value: "Lee" <- 프로퍼티의 값인 'Lee'를 문자열로 반환했다.
   // writable: true <- 객체 리터럴로 프로퍼티를 만들면 내부슬롯의 값은 기본적으로 true로 세팅이 된다. 
   //enumerable: true <- 객체 리터럴로 프로퍼티를 만들면 내부슬롯의 값은 기본적으로 true로 세팅이 된다. 
   //confiurable: true <- 객체 리터럴로 프로퍼티를 만들면 내부슬롯의 값은 기본적으로 true로 세팅이 된다.             
   ```

즉, 프로퍼티에는 프로퍼티 어트리뷰트라는 내부슬롯이 있고, 그렇기 때문에 프로퍼티 자체가 객체라는 뜻이다. <br>또한, 모든 객체는 [[Prototype] 이란 내부슬롯을 가지고있는 것이고, [[Value]], [[Writable]], [[Enumarable]]. [[Configuarable]], [[Prototype]] 각각의 내부슬롯을 __프로퍼티 키__라고 생각하면 된다. 



## 데이터 프로퍼티와 접근자 프로퍼티

### 데이터 프로퍼티

<u>" 키와 값으로 구성된 __일반적인 프로퍼티__ "</u>

- 프로퍼티가 생성될 때 [[Value]]의 값은 프로퍼티 값으로 초기화가 되며, [[writable]]과  [[Enumarable]], [[Configuarable]] 의 기본값인 true 로 초기화된다. <br>이는, 프로퍼티를 동적 추가하여도 마찬가지다.

### 접근자 프로퍼티(_ _ proto _ _)

<u>" [[Value]]을 가지고 있지 않고, 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 __접근자 함수로 구성된 프로퍼티__"</u>

__프로퍼티 처럼 생긴 함수__

① [[Get]] : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수

- 접근자 프로터피 키로 프로퍼티 값에 __접근하면__ `getter 함수`가 호출이 되고, 그 결과가 프로퍼티 값으로 반환된다. 

- 반드시 리턴을 해야 한다.

- 인수를 전달할 방법이 없기때문에 매개변수를 쓸 이유가 없다. 

  > __getter 함수__
  >
  > [[Get]] 이라고 하는 프로퍼티 어트리뷰트의 값인 함수 

```js
get fullname(){
    return `${this.firstName} ${this.lastName}`;
}
console.log(person.fullName);
```

② [[Set]] : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수

- 접근자 프로터피 키로 프로퍼티 값에 __저장하면__ setter 함수가 호출이 되고, 그 결과가 프로퍼티 값으로 반환된다. (프로퍼티 값을 할당하면 `setter 함수`가 호출이 된다.)

- 반드시 리턴이 없어야 한다.

- 반드시 인수를 받아야 하는데, 반드시 1개만 받아야 한다.

  >__setter 함수__
  >
  >[[Set]] 이라고 하는 프로퍼티 어트리뷰트의 값

```js
set fullName(name){
    [this.first, this.lastName] = name.split(' ');
}
person.fullName = 'Heegun Lee';
```

③ [[Enumerable]] : 열거가 가능한지 여부를 나타낸다. 

- for in 문으로 열거
- object 라는 객체의 keys로 열거 <br>(객체의 keys : 프로퍼티의 키들을 뽑아서 배열로 리턴해준다.)
- [[Enumerable]] 의 값이 false인 경우에는 for in문이나 Object.keys 메소드 등으로 열거할수 없다.

④ [[Configurable]] : 재정의가 가능한지 여부를 나타낸다.

- [[Configurable]]값이 false인 경우에는, 해당 프로퍼티의 삭제, 값의 변경이 금지된다.



예시 코드)

![캡쳐107](https://user-images.githubusercontent.com/62126380/82121912-652fad00-97cb-11ea-97a8-74dcf8e5ab73.PNG) 

![캡쳐108](https://user-images.githubusercontent.com/62126380/82121942-960fe200-97cb-11ea-9e0b-7cc98fc63023.PNG)   

 

** getOwnPropertyDecriptor 함수로 데이터 프로퍼티만 가져올수 있는게 아니라 <br>접근자 프로퍼티도 가져올수 있다.

```js
Object getOwnPropertyDecriptor(Object.prototype, '__proto__');
// {get: ƒ, set: ƒ, enumerable: true, configuarable: true}

Object.getOwnPropertyDecriptor(function(){}, 'prototype');
//  {value: {...}, writable: true, enumerable: true, configuarable: true}
```



## 프로퍼티 정의

### 프로퍼티 정의

- __새로운 프로퍼티를 추가__ 하면서 __프로퍼티 어트리뷰트를 명시적으로 정의__ 하거나,<br>기존 프로퍼티의 프로퍼티 어트리뷰트를 __재정의__ 하는 것을 말한다.
- __Object.defineProperty 메소드__를 사용하면 __프로퍼티의 어트리뷰트를 정의__ 할수 있다.
- Object.defineProperty 메소드는 한번에 하나의 프로퍼티만 정의할수 있지만,<br>Object.defineProperties 메소느는 여러개의 프로퍼티를 한번에 정의 할수 있다.

---

#### 데이터 프로퍼티 정의

![캡쳐109](https://user-images.githubusercontent.com/62126380/82138066-7e326f80-9858-11ea-8824-af081055a416.PNG)

- Object.defineProperty 메소드로 프로퍼티를 정의할때 프로퍼티 디스크립터 객체에서 일부의<br>프로퍼티를 생략하면 프로퍼티의 기본값이 적용된다.

  [[Value]] 의 기본값 : undefined<br>[[Writable]] 의 기본값 : false<br>[[Enumerable]] 의 기본값 : false<br>[[Configuarable]] 의 기본값 : false

----

#### 접근자 프로퍼티 정의

![캡쳐110](https://user-images.githubusercontent.com/62126380/82138079-9dc99800-9858-11ea-8802-d6ed4389caba.PNG) 

- Object.defineProperty 메소드로 프로퍼티를 정의할때 프로퍼티 디스크립터 객체에서 일부의<br>프로퍼티를 생략하면 프로퍼티의 기본값이 적용된다.

  [[Get]] 의 기본값 : undefined<br>[[Set]] 의 기본값 : undefined<br>[[Enumerable]] 의 기본값 : false<br>[[Configuarable]] 의 기본값 : false

  

## 객체 변경 방지

객체를 변경을 방지할수 있는 3가지 메소드가 있다.

1. 객체 확장 금지
2. 객체 밀봉
3. 객체 동결
   -  재할당이 안 이루어지는 상황에서 객체를 원시값처럼 쓰고자 할때에 객체동결(Object.freeze)를 통해서 객체를 얼려서 readOnly하게 만든다. 

==> ∴ 이런게 있다고만 알고 넘어갑시다. 왜냐면, 실무에서는 다 라이브러리를 쓰기 때문에 이것들이 있다고만 알고 넘어가자. *<- 라이브러리 사용하는게 훨씬 안전하다* 

---

---

---



# 생성자 함수에 의한 객체 생성

객체를 생성하는 방법은 다양하다.

1. 객체 리터럴을 사용하여 생성
2. Object 생성자 함수로 생성
3. 생성자 함수로 생성
4. Object.creat 라는 메소드로 생성

위 방법들 중 1번 객체 리터럴을 사용하여 생성하는 건 앞서 다룬 내용이므로, 이번엔 2번부터 시작하는 생성자 함수로 객체를 생성하는 방법을 알아보겠다. 

---



## Object 생성자 함수

__new 연산자__와 함께 __Object 생성자 함수를 호__출 하면 __빈 객체를 생성__하여 반환한다.<br>이 이후에 __프로퍼티 또는 메소드를 추가__하여 빈 객체를 채워서, 내용을 채운 객체를 완성할 수 있다.

반드시 Object 생성자 함수를 사용해서 빈 객체를 생성해야 하는 것은 아니므로, 특별한 이유가 없다면<br>사용하지마라. 유용하지 않은 함수다.

---



## 생성자 함수 

- 생성자 함수 라고 함은, 객체를 만들어내는 목적을 가지고 있는 함수다

- new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수<br>즉, 생성자 함수에 의해 생성된 객체를 인스턴스라고 한다.

- 생성자 함수와 일반 함수가 생긴 것은 똑같이 생겼지만, 구분하기 위해서 생성자 함수의 함수 이름 첫글자를 대문자로 사용한다.( *<-소문자로 해도 Error는 나지 않지만, 구분을 해주자* )

- 생성자 함수에는 여러 빌트인 함수들이 있는데, 그 중에 우리가 만들수 있는 생성자 함수는<br>Object 생성자 함수 / String 생성자 함수 / Number 생성자 함수 / Boolean 생성자 함수 <br>/ Function 생성자 함수 / Array 생성자 함수/ Date 생성자 함수 / RegExp 생성자 함수 이다. 

  ```js
  1. String 생성자 함수를 사용하여 생성한 String 객체
  const strObj = new String('Lee');
  console.log(typeof strObj); // object (문자열 객체)
  console.log(strObj); // String {"Lee"}
  
  2. Number 생성자 함수를 사용하여 생성한 Number 객체
  const numObj = new Number(123); 
  console.log(typeof munObj); // object(number 객체)
  console.log(numObj); // Number {123}
  
  3. Boolean 생성자 함수를 사용하여 생성한 Boolean 객체
  const booObj = new Boolean(true);
  console.log(typeof booObj); // object(boolean 객체)
  console.log(booObj); // Boolean {true}
  
  4. Function 생성자 함수를 사용하여 생성한 Function 객체
  const func = new Function('x', 'return x * x');
  console.log(typeof func); // object(function 함수 객체)
  console.log(func); // ƒ anonymous(x)
  
  5. Array 생성자 함수를 사용하여 생성한 Array 객체
  const arr = new Array(1, 2, 3);
  consoel.log(typeof arr); // object(array 객체)
  console.log(arr); // [1, 2, 3]
  
  6. Date 생성자 함수를 사용하여 생성한 Date 객체
  const date = new Date();
  conosole.log(typeof date); // object(date 객체)
  console.log(date); // Sun May 17 2020 21:17:00 GMT+0900 
  
  7. RegExp 생성자 함수를 사용하여 생성한 RegExp 객체 
  ```

- 객체 리터럴에 의한 객체 생성은 단 하나의 객체만 생성하기 때문에 프로퍼티 구조가 똑같으면 매번 똑같은  객체를 만들어야 하므로 비효율 적이다 -> 프로퍼티 구조가 똑같은 객체라면, 생성자 함수로 <br>객체를 짧고 간결하게 만들 수 있다.  <br>(대부분 객체마다 프로퍼티 값이 다를수 있지만 메소드는 내용이 동일한 경우가 일반적이기 때문이다.)

  ![캡쳐111](https://user-images.githubusercontent.com/62126380/82146669-e9933600-9886-11ea-8535-faedbc3b1eb4.PNG) 

  위 코드에서 볼수 있듯이,

  1. 생성자 함수 내부에서의 this 
     - 생성자 함수가 미래에 생성할 인스턴스를 가리킨다.
     - this에는 우리가 필요로 하는 프로퍼티를 담는다.(그러므로, this 뒤에는 꼭 프로퍼티가 와야 한다)
     - 생성자 함수 내부에서의 this는 문맥에 따라서 가리키는 값이 달라진다. 

  2. news 연산자를 통해서 생성자 함수를 호출했다. 
     - new를 쓰지 않고 호출하면 undefined 가 나오고, new를 붙여야 값이 호출된다.





## 생성자 함수에 의한 객체 생성 방식의 장점

여러개 만들어야 한다. 몇개? 하여간 여러개. 그렇단 얘기죠. 

![image-20200504161723182](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504161723182.png) 

여기서 디스는 누굴 가리킬까요, 외우세요. 생성자 함수 내부에서 디스는 누구다? 생성자 함수가 생성할 인스턴스다. 객체 리터럴 내부에 메소드 내부에서 사용한 디스는 그 메소드를 호출할 객체다. 그 메소드가 소속한 객체가 아니고

일반함수에서 디스를 쓸수 있을까? 일반함수라는 것은 기존에 우리가 호출한거. 쓸수 있을까? 왜 있지?

원래 쓰면 안된다. 디스는 왜 쓰지? 디스는 원래 객체지향에서 의미가 있는거다.

일반함수에서 디스 왜써? 의미 없는거다. 근데 자스는 디스가 있어야 함.

일반함수에서 디스는 무조건 전역객체다. 

![image-20200504161938329](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504161938329.png) 

디스가 가리키는 값이 중요하다

우리가 함수라고 불리는 것이 일반 함수로서 호출될때가 있고 메소드로서 호출될때가 있고 생성자 함수로서 호출될때 장면이 잇다. 

![image-20200504162106833](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504162106833.png) 

위에 보면 일반함수같다. 여기서 디스는 전역객체다.

![image-20200504162204425](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504162204425.png) 

생성자 함수로서 호출했다는 것은 뉴와 함께 호출했다는 것이다.

![image-20200504162553404](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504162553404.png)

그럼 우리가 명시적으로 리턴하면 어케 될까? 그래서 어떤 객체를 리턴했다고 하면 우리가 명시적으로 리턴한 객체가 된다. 그러니까 주의해야 한다. 

원시값을 리턴하면 무시당한다.



## 내부 메소드

new : 연산자다.

얘 뒤에는, 우항에는 함수가 온다. 생성자 함수라는 문법이 있나요? 생성자 함수라는 문법을 지키면 생긴다는 식의 문법은 없다. ... 로도 될수 있다.

따라서 일반함수는 일반함수라는건 함수만드는거  몇가지? 

펑션 푸()

콘스트 푸 = 펑션() {}

위 두개는 생성자함수도, .. 도 호출할수 있다.

콘스트 푸 = ( )=> {})

위 하나는 생성자 함수로 호출 못한다.



우리가 일반적으로 메소드라는거. 객체 지향언어에서 다 메소드라고 한다.

우리가 메소드라고 통상 부르는거랑 에크마 에서 부르는 메소드는 다른거다. 

에크마에서 메소드라고 부르는 애는 단하나. 메소드 축햑형. (푸 () {}) 얘네만 문법상 메소드라고 한다.

에크마에서 메소드라고 지칭하는건 생성자 함수로 호출할수 없다. 메소드를 왜 생성자 함수로 호출하냐고~ 당연한거다. 

함수들의 종류가 있다.

생성자 함수로 호출할수 있고 없는 함수가 있다.

생성자 함수로서 호출 가능한거 함수 선언문, 함수 표현식

근데 생성자 함수로서 호출 안되는건 다 이엑스 식스 문법이다. 메소드랑 화살표함수. 

함수라는게 기본적으로 어떤 특성을 갖고 있어야 하나? 함수도 객체라매. 객체랑 함수의 차이는?

객체가 함수보다 큰 개념이다.

그러면 함수는 객체의 특성을 모두 갖고 잇을까?  싹 다 갖고 있다. 

그런데 함수만의 특징을 갖고잇다. 그 특징은 쉽게 말해서 호출할수 있다.

객체는 호출할수 없다

함수를 호출하면 함수가 내부적으로 [[call]] [[construct]] 얘네 내부 메소드다

함수 객체를 가리키는 식별자 ( )

위 두개를 호출하는거다. 내부동작이. 

어쩔때 콜, 어쩔대 콘스트럭 호출하느냐.

함수가 함수 선언문이랑 함수 표현식이 잇는데 [[콜]] [[콘스트럭트]] 둘다 가능하다. 둘다 가지고 있다. 

근데 콘스트럭트 화살표함수는 콜을 갖고잇다. 콜을 안갖고잇으면 함수가 아니다. 

근데 콘스트럭트는 있는애 가 잇고 없는 애가 있다. 없는 애를 논 컨스트럭트 , 있는애를 콘스트럭트라고 한다. 

![image-20200504163840394](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504163840394.png) 

위의 메소드는 콘스트럭트다. 뉴와 함께 호출할수 있다. 

그러면 콜 메소드도 갖고 잇고 내부에서 콘스트럭트고 갖고 있어서 함구 객체가 크다는 얘기다.

이렇게 저렇게 호출할수도 있다. 쓸데없는 기능을 갖고잇다는 얘기다. 

그래서 비효율적이다. 함수라는게 생성자, 일반 함수로도 호출할수 잇다. 이게 생성자 함수인지 일반 함수인지 파스칼케이스로 구분해서 알려줘라. 

함수를 만들때 파스칼케이스로 만들어줬는데 왜 생성자 함수로 호출 안했어? 라고 하는게 아니라 그 버튼을 만들지 말았어야지.

![image-20200504164417321](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504164417321.png) 

뉴를 안붙이는 경우 : 일반함수로 호출 한거. 그냥 일반함수 하듯이 선언문 먼저 찾는다. 



## 뉴 타겟

예를 들어서 

![image-20200504165909203](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504165909203.png) 



뉴.타겟 : 함수 객체를 가리키고 있다. 그래서 빈객체가 아니라는거다. 뉴와 함께 호출하지 않으면 언디파인드가 된다. 



![image-20200504170157078](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504170157078.png) 









방어코드가 있을까 없을까. 있다. 오브젝트도  뉴 오브젝트에서 빈객체 만들수 있었죠. 

펑션 생성자 함수도 ... 

문제는 얘네들이야.  빌트인 생성자 함수(Object, String, Number, Boolean, Function, Array, Date, RegExp, Promise 등) 얘네들. 

행동들이 일관되자 않다. 

![image-20200504170522844](C:\Users\강호승\AppData\Roaming\Typora\typora-user-images\image-20200504170522844.png) 

위처럼 띄지 말고 붙여줘야 한다. 



디스를 안보는 메소드를 정적 메소드라고 한다.



예습 :  18, 19

---

---

---





































